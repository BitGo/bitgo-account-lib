/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.protocol = (function() {

    /**
     * Namespace protocol.
     * @exports protocol
     * @namespace
     */
    var protocol = {};

    protocol.Endpoint = (function() {

        /**
         * Properties of an Endpoint.
         * @memberof protocol
         * @interface IEndpoint
         * @property {Uint8Array|null} [address] Endpoint address
         * @property {number|null} [port] Endpoint port
         * @property {Uint8Array|null} [nodeId] Endpoint nodeId
         */

        /**
         * Constructs a new Endpoint.
         * @memberof protocol
         * @classdesc Represents an Endpoint.
         * @implements IEndpoint
         * @constructor
         * @param {protocol.IEndpoint=} [properties] Properties to set
         */
        function Endpoint(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Endpoint address.
         * @member {Uint8Array} address
         * @memberof protocol.Endpoint
         * @instance
         */
        Endpoint.prototype.address = $util.newBuffer([]);

        /**
         * Endpoint port.
         * @member {number} port
         * @memberof protocol.Endpoint
         * @instance
         */
        Endpoint.prototype.port = 0;

        /**
         * Endpoint nodeId.
         * @member {Uint8Array} nodeId
         * @memberof protocol.Endpoint
         * @instance
         */
        Endpoint.prototype.nodeId = $util.newBuffer([]);

        /**
         * Creates a new Endpoint instance using the specified properties.
         * @function create
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.IEndpoint=} [properties] Properties to set
         * @returns {protocol.Endpoint} Endpoint instance
         */
        Endpoint.create = function create(properties) {
            return new Endpoint(properties);
        };

        /**
         * Encodes the specified Endpoint message. Does not implicitly {@link protocol.Endpoint.verify|verify} messages.
         * @function encode
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.IEndpoint} message Endpoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Endpoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.port != null && message.hasOwnProperty("port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.nodeId);
            return writer;
        };

        /**
         * Encodes the specified Endpoint message, length delimited. Does not implicitly {@link protocol.Endpoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.IEndpoint} message Endpoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Endpoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Endpoint message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Endpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Endpoint} Endpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Endpoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Endpoint();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.port = reader.int32();
                    break;
                case 3:
                    message.nodeId = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Endpoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Endpoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Endpoint} Endpoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Endpoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Endpoint message.
         * @function verify
         * @memberof protocol.Endpoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Endpoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!(message.nodeId && typeof message.nodeId.length === "number" || $util.isString(message.nodeId)))
                    return "nodeId: buffer expected";
            return null;
        };

        /**
         * Creates an Endpoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Endpoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Endpoint} Endpoint
         */
        Endpoint.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Endpoint)
                return object;
            var message = new $root.protocol.Endpoint();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.port != null)
                message.port = object.port | 0;
            if (object.nodeId != null)
                if (typeof object.nodeId === "string")
                    $util.base64.decode(object.nodeId, message.nodeId = $util.newBuffer($util.base64.length(object.nodeId)), 0);
                else if (object.nodeId.length)
                    message.nodeId = object.nodeId;
            return message;
        };

        /**
         * Creates a plain object from an Endpoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Endpoint
         * @static
         * @param {protocol.Endpoint} message Endpoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Endpoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                object.port = 0;
                if (options.bytes === String)
                    object.nodeId = "";
                else {
                    object.nodeId = [];
                    if (options.bytes !== Array)
                        object.nodeId = $util.newBuffer(object.nodeId);
                }
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = options.bytes === String ? $util.base64.encode(message.nodeId, 0, message.nodeId.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodeId) : message.nodeId;
            return object;
        };

        /**
         * Converts this Endpoint to JSON.
         * @function toJSON
         * @memberof protocol.Endpoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Endpoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Endpoint;
    })();

    protocol.PingMessage = (function() {

        /**
         * Properties of a PingMessage.
         * @memberof protocol
         * @interface IPingMessage
         * @property {protocol.IEndpoint|null} [from] PingMessage from
         * @property {protocol.IEndpoint|null} [to] PingMessage to
         * @property {number|null} [version] PingMessage version
         * @property {number|Long|null} [timestamp] PingMessage timestamp
         */

        /**
         * Constructs a new PingMessage.
         * @memberof protocol
         * @classdesc Represents a PingMessage.
         * @implements IPingMessage
         * @constructor
         * @param {protocol.IPingMessage=} [properties] Properties to set
         */
        function PingMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingMessage from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.from = null;

        /**
         * PingMessage to.
         * @member {protocol.IEndpoint|null|undefined} to
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.to = null;

        /**
         * PingMessage version.
         * @member {number} version
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.version = 0;

        /**
         * PingMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.PingMessage
         * @instance
         */
        PingMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PingMessage instance using the specified properties.
         * @function create
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.IPingMessage=} [properties] Properties to set
         * @returns {protocol.PingMessage} PingMessage instance
         */
        PingMessage.create = function create(properties) {
            return new PingMessage(properties);
        };

        /**
         * Encodes the specified PingMessage message. Does not implicitly {@link protocol.PingMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.IPingMessage} message PingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.to != null && message.hasOwnProperty("to"))
                $root.protocol.Endpoint.encode(message.to, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.version);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PingMessage message, length delimited. Does not implicitly {@link protocol.PingMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.IPingMessage} message PingMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.PingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.PingMessage} PingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.PingMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.to = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.PingMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.PingMessage} PingMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingMessage message.
         * @function verify
         * @memberof protocol.PingMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.to != null && message.hasOwnProperty("to")) {
                var error = $root.protocol.Endpoint.verify(message.to);
                if (error)
                    return "to." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PingMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.PingMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.PingMessage} PingMessage
         */
        PingMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.PingMessage)
                return object;
            var message = new $root.protocol.PingMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.PingMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.to != null) {
                if (typeof object.to !== "object")
                    throw TypeError(".protocol.PingMessage.to: object expected");
                message.to = $root.protocol.Endpoint.fromObject(object.to);
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PingMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.PingMessage
         * @static
         * @param {protocol.PingMessage} message PingMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.to = null;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = $root.protocol.Endpoint.toObject(message.to, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this PingMessage to JSON.
         * @function toJSON
         * @memberof protocol.PingMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PingMessage;
    })();

    protocol.PongMessage = (function() {

        /**
         * Properties of a PongMessage.
         * @memberof protocol
         * @interface IPongMessage
         * @property {protocol.IEndpoint|null} [from] PongMessage from
         * @property {number|null} [echo] PongMessage echo
         * @property {number|Long|null} [timestamp] PongMessage timestamp
         */

        /**
         * Constructs a new PongMessage.
         * @memberof protocol
         * @classdesc Represents a PongMessage.
         * @implements IPongMessage
         * @constructor
         * @param {protocol.IPongMessage=} [properties] Properties to set
         */
        function PongMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PongMessage from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.PongMessage
         * @instance
         */
        PongMessage.prototype.from = null;

        /**
         * PongMessage echo.
         * @member {number} echo
         * @memberof protocol.PongMessage
         * @instance
         */
        PongMessage.prototype.echo = 0;

        /**
         * PongMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.PongMessage
         * @instance
         */
        PongMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PongMessage instance using the specified properties.
         * @function create
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.IPongMessage=} [properties] Properties to set
         * @returns {protocol.PongMessage} PongMessage instance
         */
        PongMessage.create = function create(properties) {
            return new PongMessage(properties);
        };

        /**
         * Encodes the specified PongMessage message. Does not implicitly {@link protocol.PongMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.IPongMessage} message PongMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.echo != null && message.hasOwnProperty("echo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.echo);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified PongMessage message, length delimited. Does not implicitly {@link protocol.PongMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.IPongMessage} message PongMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PongMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.PongMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.PongMessage} PongMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.PongMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.echo = reader.int32();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PongMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.PongMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.PongMessage} PongMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PongMessage message.
         * @function verify
         * @memberof protocol.PongMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PongMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.echo != null && message.hasOwnProperty("echo"))
                if (!$util.isInteger(message.echo))
                    return "echo: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a PongMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.PongMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.PongMessage} PongMessage
         */
        PongMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.PongMessage)
                return object;
            var message = new $root.protocol.PongMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.PongMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.echo != null)
                message.echo = object.echo | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PongMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.PongMessage
         * @static
         * @param {protocol.PongMessage} message PongMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PongMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.echo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.echo != null && message.hasOwnProperty("echo"))
                object.echo = message.echo;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this PongMessage to JSON.
         * @function toJSON
         * @memberof protocol.PongMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PongMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PongMessage;
    })();

    protocol.FindNeighbours = (function() {

        /**
         * Properties of a FindNeighbours.
         * @memberof protocol
         * @interface IFindNeighbours
         * @property {protocol.IEndpoint|null} [from] FindNeighbours from
         * @property {Uint8Array|null} [targetId] FindNeighbours targetId
         * @property {number|Long|null} [timestamp] FindNeighbours timestamp
         */

        /**
         * Constructs a new FindNeighbours.
         * @memberof protocol
         * @classdesc Represents a FindNeighbours.
         * @implements IFindNeighbours
         * @constructor
         * @param {protocol.IFindNeighbours=} [properties] Properties to set
         */
        function FindNeighbours(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FindNeighbours from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.FindNeighbours
         * @instance
         */
        FindNeighbours.prototype.from = null;

        /**
         * FindNeighbours targetId.
         * @member {Uint8Array} targetId
         * @memberof protocol.FindNeighbours
         * @instance
         */
        FindNeighbours.prototype.targetId = $util.newBuffer([]);

        /**
         * FindNeighbours timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.FindNeighbours
         * @instance
         */
        FindNeighbours.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new FindNeighbours instance using the specified properties.
         * @function create
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.IFindNeighbours=} [properties] Properties to set
         * @returns {protocol.FindNeighbours} FindNeighbours instance
         */
        FindNeighbours.create = function create(properties) {
            return new FindNeighbours(properties);
        };

        /**
         * Encodes the specified FindNeighbours message. Does not implicitly {@link protocol.FindNeighbours.verify|verify} messages.
         * @function encode
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.IFindNeighbours} message FindNeighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindNeighbours.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.targetId);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified FindNeighbours message, length delimited. Does not implicitly {@link protocol.FindNeighbours.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.IFindNeighbours} message FindNeighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FindNeighbours.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FindNeighbours message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.FindNeighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.FindNeighbours} FindNeighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindNeighbours.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.FindNeighbours();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.targetId = reader.bytes();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FindNeighbours message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.FindNeighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.FindNeighbours} FindNeighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FindNeighbours.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FindNeighbours message.
         * @function verify
         * @memberof protocol.FindNeighbours
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FindNeighbours.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                if (!(message.targetId && typeof message.targetId.length === "number" || $util.isString(message.targetId)))
                    return "targetId: buffer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a FindNeighbours message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.FindNeighbours
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.FindNeighbours} FindNeighbours
         */
        FindNeighbours.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.FindNeighbours)
                return object;
            var message = new $root.protocol.FindNeighbours();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.FindNeighbours.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.targetId != null)
                if (typeof object.targetId === "string")
                    $util.base64.decode(object.targetId, message.targetId = $util.newBuffer($util.base64.length(object.targetId)), 0);
                else if (object.targetId.length)
                    message.targetId = object.targetId;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FindNeighbours message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.FindNeighbours
         * @static
         * @param {protocol.FindNeighbours} message FindNeighbours
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FindNeighbours.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                if (options.bytes === String)
                    object.targetId = "";
                else {
                    object.targetId = [];
                    if (options.bytes !== Array)
                        object.targetId = $util.newBuffer(object.targetId);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.targetId != null && message.hasOwnProperty("targetId"))
                object.targetId = options.bytes === String ? $util.base64.encode(message.targetId, 0, message.targetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.targetId) : message.targetId;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this FindNeighbours to JSON.
         * @function toJSON
         * @memberof protocol.FindNeighbours
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FindNeighbours.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FindNeighbours;
    })();

    protocol.Neighbours = (function() {

        /**
         * Properties of a Neighbours.
         * @memberof protocol
         * @interface INeighbours
         * @property {protocol.IEndpoint|null} [from] Neighbours from
         * @property {Array.<protocol.IEndpoint>|null} [neighbours] Neighbours neighbours
         * @property {number|Long|null} [timestamp] Neighbours timestamp
         */

        /**
         * Constructs a new Neighbours.
         * @memberof protocol
         * @classdesc Represents a Neighbours.
         * @implements INeighbours
         * @constructor
         * @param {protocol.INeighbours=} [properties] Properties to set
         */
        function Neighbours(properties) {
            this.neighbours = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Neighbours from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.Neighbours
         * @instance
         */
        Neighbours.prototype.from = null;

        /**
         * Neighbours neighbours.
         * @member {Array.<protocol.IEndpoint>} neighbours
         * @memberof protocol.Neighbours
         * @instance
         */
        Neighbours.prototype.neighbours = $util.emptyArray;

        /**
         * Neighbours timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.Neighbours
         * @instance
         */
        Neighbours.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Neighbours instance using the specified properties.
         * @function create
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.INeighbours=} [properties] Properties to set
         * @returns {protocol.Neighbours} Neighbours instance
         */
        Neighbours.create = function create(properties) {
            return new Neighbours(properties);
        };

        /**
         * Encodes the specified Neighbours message. Does not implicitly {@link protocol.Neighbours.verify|verify} messages.
         * @function encode
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.INeighbours} message Neighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Neighbours.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.neighbours != null && message.neighbours.length)
                for (var i = 0; i < message.neighbours.length; ++i)
                    $root.protocol.Endpoint.encode(message.neighbours[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            return writer;
        };

        /**
         * Encodes the specified Neighbours message, length delimited. Does not implicitly {@link protocol.Neighbours.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.INeighbours} message Neighbours message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Neighbours.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Neighbours message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Neighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Neighbours} Neighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Neighbours.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Neighbours();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.neighbours && message.neighbours.length))
                        message.neighbours = [];
                    message.neighbours.push($root.protocol.Endpoint.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Neighbours message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Neighbours
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Neighbours} Neighbours
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Neighbours.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Neighbours message.
         * @function verify
         * @memberof protocol.Neighbours
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Neighbours.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.neighbours != null && message.hasOwnProperty("neighbours")) {
                if (!Array.isArray(message.neighbours))
                    return "neighbours: array expected";
                for (var i = 0; i < message.neighbours.length; ++i) {
                    var error = $root.protocol.Endpoint.verify(message.neighbours[i]);
                    if (error)
                        return "neighbours." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            return null;
        };

        /**
         * Creates a Neighbours message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Neighbours
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Neighbours} Neighbours
         */
        Neighbours.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Neighbours)
                return object;
            var message = new $root.protocol.Neighbours();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.Neighbours.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.neighbours) {
                if (!Array.isArray(object.neighbours))
                    throw TypeError(".protocol.Neighbours.neighbours: array expected");
                message.neighbours = [];
                for (var i = 0; i < object.neighbours.length; ++i) {
                    if (typeof object.neighbours[i] !== "object")
                        throw TypeError(".protocol.Neighbours.neighbours: object expected");
                    message.neighbours[i] = $root.protocol.Endpoint.fromObject(object.neighbours[i]);
                }
            }
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Neighbours message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Neighbours
         * @static
         * @param {protocol.Neighbours} message Neighbours
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Neighbours.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.neighbours = [];
            if (options.defaults) {
                object.from = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.neighbours && message.neighbours.length) {
                object.neighbours = [];
                for (var j = 0; j < message.neighbours.length; ++j)
                    object.neighbours[j] = $root.protocol.Endpoint.toObject(message.neighbours[j], options);
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            return object;
        };

        /**
         * Converts this Neighbours to JSON.
         * @function toJSON
         * @memberof protocol.Neighbours
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Neighbours.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Neighbours;
    })();

    protocol.BackupMessage = (function() {

        /**
         * Properties of a BackupMessage.
         * @memberof protocol
         * @interface IBackupMessage
         * @property {boolean|null} [flag] BackupMessage flag
         * @property {number|null} [priority] BackupMessage priority
         */

        /**
         * Constructs a new BackupMessage.
         * @memberof protocol
         * @classdesc Represents a BackupMessage.
         * @implements IBackupMessage
         * @constructor
         * @param {protocol.IBackupMessage=} [properties] Properties to set
         */
        function BackupMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BackupMessage flag.
         * @member {boolean} flag
         * @memberof protocol.BackupMessage
         * @instance
         */
        BackupMessage.prototype.flag = false;

        /**
         * BackupMessage priority.
         * @member {number} priority
         * @memberof protocol.BackupMessage
         * @instance
         */
        BackupMessage.prototype.priority = 0;

        /**
         * Creates a new BackupMessage instance using the specified properties.
         * @function create
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.IBackupMessage=} [properties] Properties to set
         * @returns {protocol.BackupMessage} BackupMessage instance
         */
        BackupMessage.create = function create(properties) {
            return new BackupMessage(properties);
        };

        /**
         * Encodes the specified BackupMessage message. Does not implicitly {@link protocol.BackupMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.IBackupMessage} message BackupMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flag != null && message.hasOwnProperty("flag"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.flag);
            if (message.priority != null && message.hasOwnProperty("priority"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.priority);
            return writer;
        };

        /**
         * Encodes the specified BackupMessage message, length delimited. Does not implicitly {@link protocol.BackupMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.IBackupMessage} message BackupMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BackupMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BackupMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BackupMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BackupMessage} BackupMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BackupMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.flag = reader.bool();
                    break;
                case 2:
                    message.priority = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BackupMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BackupMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BackupMessage} BackupMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BackupMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BackupMessage message.
         * @function verify
         * @memberof protocol.BackupMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BackupMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (typeof message.flag !== "boolean")
                    return "flag: boolean expected";
            if (message.priority != null && message.hasOwnProperty("priority"))
                if (!$util.isInteger(message.priority))
                    return "priority: integer expected";
            return null;
        };

        /**
         * Creates a BackupMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BackupMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BackupMessage} BackupMessage
         */
        BackupMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BackupMessage)
                return object;
            var message = new $root.protocol.BackupMessage();
            if (object.flag != null)
                message.flag = Boolean(object.flag);
            if (object.priority != null)
                message.priority = object.priority | 0;
            return message;
        };

        /**
         * Creates a plain object from a BackupMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BackupMessage
         * @static
         * @param {protocol.BackupMessage} message BackupMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BackupMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.flag = false;
                object.priority = 0;
            }
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.priority != null && message.hasOwnProperty("priority"))
                object.priority = message.priority;
            return object;
        };

        /**
         * Converts this BackupMessage to JSON.
         * @function toJSON
         * @memberof protocol.BackupMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BackupMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BackupMessage;
    })();

    protocol.AccountCreateContract = (function() {

        /**
         * Properties of an AccountCreateContract.
         * @memberof protocol
         * @interface IAccountCreateContract
         * @property {Uint8Array|null} [owner_address] AccountCreateContract owner_address
         * @property {Uint8Array|null} [account_address] AccountCreateContract account_address
         * @property {protocol.AccountType|null} [type] AccountCreateContract type
         */

        /**
         * Constructs a new AccountCreateContract.
         * @memberof protocol
         * @classdesc Represents an AccountCreateContract.
         * @implements IAccountCreateContract
         * @constructor
         * @param {protocol.IAccountCreateContract=} [properties] Properties to set
         */
        function AccountCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountCreateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.AccountCreateContract
         * @instance
         */
        AccountCreateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * AccountCreateContract account_address.
         * @member {Uint8Array} account_address
         * @memberof protocol.AccountCreateContract
         * @instance
         */
        AccountCreateContract.prototype.account_address = $util.newBuffer([]);

        /**
         * AccountCreateContract type.
         * @member {protocol.AccountType} type
         * @memberof protocol.AccountCreateContract
         * @instance
         */
        AccountCreateContract.prototype.type = 0;

        /**
         * Creates a new AccountCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.IAccountCreateContract=} [properties] Properties to set
         * @returns {protocol.AccountCreateContract} AccountCreateContract instance
         */
        AccountCreateContract.create = function create(properties) {
            return new AccountCreateContract(properties);
        };

        /**
         * Encodes the specified AccountCreateContract message. Does not implicitly {@link protocol.AccountCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.IAccountCreateContract} message AccountCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.account_address != null && message.hasOwnProperty("account_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.account_address);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified AccountCreateContract message, length delimited. Does not implicitly {@link protocol.AccountCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.IAccountCreateContract} message AccountCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountCreateContract} AccountCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.account_address = reader.bytes();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountCreateContract} AccountCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountCreateContract message.
         * @function verify
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.account_address != null && message.hasOwnProperty("account_address"))
                if (!(message.account_address && typeof message.account_address.length === "number" || $util.isString(message.account_address)))
                    return "account_address: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an AccountCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountCreateContract} AccountCreateContract
         */
        AccountCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountCreateContract)
                return object;
            var message = new $root.protocol.AccountCreateContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.account_address != null)
                if (typeof object.account_address === "string")
                    $util.base64.decode(object.account_address, message.account_address = $util.newBuffer($util.base64.length(object.account_address)), 0);
                else if (object.account_address.length)
                    message.account_address = object.account_address;
            switch (object.type) {
            case "Normal":
            case 0:
                message.type = 0;
                break;
            case "AssetIssue":
            case 1:
                message.type = 1;
                break;
            case "Contract":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountCreateContract
         * @static
         * @param {protocol.AccountCreateContract} message AccountCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.account_address = "";
                else {
                    object.account_address = [];
                    if (options.bytes !== Array)
                        object.account_address = $util.newBuffer(object.account_address);
                }
                object.type = options.enums === String ? "Normal" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.account_address != null && message.hasOwnProperty("account_address"))
                object.account_address = options.bytes === String ? $util.base64.encode(message.account_address, 0, message.account_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.account_address) : message.account_address;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.AccountType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this AccountCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.AccountCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountCreateContract;
    })();

    protocol.AccountUpdateContract = (function() {

        /**
         * Properties of an AccountUpdateContract.
         * @memberof protocol
         * @interface IAccountUpdateContract
         * @property {Uint8Array|null} [account_name] AccountUpdateContract account_name
         * @property {Uint8Array|null} [owner_address] AccountUpdateContract owner_address
         */

        /**
         * Constructs a new AccountUpdateContract.
         * @memberof protocol
         * @classdesc Represents an AccountUpdateContract.
         * @implements IAccountUpdateContract
         * @constructor
         * @param {protocol.IAccountUpdateContract=} [properties] Properties to set
         */
        function AccountUpdateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUpdateContract account_name.
         * @member {Uint8Array} account_name
         * @memberof protocol.AccountUpdateContract
         * @instance
         */
        AccountUpdateContract.prototype.account_name = $util.newBuffer([]);

        /**
         * AccountUpdateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.AccountUpdateContract
         * @instance
         */
        AccountUpdateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * Creates a new AccountUpdateContract instance using the specified properties.
         * @function create
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.IAccountUpdateContract=} [properties] Properties to set
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract instance
         */
        AccountUpdateContract.create = function create(properties) {
            return new AccountUpdateContract(properties);
        };

        /**
         * Encodes the specified AccountUpdateContract message. Does not implicitly {@link protocol.AccountUpdateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.IAccountUpdateContract} message AccountUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account_name != null && message.hasOwnProperty("account_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account_name);
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner_address);
            return writer;
        };

        /**
         * Encodes the specified AccountUpdateContract message, length delimited. Does not implicitly {@link protocol.AccountUpdateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.IAccountUpdateContract} message AccountUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUpdateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account_name = reader.bytes();
                    break;
                case 2:
                    message.owner_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUpdateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUpdateContract message.
         * @function verify
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account_name != null && message.hasOwnProperty("account_name"))
                if (!(message.account_name && typeof message.account_name.length === "number" || $util.isString(message.account_name)))
                    return "account_name: buffer expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            return null;
        };

        /**
         * Creates an AccountUpdateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountUpdateContract} AccountUpdateContract
         */
        AccountUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountUpdateContract)
                return object;
            var message = new $root.protocol.AccountUpdateContract();
            if (object.account_name != null)
                if (typeof object.account_name === "string")
                    $util.base64.decode(object.account_name, message.account_name = $util.newBuffer($util.base64.length(object.account_name)), 0);
                else if (object.account_name.length)
                    message.account_name = object.account_name;
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            return message;
        };

        /**
         * Creates a plain object from an AccountUpdateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountUpdateContract
         * @static
         * @param {protocol.AccountUpdateContract} message AccountUpdateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.account_name = "";
                else {
                    object.account_name = [];
                    if (options.bytes !== Array)
                        object.account_name = $util.newBuffer(object.account_name);
                }
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
            }
            if (message.account_name != null && message.hasOwnProperty("account_name"))
                object.account_name = options.bytes === String ? $util.base64.encode(message.account_name, 0, message.account_name.length) : options.bytes === Array ? Array.prototype.slice.call(message.account_name) : message.account_name;
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            return object;
        };

        /**
         * Converts this AccountUpdateContract to JSON.
         * @function toJSON
         * @memberof protocol.AccountUpdateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountUpdateContract;
    })();

    protocol.SetAccountIdContract = (function() {

        /**
         * Properties of a SetAccountIdContract.
         * @memberof protocol
         * @interface ISetAccountIdContract
         * @property {Uint8Array|null} [account_id] SetAccountIdContract account_id
         * @property {Uint8Array|null} [owner_address] SetAccountIdContract owner_address
         */

        /**
         * Constructs a new SetAccountIdContract.
         * @memberof protocol
         * @classdesc Represents a SetAccountIdContract.
         * @implements ISetAccountIdContract
         * @constructor
         * @param {protocol.ISetAccountIdContract=} [properties] Properties to set
         */
        function SetAccountIdContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetAccountIdContract account_id.
         * @member {Uint8Array} account_id
         * @memberof protocol.SetAccountIdContract
         * @instance
         */
        SetAccountIdContract.prototype.account_id = $util.newBuffer([]);

        /**
         * SetAccountIdContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.SetAccountIdContract
         * @instance
         */
        SetAccountIdContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * Creates a new SetAccountIdContract instance using the specified properties.
         * @function create
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.ISetAccountIdContract=} [properties] Properties to set
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract instance
         */
        SetAccountIdContract.create = function create(properties) {
            return new SetAccountIdContract(properties);
        };

        /**
         * Encodes the specified SetAccountIdContract message. Does not implicitly {@link protocol.SetAccountIdContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.ISetAccountIdContract} message SetAccountIdContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAccountIdContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account_id);
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner_address);
            return writer;
        };

        /**
         * Encodes the specified SetAccountIdContract message, length delimited. Does not implicitly {@link protocol.SetAccountIdContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.ISetAccountIdContract} message SetAccountIdContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetAccountIdContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetAccountIdContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAccountIdContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SetAccountIdContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account_id = reader.bytes();
                    break;
                case 2:
                    message.owner_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetAccountIdContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetAccountIdContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetAccountIdContract message.
         * @function verify
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetAccountIdContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                if (!(message.account_id && typeof message.account_id.length === "number" || $util.isString(message.account_id)))
                    return "account_id: buffer expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            return null;
        };

        /**
         * Creates a SetAccountIdContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.SetAccountIdContract} SetAccountIdContract
         */
        SetAccountIdContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SetAccountIdContract)
                return object;
            var message = new $root.protocol.SetAccountIdContract();
            if (object.account_id != null)
                if (typeof object.account_id === "string")
                    $util.base64.decode(object.account_id, message.account_id = $util.newBuffer($util.base64.length(object.account_id)), 0);
                else if (object.account_id.length)
                    message.account_id = object.account_id;
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            return message;
        };

        /**
         * Creates a plain object from a SetAccountIdContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.SetAccountIdContract
         * @static
         * @param {protocol.SetAccountIdContract} message SetAccountIdContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetAccountIdContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.account_id = "";
                else {
                    object.account_id = [];
                    if (options.bytes !== Array)
                        object.account_id = $util.newBuffer(object.account_id);
                }
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
            }
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                object.account_id = options.bytes === String ? $util.base64.encode(message.account_id, 0, message.account_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.account_id) : message.account_id;
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            return object;
        };

        /**
         * Converts this SetAccountIdContract to JSON.
         * @function toJSON
         * @memberof protocol.SetAccountIdContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetAccountIdContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetAccountIdContract;
    })();

    protocol.TransferContract = (function() {

        /**
         * Properties of a TransferContract.
         * @memberof protocol
         * @interface ITransferContract
         * @property {Uint8Array|null} [owner_address] TransferContract owner_address
         * @property {Uint8Array|null} [to_address] TransferContract to_address
         * @property {number|Long|null} [amount] TransferContract amount
         */

        /**
         * Constructs a new TransferContract.
         * @memberof protocol
         * @classdesc Represents a TransferContract.
         * @implements ITransferContract
         * @constructor
         * @param {protocol.ITransferContract=} [properties] Properties to set
         */
        function TransferContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.TransferContract
         * @instance
         */
        TransferContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * TransferContract to_address.
         * @member {Uint8Array} to_address
         * @memberof protocol.TransferContract
         * @instance
         */
        TransferContract.prototype.to_address = $util.newBuffer([]);

        /**
         * TransferContract amount.
         * @member {number|Long} amount
         * @memberof protocol.TransferContract
         * @instance
         */
        TransferContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TransferContract instance using the specified properties.
         * @function create
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.ITransferContract=} [properties] Properties to set
         * @returns {protocol.TransferContract} TransferContract instance
         */
        TransferContract.create = function create(properties) {
            return new TransferContract(properties);
        };

        /**
         * Encodes the specified TransferContract message. Does not implicitly {@link protocol.TransferContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.ITransferContract} message TransferContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to_address);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified TransferContract message, length delimited. Does not implicitly {@link protocol.TransferContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.ITransferContract} message TransferContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransferContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransferContract} TransferContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransferContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.to_address = reader.bytes();
                    break;
                case 3:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransferContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransferContract} TransferContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferContract message.
         * @function verify
         * @memberof protocol.TransferContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                if (!(message.to_address && typeof message.to_address.length === "number" || $util.isString(message.to_address)))
                    return "to_address: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransferContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransferContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransferContract} TransferContract
         */
        TransferContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransferContract)
                return object;
            var message = new $root.protocol.TransferContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.to_address != null)
                if (typeof object.to_address === "string")
                    $util.base64.decode(object.to_address, message.to_address = $util.newBuffer($util.base64.length(object.to_address)), 0);
                else if (object.to_address.length)
                    message.to_address = object.to_address;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TransferContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransferContract
         * @static
         * @param {protocol.TransferContract} message TransferContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.to_address = "";
                else {
                    object.to_address = [];
                    if (options.bytes !== Array)
                        object.to_address = $util.newBuffer(object.to_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                object.to_address = options.bytes === String ? $util.base64.encode(message.to_address, 0, message.to_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.to_address) : message.to_address;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this TransferContract to JSON.
         * @function toJSON
         * @memberof protocol.TransferContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferContract;
    })();

    protocol.TransferAssetContract = (function() {

        /**
         * Properties of a TransferAssetContract.
         * @memberof protocol
         * @interface ITransferAssetContract
         * @property {Uint8Array|null} [asset_name] TransferAssetContract asset_name
         * @property {Uint8Array|null} [owner_address] TransferAssetContract owner_address
         * @property {Uint8Array|null} [to_address] TransferAssetContract to_address
         * @property {number|Long|null} [amount] TransferAssetContract amount
         */

        /**
         * Constructs a new TransferAssetContract.
         * @memberof protocol
         * @classdesc Represents a TransferAssetContract.
         * @implements ITransferAssetContract
         * @constructor
         * @param {protocol.ITransferAssetContract=} [properties] Properties to set
         */
        function TransferAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransferAssetContract asset_name.
         * @member {Uint8Array} asset_name
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.asset_name = $util.newBuffer([]);

        /**
         * TransferAssetContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * TransferAssetContract to_address.
         * @member {Uint8Array} to_address
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.to_address = $util.newBuffer([]);

        /**
         * TransferAssetContract amount.
         * @member {number|Long} amount
         * @memberof protocol.TransferAssetContract
         * @instance
         */
        TransferAssetContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TransferAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.ITransferAssetContract=} [properties] Properties to set
         * @returns {protocol.TransferAssetContract} TransferAssetContract instance
         */
        TransferAssetContract.create = function create(properties) {
            return new TransferAssetContract(properties);
        };

        /**
         * Encodes the specified TransferAssetContract message. Does not implicitly {@link protocol.TransferAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.ITransferAssetContract} message TransferAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.asset_name != null && message.hasOwnProperty("asset_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.asset_name);
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner_address);
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.to_address);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified TransferAssetContract message, length delimited. Does not implicitly {@link protocol.TransferAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.ITransferAssetContract} message TransferAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransferAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransferAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransferAssetContract} TransferAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransferAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.asset_name = reader.bytes();
                    break;
                case 2:
                    message.owner_address = reader.bytes();
                    break;
                case 3:
                    message.to_address = reader.bytes();
                    break;
                case 4:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransferAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransferAssetContract} TransferAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransferAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransferAssetContract message.
         * @function verify
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransferAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.asset_name != null && message.hasOwnProperty("asset_name"))
                if (!(message.asset_name && typeof message.asset_name.length === "number" || $util.isString(message.asset_name)))
                    return "asset_name: buffer expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                if (!(message.to_address && typeof message.to_address.length === "number" || $util.isString(message.to_address)))
                    return "to_address: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransferAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransferAssetContract} TransferAssetContract
         */
        TransferAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransferAssetContract)
                return object;
            var message = new $root.protocol.TransferAssetContract();
            if (object.asset_name != null)
                if (typeof object.asset_name === "string")
                    $util.base64.decode(object.asset_name, message.asset_name = $util.newBuffer($util.base64.length(object.asset_name)), 0);
                else if (object.asset_name.length)
                    message.asset_name = object.asset_name;
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.to_address != null)
                if (typeof object.to_address === "string")
                    $util.base64.decode(object.to_address, message.to_address = $util.newBuffer($util.base64.length(object.to_address)), 0);
                else if (object.to_address.length)
                    message.to_address = object.to_address;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TransferAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransferAssetContract
         * @static
         * @param {protocol.TransferAssetContract} message TransferAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransferAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.asset_name = "";
                else {
                    object.asset_name = [];
                    if (options.bytes !== Array)
                        object.asset_name = $util.newBuffer(object.asset_name);
                }
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.to_address = "";
                else {
                    object.to_address = [];
                    if (options.bytes !== Array)
                        object.to_address = $util.newBuffer(object.to_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.asset_name != null && message.hasOwnProperty("asset_name"))
                object.asset_name = options.bytes === String ? $util.base64.encode(message.asset_name, 0, message.asset_name.length) : options.bytes === Array ? Array.prototype.slice.call(message.asset_name) : message.asset_name;
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                object.to_address = options.bytes === String ? $util.base64.encode(message.to_address, 0, message.to_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.to_address) : message.to_address;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this TransferAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.TransferAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransferAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransferAssetContract;
    })();

    protocol.VoteAssetContract = (function() {

        /**
         * Properties of a VoteAssetContract.
         * @memberof protocol
         * @interface IVoteAssetContract
         * @property {Uint8Array|null} [owner_address] VoteAssetContract owner_address
         * @property {Array.<Uint8Array>|null} [vote_address] VoteAssetContract vote_address
         * @property {boolean|null} [support] VoteAssetContract support
         * @property {number|null} [count] VoteAssetContract count
         */

        /**
         * Constructs a new VoteAssetContract.
         * @memberof protocol
         * @classdesc Represents a VoteAssetContract.
         * @implements IVoteAssetContract
         * @constructor
         * @param {protocol.IVoteAssetContract=} [properties] Properties to set
         */
        function VoteAssetContract(properties) {
            this.vote_address = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteAssetContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * VoteAssetContract vote_address.
         * @member {Array.<Uint8Array>} vote_address
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.vote_address = $util.emptyArray;

        /**
         * VoteAssetContract support.
         * @member {boolean} support
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.support = false;

        /**
         * VoteAssetContract count.
         * @member {number} count
         * @memberof protocol.VoteAssetContract
         * @instance
         */
        VoteAssetContract.prototype.count = 0;

        /**
         * Creates a new VoteAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.IVoteAssetContract=} [properties] Properties to set
         * @returns {protocol.VoteAssetContract} VoteAssetContract instance
         */
        VoteAssetContract.create = function create(properties) {
            return new VoteAssetContract(properties);
        };

        /**
         * Encodes the specified VoteAssetContract message. Does not implicitly {@link protocol.VoteAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.IVoteAssetContract} message VoteAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.vote_address != null && message.vote_address.length)
                for (var i = 0; i < message.vote_address.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.vote_address[i]);
            if (message.support != null && message.hasOwnProperty("support"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.support);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified VoteAssetContract message, length delimited. Does not implicitly {@link protocol.VoteAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.IVoteAssetContract} message VoteAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.VoteAssetContract} VoteAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    if (!(message.vote_address && message.vote_address.length))
                        message.vote_address = [];
                    message.vote_address.push(reader.bytes());
                    break;
                case 3:
                    message.support = reader.bool();
                    break;
                case 5:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.VoteAssetContract} VoteAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteAssetContract message.
         * @function verify
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.vote_address != null && message.hasOwnProperty("vote_address")) {
                if (!Array.isArray(message.vote_address))
                    return "vote_address: array expected";
                for (var i = 0; i < message.vote_address.length; ++i)
                    if (!(message.vote_address[i] && typeof message.vote_address[i].length === "number" || $util.isString(message.vote_address[i])))
                        return "vote_address: buffer[] expected";
            }
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        /**
         * Creates a VoteAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.VoteAssetContract} VoteAssetContract
         */
        VoteAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.VoteAssetContract)
                return object;
            var message = new $root.protocol.VoteAssetContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.vote_address) {
                if (!Array.isArray(object.vote_address))
                    throw TypeError(".protocol.VoteAssetContract.vote_address: array expected");
                message.vote_address = [];
                for (var i = 0; i < object.vote_address.length; ++i)
                    if (typeof object.vote_address[i] === "string")
                        $util.base64.decode(object.vote_address[i], message.vote_address[i] = $util.newBuffer($util.base64.length(object.vote_address[i])), 0);
                    else if (object.vote_address[i].length)
                        message.vote_address[i] = object.vote_address[i];
            }
            if (object.support != null)
                message.support = Boolean(object.support);
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };

        /**
         * Creates a plain object from a VoteAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.VoteAssetContract
         * @static
         * @param {protocol.VoteAssetContract} message VoteAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.vote_address = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                object.support = false;
                object.count = 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.vote_address && message.vote_address.length) {
                object.vote_address = [];
                for (var j = 0; j < message.vote_address.length; ++j)
                    object.vote_address[j] = options.bytes === String ? $util.base64.encode(message.vote_address[j], 0, message.vote_address[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.vote_address[j]) : message.vote_address[j];
            }
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };

        /**
         * Converts this VoteAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.VoteAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VoteAssetContract;
    })();

    protocol.VoteWitnessContract = (function() {

        /**
         * Properties of a VoteWitnessContract.
         * @memberof protocol
         * @interface IVoteWitnessContract
         * @property {Uint8Array|null} [owner_address] VoteWitnessContract owner_address
         * @property {Array.<protocol.VoteWitnessContract.IVote>|null} [votes] VoteWitnessContract votes
         * @property {boolean|null} [support] VoteWitnessContract support
         */

        /**
         * Constructs a new VoteWitnessContract.
         * @memberof protocol
         * @classdesc Represents a VoteWitnessContract.
         * @implements IVoteWitnessContract
         * @constructor
         * @param {protocol.IVoteWitnessContract=} [properties] Properties to set
         */
        function VoteWitnessContract(properties) {
            this.votes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteWitnessContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.VoteWitnessContract
         * @instance
         */
        VoteWitnessContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * VoteWitnessContract votes.
         * @member {Array.<protocol.VoteWitnessContract.IVote>} votes
         * @memberof protocol.VoteWitnessContract
         * @instance
         */
        VoteWitnessContract.prototype.votes = $util.emptyArray;

        /**
         * VoteWitnessContract support.
         * @member {boolean} support
         * @memberof protocol.VoteWitnessContract
         * @instance
         */
        VoteWitnessContract.prototype.support = false;

        /**
         * Creates a new VoteWitnessContract instance using the specified properties.
         * @function create
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.IVoteWitnessContract=} [properties] Properties to set
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract instance
         */
        VoteWitnessContract.create = function create(properties) {
            return new VoteWitnessContract(properties);
        };

        /**
         * Encodes the specified VoteWitnessContract message. Does not implicitly {@link protocol.VoteWitnessContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.IVoteWitnessContract} message VoteWitnessContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteWitnessContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.votes != null && message.votes.length)
                for (var i = 0; i < message.votes.length; ++i)
                    $root.protocol.VoteWitnessContract.Vote.encode(message.votes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.support != null && message.hasOwnProperty("support"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.support);
            return writer;
        };

        /**
         * Encodes the specified VoteWitnessContract message, length delimited. Does not implicitly {@link protocol.VoteWitnessContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.IVoteWitnessContract} message VoteWitnessContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteWitnessContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteWitnessContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteWitnessContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteWitnessContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    if (!(message.votes && message.votes.length))
                        message.votes = [];
                    message.votes.push($root.protocol.VoteWitnessContract.Vote.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.support = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteWitnessContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteWitnessContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteWitnessContract message.
         * @function verify
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteWitnessContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.votes != null && message.hasOwnProperty("votes")) {
                if (!Array.isArray(message.votes))
                    return "votes: array expected";
                for (var i = 0; i < message.votes.length; ++i) {
                    var error = $root.protocol.VoteWitnessContract.Vote.verify(message.votes[i]);
                    if (error)
                        return "votes." + error;
                }
            }
            if (message.support != null && message.hasOwnProperty("support"))
                if (typeof message.support !== "boolean")
                    return "support: boolean expected";
            return null;
        };

        /**
         * Creates a VoteWitnessContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.VoteWitnessContract} VoteWitnessContract
         */
        VoteWitnessContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.VoteWitnessContract)
                return object;
            var message = new $root.protocol.VoteWitnessContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.votes) {
                if (!Array.isArray(object.votes))
                    throw TypeError(".protocol.VoteWitnessContract.votes: array expected");
                message.votes = [];
                for (var i = 0; i < object.votes.length; ++i) {
                    if (typeof object.votes[i] !== "object")
                        throw TypeError(".protocol.VoteWitnessContract.votes: object expected");
                    message.votes[i] = $root.protocol.VoteWitnessContract.Vote.fromObject(object.votes[i]);
                }
            }
            if (object.support != null)
                message.support = Boolean(object.support);
            return message;
        };

        /**
         * Creates a plain object from a VoteWitnessContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.VoteWitnessContract
         * @static
         * @param {protocol.VoteWitnessContract} message VoteWitnessContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VoteWitnessContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.votes = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                object.support = false;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.votes && message.votes.length) {
                object.votes = [];
                for (var j = 0; j < message.votes.length; ++j)
                    object.votes[j] = $root.protocol.VoteWitnessContract.Vote.toObject(message.votes[j], options);
            }
            if (message.support != null && message.hasOwnProperty("support"))
                object.support = message.support;
            return object;
        };

        /**
         * Converts this VoteWitnessContract to JSON.
         * @function toJSON
         * @memberof protocol.VoteWitnessContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VoteWitnessContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        VoteWitnessContract.Vote = (function() {

            /**
             * Properties of a Vote.
             * @memberof protocol.VoteWitnessContract
             * @interface IVote
             * @property {Uint8Array|null} [vote_address] Vote vote_address
             * @property {number|Long|null} [vote_count] Vote vote_count
             */

            /**
             * Constructs a new Vote.
             * @memberof protocol.VoteWitnessContract
             * @classdesc Represents a Vote.
             * @implements IVote
             * @constructor
             * @param {protocol.VoteWitnessContract.IVote=} [properties] Properties to set
             */
            function Vote(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Vote vote_address.
             * @member {Uint8Array} vote_address
             * @memberof protocol.VoteWitnessContract.Vote
             * @instance
             */
            Vote.prototype.vote_address = $util.newBuffer([]);

            /**
             * Vote vote_count.
             * @member {number|Long} vote_count
             * @memberof protocol.VoteWitnessContract.Vote
             * @instance
             */
            Vote.prototype.vote_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Vote instance using the specified properties.
             * @function create
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.IVote=} [properties] Properties to set
             * @returns {protocol.VoteWitnessContract.Vote} Vote instance
             */
            Vote.create = function create(properties) {
                return new Vote(properties);
            };

            /**
             * Encodes the specified Vote message. Does not implicitly {@link protocol.VoteWitnessContract.Vote.verify|verify} messages.
             * @function encode
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.IVote} message Vote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vote.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.vote_address != null && message.hasOwnProperty("vote_address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.vote_address);
                if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.vote_count);
                return writer;
            };

            /**
             * Encodes the specified Vote message, length delimited. Does not implicitly {@link protocol.VoteWitnessContract.Vote.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.IVote} message Vote message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vote.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Vote message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.VoteWitnessContract.Vote} Vote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vote.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.VoteWitnessContract.Vote();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.vote_address = reader.bytes();
                        break;
                    case 2:
                        message.vote_count = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Vote message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.VoteWitnessContract.Vote} Vote
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vote.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Vote message.
             * @function verify
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Vote.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.vote_address != null && message.hasOwnProperty("vote_address"))
                    if (!(message.vote_address && typeof message.vote_address.length === "number" || $util.isString(message.vote_address)))
                        return "vote_address: buffer expected";
                if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                    if (!$util.isInteger(message.vote_count) && !(message.vote_count && $util.isInteger(message.vote_count.low) && $util.isInteger(message.vote_count.high)))
                        return "vote_count: integer|Long expected";
                return null;
            };

            /**
             * Creates a Vote message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.VoteWitnessContract.Vote} Vote
             */
            Vote.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.VoteWitnessContract.Vote)
                    return object;
                var message = new $root.protocol.VoteWitnessContract.Vote();
                if (object.vote_address != null)
                    if (typeof object.vote_address === "string")
                        $util.base64.decode(object.vote_address, message.vote_address = $util.newBuffer($util.base64.length(object.vote_address)), 0);
                    else if (object.vote_address.length)
                        message.vote_address = object.vote_address;
                if (object.vote_count != null)
                    if ($util.Long)
                        (message.vote_count = $util.Long.fromValue(object.vote_count)).unsigned = false;
                    else if (typeof object.vote_count === "string")
                        message.vote_count = parseInt(object.vote_count, 10);
                    else if (typeof object.vote_count === "number")
                        message.vote_count = object.vote_count;
                    else if (typeof object.vote_count === "object")
                        message.vote_count = new $util.LongBits(object.vote_count.low >>> 0, object.vote_count.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Vote message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.VoteWitnessContract.Vote
             * @static
             * @param {protocol.VoteWitnessContract.Vote} message Vote
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Vote.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.vote_address = "";
                    else {
                        object.vote_address = [];
                        if (options.bytes !== Array)
                            object.vote_address = $util.newBuffer(object.vote_address);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.vote_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.vote_count = options.longs === String ? "0" : 0;
                }
                if (message.vote_address != null && message.hasOwnProperty("vote_address"))
                    object.vote_address = options.bytes === String ? $util.base64.encode(message.vote_address, 0, message.vote_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.vote_address) : message.vote_address;
                if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                    if (typeof message.vote_count === "number")
                        object.vote_count = options.longs === String ? String(message.vote_count) : message.vote_count;
                    else
                        object.vote_count = options.longs === String ? $util.Long.prototype.toString.call(message.vote_count) : options.longs === Number ? new $util.LongBits(message.vote_count.low >>> 0, message.vote_count.high >>> 0).toNumber() : message.vote_count;
                return object;
            };

            /**
             * Converts this Vote to JSON.
             * @function toJSON
             * @memberof protocol.VoteWitnessContract.Vote
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Vote.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Vote;
        })();

        return VoteWitnessContract;
    })();

    protocol.UpdateSettingContract = (function() {

        /**
         * Properties of an UpdateSettingContract.
         * @memberof protocol
         * @interface IUpdateSettingContract
         * @property {Uint8Array|null} [owner_address] UpdateSettingContract owner_address
         * @property {Uint8Array|null} [contract_address] UpdateSettingContract contract_address
         * @property {number|Long|null} [consume_user_resource_percent] UpdateSettingContract consume_user_resource_percent
         */

        /**
         * Constructs a new UpdateSettingContract.
         * @memberof protocol
         * @classdesc Represents an UpdateSettingContract.
         * @implements IUpdateSettingContract
         * @constructor
         * @param {protocol.IUpdateSettingContract=} [properties] Properties to set
         */
        function UpdateSettingContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateSettingContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.UpdateSettingContract
         * @instance
         */
        UpdateSettingContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * UpdateSettingContract contract_address.
         * @member {Uint8Array} contract_address
         * @memberof protocol.UpdateSettingContract
         * @instance
         */
        UpdateSettingContract.prototype.contract_address = $util.newBuffer([]);

        /**
         * UpdateSettingContract consume_user_resource_percent.
         * @member {number|Long} consume_user_resource_percent
         * @memberof protocol.UpdateSettingContract
         * @instance
         */
        UpdateSettingContract.prototype.consume_user_resource_percent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateSettingContract instance using the specified properties.
         * @function create
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.IUpdateSettingContract=} [properties] Properties to set
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract instance
         */
        UpdateSettingContract.create = function create(properties) {
            return new UpdateSettingContract(properties);
        };

        /**
         * Encodes the specified UpdateSettingContract message. Does not implicitly {@link protocol.UpdateSettingContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.IUpdateSettingContract} message UpdateSettingContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSettingContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract_address);
            if (message.consume_user_resource_percent != null && message.hasOwnProperty("consume_user_resource_percent"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.consume_user_resource_percent);
            return writer;
        };

        /**
         * Encodes the specified UpdateSettingContract message, length delimited. Does not implicitly {@link protocol.UpdateSettingContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.IUpdateSettingContract} message UpdateSettingContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateSettingContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateSettingContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSettingContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateSettingContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.contract_address = reader.bytes();
                    break;
                case 3:
                    message.consume_user_resource_percent = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateSettingContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateSettingContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateSettingContract message.
         * @function verify
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateSettingContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                if (!(message.contract_address && typeof message.contract_address.length === "number" || $util.isString(message.contract_address)))
                    return "contract_address: buffer expected";
            if (message.consume_user_resource_percent != null && message.hasOwnProperty("consume_user_resource_percent"))
                if (!$util.isInteger(message.consume_user_resource_percent) && !(message.consume_user_resource_percent && $util.isInteger(message.consume_user_resource_percent.low) && $util.isInteger(message.consume_user_resource_percent.high)))
                    return "consume_user_resource_percent: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateSettingContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UpdateSettingContract} UpdateSettingContract
         */
        UpdateSettingContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateSettingContract)
                return object;
            var message = new $root.protocol.UpdateSettingContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.contract_address != null)
                if (typeof object.contract_address === "string")
                    $util.base64.decode(object.contract_address, message.contract_address = $util.newBuffer($util.base64.length(object.contract_address)), 0);
                else if (object.contract_address.length)
                    message.contract_address = object.contract_address;
            if (object.consume_user_resource_percent != null)
                if ($util.Long)
                    (message.consume_user_resource_percent = $util.Long.fromValue(object.consume_user_resource_percent)).unsigned = false;
                else if (typeof object.consume_user_resource_percent === "string")
                    message.consume_user_resource_percent = parseInt(object.consume_user_resource_percent, 10);
                else if (typeof object.consume_user_resource_percent === "number")
                    message.consume_user_resource_percent = object.consume_user_resource_percent;
                else if (typeof object.consume_user_resource_percent === "object")
                    message.consume_user_resource_percent = new $util.LongBits(object.consume_user_resource_percent.low >>> 0, object.consume_user_resource_percent.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateSettingContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UpdateSettingContract
         * @static
         * @param {protocol.UpdateSettingContract} message UpdateSettingContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateSettingContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.contract_address = "";
                else {
                    object.contract_address = [];
                    if (options.bytes !== Array)
                        object.contract_address = $util.newBuffer(object.contract_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.consume_user_resource_percent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.consume_user_resource_percent = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                object.contract_address = options.bytes === String ? $util.base64.encode(message.contract_address, 0, message.contract_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_address) : message.contract_address;
            if (message.consume_user_resource_percent != null && message.hasOwnProperty("consume_user_resource_percent"))
                if (typeof message.consume_user_resource_percent === "number")
                    object.consume_user_resource_percent = options.longs === String ? String(message.consume_user_resource_percent) : message.consume_user_resource_percent;
                else
                    object.consume_user_resource_percent = options.longs === String ? $util.Long.prototype.toString.call(message.consume_user_resource_percent) : options.longs === Number ? new $util.LongBits(message.consume_user_resource_percent.low >>> 0, message.consume_user_resource_percent.high >>> 0).toNumber() : message.consume_user_resource_percent;
            return object;
        };

        /**
         * Converts this UpdateSettingContract to JSON.
         * @function toJSON
         * @memberof protocol.UpdateSettingContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateSettingContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateSettingContract;
    })();

    protocol.UpdateEnergyLimitContract = (function() {

        /**
         * Properties of an UpdateEnergyLimitContract.
         * @memberof protocol
         * @interface IUpdateEnergyLimitContract
         * @property {Uint8Array|null} [owner_address] UpdateEnergyLimitContract owner_address
         * @property {Uint8Array|null} [contract_address] UpdateEnergyLimitContract contract_address
         * @property {number|Long|null} [origin_energy_limit] UpdateEnergyLimitContract origin_energy_limit
         */

        /**
         * Constructs a new UpdateEnergyLimitContract.
         * @memberof protocol
         * @classdesc Represents an UpdateEnergyLimitContract.
         * @implements IUpdateEnergyLimitContract
         * @constructor
         * @param {protocol.IUpdateEnergyLimitContract=} [properties] Properties to set
         */
        function UpdateEnergyLimitContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateEnergyLimitContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         */
        UpdateEnergyLimitContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * UpdateEnergyLimitContract contract_address.
         * @member {Uint8Array} contract_address
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         */
        UpdateEnergyLimitContract.prototype.contract_address = $util.newBuffer([]);

        /**
         * UpdateEnergyLimitContract origin_energy_limit.
         * @member {number|Long} origin_energy_limit
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         */
        UpdateEnergyLimitContract.prototype.origin_energy_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateEnergyLimitContract instance using the specified properties.
         * @function create
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.IUpdateEnergyLimitContract=} [properties] Properties to set
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract instance
         */
        UpdateEnergyLimitContract.create = function create(properties) {
            return new UpdateEnergyLimitContract(properties);
        };

        /**
         * Encodes the specified UpdateEnergyLimitContract message. Does not implicitly {@link protocol.UpdateEnergyLimitContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.IUpdateEnergyLimitContract} message UpdateEnergyLimitContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateEnergyLimitContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract_address);
            if (message.origin_energy_limit != null && message.hasOwnProperty("origin_energy_limit"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.origin_energy_limit);
            return writer;
        };

        /**
         * Encodes the specified UpdateEnergyLimitContract message, length delimited. Does not implicitly {@link protocol.UpdateEnergyLimitContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.IUpdateEnergyLimitContract} message UpdateEnergyLimitContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateEnergyLimitContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateEnergyLimitContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateEnergyLimitContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateEnergyLimitContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.contract_address = reader.bytes();
                    break;
                case 3:
                    message.origin_energy_limit = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateEnergyLimitContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateEnergyLimitContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateEnergyLimitContract message.
         * @function verify
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateEnergyLimitContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                if (!(message.contract_address && typeof message.contract_address.length === "number" || $util.isString(message.contract_address)))
                    return "contract_address: buffer expected";
            if (message.origin_energy_limit != null && message.hasOwnProperty("origin_energy_limit"))
                if (!$util.isInteger(message.origin_energy_limit) && !(message.origin_energy_limit && $util.isInteger(message.origin_energy_limit.low) && $util.isInteger(message.origin_energy_limit.high)))
                    return "origin_energy_limit: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateEnergyLimitContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UpdateEnergyLimitContract} UpdateEnergyLimitContract
         */
        UpdateEnergyLimitContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateEnergyLimitContract)
                return object;
            var message = new $root.protocol.UpdateEnergyLimitContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.contract_address != null)
                if (typeof object.contract_address === "string")
                    $util.base64.decode(object.contract_address, message.contract_address = $util.newBuffer($util.base64.length(object.contract_address)), 0);
                else if (object.contract_address.length)
                    message.contract_address = object.contract_address;
            if (object.origin_energy_limit != null)
                if ($util.Long)
                    (message.origin_energy_limit = $util.Long.fromValue(object.origin_energy_limit)).unsigned = false;
                else if (typeof object.origin_energy_limit === "string")
                    message.origin_energy_limit = parseInt(object.origin_energy_limit, 10);
                else if (typeof object.origin_energy_limit === "number")
                    message.origin_energy_limit = object.origin_energy_limit;
                else if (typeof object.origin_energy_limit === "object")
                    message.origin_energy_limit = new $util.LongBits(object.origin_energy_limit.low >>> 0, object.origin_energy_limit.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateEnergyLimitContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UpdateEnergyLimitContract
         * @static
         * @param {protocol.UpdateEnergyLimitContract} message UpdateEnergyLimitContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateEnergyLimitContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.contract_address = "";
                else {
                    object.contract_address = [];
                    if (options.bytes !== Array)
                        object.contract_address = $util.newBuffer(object.contract_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.origin_energy_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.origin_energy_limit = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                object.contract_address = options.bytes === String ? $util.base64.encode(message.contract_address, 0, message.contract_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_address) : message.contract_address;
            if (message.origin_energy_limit != null && message.hasOwnProperty("origin_energy_limit"))
                if (typeof message.origin_energy_limit === "number")
                    object.origin_energy_limit = options.longs === String ? String(message.origin_energy_limit) : message.origin_energy_limit;
                else
                    object.origin_energy_limit = options.longs === String ? $util.Long.prototype.toString.call(message.origin_energy_limit) : options.longs === Number ? new $util.LongBits(message.origin_energy_limit.low >>> 0, message.origin_energy_limit.high >>> 0).toNumber() : message.origin_energy_limit;
            return object;
        };

        /**
         * Converts this UpdateEnergyLimitContract to JSON.
         * @function toJSON
         * @memberof protocol.UpdateEnergyLimitContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateEnergyLimitContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateEnergyLimitContract;
    })();

    protocol.ClearABIContract = (function() {

        /**
         * Properties of a ClearABIContract.
         * @memberof protocol
         * @interface IClearABIContract
         * @property {Uint8Array|null} [owner_address] ClearABIContract owner_address
         * @property {Uint8Array|null} [contract_address] ClearABIContract contract_address
         */

        /**
         * Constructs a new ClearABIContract.
         * @memberof protocol
         * @classdesc Represents a ClearABIContract.
         * @implements IClearABIContract
         * @constructor
         * @param {protocol.IClearABIContract=} [properties] Properties to set
         */
        function ClearABIContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClearABIContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ClearABIContract
         * @instance
         */
        ClearABIContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ClearABIContract contract_address.
         * @member {Uint8Array} contract_address
         * @memberof protocol.ClearABIContract
         * @instance
         */
        ClearABIContract.prototype.contract_address = $util.newBuffer([]);

        /**
         * Creates a new ClearABIContract instance using the specified properties.
         * @function create
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.IClearABIContract=} [properties] Properties to set
         * @returns {protocol.ClearABIContract} ClearABIContract instance
         */
        ClearABIContract.create = function create(properties) {
            return new ClearABIContract(properties);
        };

        /**
         * Encodes the specified ClearABIContract message. Does not implicitly {@link protocol.ClearABIContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.IClearABIContract} message ClearABIContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearABIContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract_address);
            return writer;
        };

        /**
         * Encodes the specified ClearABIContract message, length delimited. Does not implicitly {@link protocol.ClearABIContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.IClearABIContract} message ClearABIContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClearABIContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClearABIContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ClearABIContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ClearABIContract} ClearABIContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearABIContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ClearABIContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.contract_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClearABIContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ClearABIContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ClearABIContract} ClearABIContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClearABIContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClearABIContract message.
         * @function verify
         * @memberof protocol.ClearABIContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClearABIContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                if (!(message.contract_address && typeof message.contract_address.length === "number" || $util.isString(message.contract_address)))
                    return "contract_address: buffer expected";
            return null;
        };

        /**
         * Creates a ClearABIContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ClearABIContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ClearABIContract} ClearABIContract
         */
        ClearABIContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ClearABIContract)
                return object;
            var message = new $root.protocol.ClearABIContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.contract_address != null)
                if (typeof object.contract_address === "string")
                    $util.base64.decode(object.contract_address, message.contract_address = $util.newBuffer($util.base64.length(object.contract_address)), 0);
                else if (object.contract_address.length)
                    message.contract_address = object.contract_address;
            return message;
        };

        /**
         * Creates a plain object from a ClearABIContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ClearABIContract
         * @static
         * @param {protocol.ClearABIContract} message ClearABIContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClearABIContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.contract_address = "";
                else {
                    object.contract_address = [];
                    if (options.bytes !== Array)
                        object.contract_address = $util.newBuffer(object.contract_address);
                }
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                object.contract_address = options.bytes === String ? $util.base64.encode(message.contract_address, 0, message.contract_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_address) : message.contract_address;
            return object;
        };

        /**
         * Converts this ClearABIContract to JSON.
         * @function toJSON
         * @memberof protocol.ClearABIContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClearABIContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClearABIContract;
    })();

    protocol.WitnessCreateContract = (function() {

        /**
         * Properties of a WitnessCreateContract.
         * @memberof protocol
         * @interface IWitnessCreateContract
         * @property {Uint8Array|null} [owner_address] WitnessCreateContract owner_address
         * @property {Uint8Array|null} [url] WitnessCreateContract url
         */

        /**
         * Constructs a new WitnessCreateContract.
         * @memberof protocol
         * @classdesc Represents a WitnessCreateContract.
         * @implements IWitnessCreateContract
         * @constructor
         * @param {protocol.IWitnessCreateContract=} [properties] Properties to set
         */
        function WitnessCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WitnessCreateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.WitnessCreateContract
         * @instance
         */
        WitnessCreateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * WitnessCreateContract url.
         * @member {Uint8Array} url
         * @memberof protocol.WitnessCreateContract
         * @instance
         */
        WitnessCreateContract.prototype.url = $util.newBuffer([]);

        /**
         * Creates a new WitnessCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.IWitnessCreateContract=} [properties] Properties to set
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract instance
         */
        WitnessCreateContract.create = function create(properties) {
            return new WitnessCreateContract(properties);
        };

        /**
         * Encodes the specified WitnessCreateContract message. Does not implicitly {@link protocol.WitnessCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.IWitnessCreateContract} message WitnessCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.url);
            return writer;
        };

        /**
         * Encodes the specified WitnessCreateContract message, length delimited. Does not implicitly {@link protocol.WitnessCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.IWitnessCreateContract} message WitnessCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WitnessCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WitnessCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.url = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WitnessCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WitnessCreateContract message.
         * @function verify
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WitnessCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            return null;
        };

        /**
         * Creates a WitnessCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.WitnessCreateContract} WitnessCreateContract
         */
        WitnessCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WitnessCreateContract)
                return object;
            var message = new $root.protocol.WitnessCreateContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            return message;
        };

        /**
         * Creates a plain object from a WitnessCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.WitnessCreateContract
         * @static
         * @param {protocol.WitnessCreateContract} message WitnessCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WitnessCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            return object;
        };

        /**
         * Converts this WitnessCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.WitnessCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WitnessCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WitnessCreateContract;
    })();

    protocol.WitnessUpdateContract = (function() {

        /**
         * Properties of a WitnessUpdateContract.
         * @memberof protocol
         * @interface IWitnessUpdateContract
         * @property {Uint8Array|null} [owner_address] WitnessUpdateContract owner_address
         * @property {Uint8Array|null} [update_url] WitnessUpdateContract update_url
         */

        /**
         * Constructs a new WitnessUpdateContract.
         * @memberof protocol
         * @classdesc Represents a WitnessUpdateContract.
         * @implements IWitnessUpdateContract
         * @constructor
         * @param {protocol.IWitnessUpdateContract=} [properties] Properties to set
         */
        function WitnessUpdateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WitnessUpdateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.WitnessUpdateContract
         * @instance
         */
        WitnessUpdateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * WitnessUpdateContract update_url.
         * @member {Uint8Array} update_url
         * @memberof protocol.WitnessUpdateContract
         * @instance
         */
        WitnessUpdateContract.prototype.update_url = $util.newBuffer([]);

        /**
         * Creates a new WitnessUpdateContract instance using the specified properties.
         * @function create
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.IWitnessUpdateContract=} [properties] Properties to set
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract instance
         */
        WitnessUpdateContract.create = function create(properties) {
            return new WitnessUpdateContract(properties);
        };

        /**
         * Encodes the specified WitnessUpdateContract message. Does not implicitly {@link protocol.WitnessUpdateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.IWitnessUpdateContract} message WitnessUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.update_url != null && message.hasOwnProperty("update_url"))
                writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.update_url);
            return writer;
        };

        /**
         * Encodes the specified WitnessUpdateContract message, length delimited. Does not implicitly {@link protocol.WitnessUpdateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.IWitnessUpdateContract} message WitnessUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WitnessUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WitnessUpdateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WitnessUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 12:
                    message.update_url = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WitnessUpdateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WitnessUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WitnessUpdateContract message.
         * @function verify
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WitnessUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.update_url != null && message.hasOwnProperty("update_url"))
                if (!(message.update_url && typeof message.update_url.length === "number" || $util.isString(message.update_url)))
                    return "update_url: buffer expected";
            return null;
        };

        /**
         * Creates a WitnessUpdateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.WitnessUpdateContract} WitnessUpdateContract
         */
        WitnessUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WitnessUpdateContract)
                return object;
            var message = new $root.protocol.WitnessUpdateContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.update_url != null)
                if (typeof object.update_url === "string")
                    $util.base64.decode(object.update_url, message.update_url = $util.newBuffer($util.base64.length(object.update_url)), 0);
                else if (object.update_url.length)
                    message.update_url = object.update_url;
            return message;
        };

        /**
         * Creates a plain object from a WitnessUpdateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.WitnessUpdateContract
         * @static
         * @param {protocol.WitnessUpdateContract} message WitnessUpdateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WitnessUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.update_url = "";
                else {
                    object.update_url = [];
                    if (options.bytes !== Array)
                        object.update_url = $util.newBuffer(object.update_url);
                }
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.update_url != null && message.hasOwnProperty("update_url"))
                object.update_url = options.bytes === String ? $util.base64.encode(message.update_url, 0, message.update_url.length) : options.bytes === Array ? Array.prototype.slice.call(message.update_url) : message.update_url;
            return object;
        };

        /**
         * Converts this WitnessUpdateContract to JSON.
         * @function toJSON
         * @memberof protocol.WitnessUpdateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WitnessUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WitnessUpdateContract;
    })();

    protocol.AssetIssueContract = (function() {

        /**
         * Properties of an AssetIssueContract.
         * @memberof protocol
         * @interface IAssetIssueContract
         * @property {string|null} [id] AssetIssueContract id
         * @property {Uint8Array|null} [owner_address] AssetIssueContract owner_address
         * @property {Uint8Array|null} [name] AssetIssueContract name
         * @property {Uint8Array|null} [abbr] AssetIssueContract abbr
         * @property {number|Long|null} [total_supply] AssetIssueContract total_supply
         * @property {Array.<protocol.AssetIssueContract.IFrozenSupply>|null} [frozen_supply] AssetIssueContract frozen_supply
         * @property {number|null} [trx_num] AssetIssueContract trx_num
         * @property {number|null} [precision] AssetIssueContract precision
         * @property {number|null} [num] AssetIssueContract num
         * @property {number|Long|null} [start_time] AssetIssueContract start_time
         * @property {number|Long|null} [end_time] AssetIssueContract end_time
         * @property {number|Long|null} [order] AssetIssueContract order
         * @property {number|null} [vote_score] AssetIssueContract vote_score
         * @property {Uint8Array|null} [description] AssetIssueContract description
         * @property {Uint8Array|null} [url] AssetIssueContract url
         * @property {number|Long|null} [free_asset_net_limit] AssetIssueContract free_asset_net_limit
         * @property {number|Long|null} [public_free_asset_net_limit] AssetIssueContract public_free_asset_net_limit
         * @property {number|Long|null} [public_free_asset_net_usage] AssetIssueContract public_free_asset_net_usage
         * @property {number|Long|null} [public_latest_free_net_time] AssetIssueContract public_latest_free_net_time
         */

        /**
         * Constructs a new AssetIssueContract.
         * @memberof protocol
         * @classdesc Represents an AssetIssueContract.
         * @implements IAssetIssueContract
         * @constructor
         * @param {protocol.IAssetIssueContract=} [properties] Properties to set
         */
        function AssetIssueContract(properties) {
            this.frozen_supply = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AssetIssueContract id.
         * @member {string} id
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.id = "";

        /**
         * AssetIssueContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * AssetIssueContract name.
         * @member {Uint8Array} name
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.name = $util.newBuffer([]);

        /**
         * AssetIssueContract abbr.
         * @member {Uint8Array} abbr
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.abbr = $util.newBuffer([]);

        /**
         * AssetIssueContract total_supply.
         * @member {number|Long} total_supply
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.total_supply = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract frozen_supply.
         * @member {Array.<protocol.AssetIssueContract.IFrozenSupply>} frozen_supply
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.frozen_supply = $util.emptyArray;

        /**
         * AssetIssueContract trx_num.
         * @member {number} trx_num
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.trx_num = 0;

        /**
         * AssetIssueContract precision.
         * @member {number} precision
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.precision = 0;

        /**
         * AssetIssueContract num.
         * @member {number} num
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.num = 0;

        /**
         * AssetIssueContract start_time.
         * @member {number|Long} start_time
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.start_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract end_time.
         * @member {number|Long} end_time
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.end_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract order.
         * @member {number|Long} order
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.order = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract vote_score.
         * @member {number} vote_score
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.vote_score = 0;

        /**
         * AssetIssueContract description.
         * @member {Uint8Array} description
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.description = $util.newBuffer([]);

        /**
         * AssetIssueContract url.
         * @member {Uint8Array} url
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.url = $util.newBuffer([]);

        /**
         * AssetIssueContract free_asset_net_limit.
         * @member {number|Long} free_asset_net_limit
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.free_asset_net_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract public_free_asset_net_limit.
         * @member {number|Long} public_free_asset_net_limit
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.public_free_asset_net_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract public_free_asset_net_usage.
         * @member {number|Long} public_free_asset_net_usage
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.public_free_asset_net_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AssetIssueContract public_latest_free_net_time.
         * @member {number|Long} public_latest_free_net_time
         * @memberof protocol.AssetIssueContract
         * @instance
         */
        AssetIssueContract.prototype.public_latest_free_net_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AssetIssueContract instance using the specified properties.
         * @function create
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.IAssetIssueContract=} [properties] Properties to set
         * @returns {protocol.AssetIssueContract} AssetIssueContract instance
         */
        AssetIssueContract.create = function create(properties) {
            return new AssetIssueContract(properties);
        };

        /**
         * Encodes the specified AssetIssueContract message. Does not implicitly {@link protocol.AssetIssueContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.IAssetIssueContract} message AssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetIssueContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.name);
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.abbr);
            if (message.total_supply != null && message.hasOwnProperty("total_supply"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.total_supply);
            if (message.frozen_supply != null && message.frozen_supply.length)
                for (var i = 0; i < message.frozen_supply.length; ++i)
                    $root.protocol.AssetIssueContract.FrozenSupply.encode(message.frozen_supply[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.trx_num != null && message.hasOwnProperty("trx_num"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.trx_num);
            if (message.precision != null && message.hasOwnProperty("precision"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.precision);
            if (message.num != null && message.hasOwnProperty("num"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.num);
            if (message.start_time != null && message.hasOwnProperty("start_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.start_time);
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.end_time);
            if (message.order != null && message.hasOwnProperty("order"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.order);
            if (message.vote_score != null && message.hasOwnProperty("vote_score"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.vote_score);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 20, wireType 2 =*/162).bytes(message.description);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 21, wireType 2 =*/170).bytes(message.url);
            if (message.free_asset_net_limit != null && message.hasOwnProperty("free_asset_net_limit"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.free_asset_net_limit);
            if (message.public_free_asset_net_limit != null && message.hasOwnProperty("public_free_asset_net_limit"))
                writer.uint32(/* id 23, wireType 0 =*/184).int64(message.public_free_asset_net_limit);
            if (message.public_free_asset_net_usage != null && message.hasOwnProperty("public_free_asset_net_usage"))
                writer.uint32(/* id 24, wireType 0 =*/192).int64(message.public_free_asset_net_usage);
            if (message.public_latest_free_net_time != null && message.hasOwnProperty("public_latest_free_net_time"))
                writer.uint32(/* id 25, wireType 0 =*/200).int64(message.public_latest_free_net_time);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 41, wireType 2 =*/330).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified AssetIssueContract message, length delimited. Does not implicitly {@link protocol.AssetIssueContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.IAssetIssueContract} message AssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AssetIssueContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AssetIssueContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AssetIssueContract} AssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetIssueContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AssetIssueContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 41:
                    message.id = reader.string();
                    break;
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.name = reader.bytes();
                    break;
                case 3:
                    message.abbr = reader.bytes();
                    break;
                case 4:
                    message.total_supply = reader.int64();
                    break;
                case 5:
                    if (!(message.frozen_supply && message.frozen_supply.length))
                        message.frozen_supply = [];
                    message.frozen_supply.push($root.protocol.AssetIssueContract.FrozenSupply.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.trx_num = reader.int32();
                    break;
                case 7:
                    message.precision = reader.int32();
                    break;
                case 8:
                    message.num = reader.int32();
                    break;
                case 9:
                    message.start_time = reader.int64();
                    break;
                case 10:
                    message.end_time = reader.int64();
                    break;
                case 11:
                    message.order = reader.int64();
                    break;
                case 16:
                    message.vote_score = reader.int32();
                    break;
                case 20:
                    message.description = reader.bytes();
                    break;
                case 21:
                    message.url = reader.bytes();
                    break;
                case 22:
                    message.free_asset_net_limit = reader.int64();
                    break;
                case 23:
                    message.public_free_asset_net_limit = reader.int64();
                    break;
                case 24:
                    message.public_free_asset_net_usage = reader.int64();
                    break;
                case 25:
                    message.public_latest_free_net_time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AssetIssueContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AssetIssueContract} AssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AssetIssueContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AssetIssueContract message.
         * @function verify
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AssetIssueContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                if (!(message.abbr && typeof message.abbr.length === "number" || $util.isString(message.abbr)))
                    return "abbr: buffer expected";
            if (message.total_supply != null && message.hasOwnProperty("total_supply"))
                if (!$util.isInteger(message.total_supply) && !(message.total_supply && $util.isInteger(message.total_supply.low) && $util.isInteger(message.total_supply.high)))
                    return "total_supply: integer|Long expected";
            if (message.frozen_supply != null && message.hasOwnProperty("frozen_supply")) {
                if (!Array.isArray(message.frozen_supply))
                    return "frozen_supply: array expected";
                for (var i = 0; i < message.frozen_supply.length; ++i) {
                    var error = $root.protocol.AssetIssueContract.FrozenSupply.verify(message.frozen_supply[i]);
                    if (error)
                        return "frozen_supply." + error;
                }
            }
            if (message.trx_num != null && message.hasOwnProperty("trx_num"))
                if (!$util.isInteger(message.trx_num))
                    return "trx_num: integer expected";
            if (message.precision != null && message.hasOwnProperty("precision"))
                if (!$util.isInteger(message.precision))
                    return "precision: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.start_time != null && message.hasOwnProperty("start_time"))
                if (!$util.isInteger(message.start_time) && !(message.start_time && $util.isInteger(message.start_time.low) && $util.isInteger(message.start_time.high)))
                    return "start_time: integer|Long expected";
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                if (!$util.isInteger(message.end_time) && !(message.end_time && $util.isInteger(message.end_time.low) && $util.isInteger(message.end_time.high)))
                    return "end_time: integer|Long expected";
            if (message.order != null && message.hasOwnProperty("order"))
                if (!$util.isInteger(message.order) && !(message.order && $util.isInteger(message.order.low) && $util.isInteger(message.order.high)))
                    return "order: integer|Long expected";
            if (message.vote_score != null && message.hasOwnProperty("vote_score"))
                if (!$util.isInteger(message.vote_score))
                    return "vote_score: integer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            if (message.free_asset_net_limit != null && message.hasOwnProperty("free_asset_net_limit"))
                if (!$util.isInteger(message.free_asset_net_limit) && !(message.free_asset_net_limit && $util.isInteger(message.free_asset_net_limit.low) && $util.isInteger(message.free_asset_net_limit.high)))
                    return "free_asset_net_limit: integer|Long expected";
            if (message.public_free_asset_net_limit != null && message.hasOwnProperty("public_free_asset_net_limit"))
                if (!$util.isInteger(message.public_free_asset_net_limit) && !(message.public_free_asset_net_limit && $util.isInteger(message.public_free_asset_net_limit.low) && $util.isInteger(message.public_free_asset_net_limit.high)))
                    return "public_free_asset_net_limit: integer|Long expected";
            if (message.public_free_asset_net_usage != null && message.hasOwnProperty("public_free_asset_net_usage"))
                if (!$util.isInteger(message.public_free_asset_net_usage) && !(message.public_free_asset_net_usage && $util.isInteger(message.public_free_asset_net_usage.low) && $util.isInteger(message.public_free_asset_net_usage.high)))
                    return "public_free_asset_net_usage: integer|Long expected";
            if (message.public_latest_free_net_time != null && message.hasOwnProperty("public_latest_free_net_time"))
                if (!$util.isInteger(message.public_latest_free_net_time) && !(message.public_latest_free_net_time && $util.isInteger(message.public_latest_free_net_time.low) && $util.isInteger(message.public_latest_free_net_time.high)))
                    return "public_latest_free_net_time: integer|Long expected";
            return null;
        };

        /**
         * Creates an AssetIssueContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AssetIssueContract} AssetIssueContract
         */
        AssetIssueContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AssetIssueContract)
                return object;
            var message = new $root.protocol.AssetIssueContract();
            if (object.id != null)
                message.id = String(object.id);
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.abbr != null)
                if (typeof object.abbr === "string")
                    $util.base64.decode(object.abbr, message.abbr = $util.newBuffer($util.base64.length(object.abbr)), 0);
                else if (object.abbr.length)
                    message.abbr = object.abbr;
            if (object.total_supply != null)
                if ($util.Long)
                    (message.total_supply = $util.Long.fromValue(object.total_supply)).unsigned = false;
                else if (typeof object.total_supply === "string")
                    message.total_supply = parseInt(object.total_supply, 10);
                else if (typeof object.total_supply === "number")
                    message.total_supply = object.total_supply;
                else if (typeof object.total_supply === "object")
                    message.total_supply = new $util.LongBits(object.total_supply.low >>> 0, object.total_supply.high >>> 0).toNumber();
            if (object.frozen_supply) {
                if (!Array.isArray(object.frozen_supply))
                    throw TypeError(".protocol.AssetIssueContract.frozen_supply: array expected");
                message.frozen_supply = [];
                for (var i = 0; i < object.frozen_supply.length; ++i) {
                    if (typeof object.frozen_supply[i] !== "object")
                        throw TypeError(".protocol.AssetIssueContract.frozen_supply: object expected");
                    message.frozen_supply[i] = $root.protocol.AssetIssueContract.FrozenSupply.fromObject(object.frozen_supply[i]);
                }
            }
            if (object.trx_num != null)
                message.trx_num = object.trx_num | 0;
            if (object.precision != null)
                message.precision = object.precision | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.start_time != null)
                if ($util.Long)
                    (message.start_time = $util.Long.fromValue(object.start_time)).unsigned = false;
                else if (typeof object.start_time === "string")
                    message.start_time = parseInt(object.start_time, 10);
                else if (typeof object.start_time === "number")
                    message.start_time = object.start_time;
                else if (typeof object.start_time === "object")
                    message.start_time = new $util.LongBits(object.start_time.low >>> 0, object.start_time.high >>> 0).toNumber();
            if (object.end_time != null)
                if ($util.Long)
                    (message.end_time = $util.Long.fromValue(object.end_time)).unsigned = false;
                else if (typeof object.end_time === "string")
                    message.end_time = parseInt(object.end_time, 10);
                else if (typeof object.end_time === "number")
                    message.end_time = object.end_time;
                else if (typeof object.end_time === "object")
                    message.end_time = new $util.LongBits(object.end_time.low >>> 0, object.end_time.high >>> 0).toNumber();
            if (object.order != null)
                if ($util.Long)
                    (message.order = $util.Long.fromValue(object.order)).unsigned = false;
                else if (typeof object.order === "string")
                    message.order = parseInt(object.order, 10);
                else if (typeof object.order === "number")
                    message.order = object.order;
                else if (typeof object.order === "object")
                    message.order = new $util.LongBits(object.order.low >>> 0, object.order.high >>> 0).toNumber();
            if (object.vote_score != null)
                message.vote_score = object.vote_score | 0;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            if (object.free_asset_net_limit != null)
                if ($util.Long)
                    (message.free_asset_net_limit = $util.Long.fromValue(object.free_asset_net_limit)).unsigned = false;
                else if (typeof object.free_asset_net_limit === "string")
                    message.free_asset_net_limit = parseInt(object.free_asset_net_limit, 10);
                else if (typeof object.free_asset_net_limit === "number")
                    message.free_asset_net_limit = object.free_asset_net_limit;
                else if (typeof object.free_asset_net_limit === "object")
                    message.free_asset_net_limit = new $util.LongBits(object.free_asset_net_limit.low >>> 0, object.free_asset_net_limit.high >>> 0).toNumber();
            if (object.public_free_asset_net_limit != null)
                if ($util.Long)
                    (message.public_free_asset_net_limit = $util.Long.fromValue(object.public_free_asset_net_limit)).unsigned = false;
                else if (typeof object.public_free_asset_net_limit === "string")
                    message.public_free_asset_net_limit = parseInt(object.public_free_asset_net_limit, 10);
                else if (typeof object.public_free_asset_net_limit === "number")
                    message.public_free_asset_net_limit = object.public_free_asset_net_limit;
                else if (typeof object.public_free_asset_net_limit === "object")
                    message.public_free_asset_net_limit = new $util.LongBits(object.public_free_asset_net_limit.low >>> 0, object.public_free_asset_net_limit.high >>> 0).toNumber();
            if (object.public_free_asset_net_usage != null)
                if ($util.Long)
                    (message.public_free_asset_net_usage = $util.Long.fromValue(object.public_free_asset_net_usage)).unsigned = false;
                else if (typeof object.public_free_asset_net_usage === "string")
                    message.public_free_asset_net_usage = parseInt(object.public_free_asset_net_usage, 10);
                else if (typeof object.public_free_asset_net_usage === "number")
                    message.public_free_asset_net_usage = object.public_free_asset_net_usage;
                else if (typeof object.public_free_asset_net_usage === "object")
                    message.public_free_asset_net_usage = new $util.LongBits(object.public_free_asset_net_usage.low >>> 0, object.public_free_asset_net_usage.high >>> 0).toNumber();
            if (object.public_latest_free_net_time != null)
                if ($util.Long)
                    (message.public_latest_free_net_time = $util.Long.fromValue(object.public_latest_free_net_time)).unsigned = false;
                else if (typeof object.public_latest_free_net_time === "string")
                    message.public_latest_free_net_time = parseInt(object.public_latest_free_net_time, 10);
                else if (typeof object.public_latest_free_net_time === "number")
                    message.public_latest_free_net_time = object.public_latest_free_net_time;
                else if (typeof object.public_latest_free_net_time === "object")
                    message.public_latest_free_net_time = new $util.LongBits(object.public_latest_free_net_time.low >>> 0, object.public_latest_free_net_time.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AssetIssueContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AssetIssueContract
         * @static
         * @param {protocol.AssetIssueContract} message AssetIssueContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AssetIssueContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.frozen_supply = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.abbr = "";
                else {
                    object.abbr = [];
                    if (options.bytes !== Array)
                        object.abbr = $util.newBuffer(object.abbr);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.total_supply = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.total_supply = options.longs === String ? "0" : 0;
                object.trx_num = 0;
                object.precision = 0;
                object.num = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.start_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.start_time = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.end_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.end_time = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.order = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.order = options.longs === String ? "0" : 0;
                object.vote_score = 0;
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.free_asset_net_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.free_asset_net_limit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.public_free_asset_net_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.public_free_asset_net_limit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.public_free_asset_net_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.public_free_asset_net_usage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.public_latest_free_net_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.public_latest_free_net_time = options.longs === String ? "0" : 0;
                object.id = "";
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.abbr != null && message.hasOwnProperty("abbr"))
                object.abbr = options.bytes === String ? $util.base64.encode(message.abbr, 0, message.abbr.length) : options.bytes === Array ? Array.prototype.slice.call(message.abbr) : message.abbr;
            if (message.total_supply != null && message.hasOwnProperty("total_supply"))
                if (typeof message.total_supply === "number")
                    object.total_supply = options.longs === String ? String(message.total_supply) : message.total_supply;
                else
                    object.total_supply = options.longs === String ? $util.Long.prototype.toString.call(message.total_supply) : options.longs === Number ? new $util.LongBits(message.total_supply.low >>> 0, message.total_supply.high >>> 0).toNumber() : message.total_supply;
            if (message.frozen_supply && message.frozen_supply.length) {
                object.frozen_supply = [];
                for (var j = 0; j < message.frozen_supply.length; ++j)
                    object.frozen_supply[j] = $root.protocol.AssetIssueContract.FrozenSupply.toObject(message.frozen_supply[j], options);
            }
            if (message.trx_num != null && message.hasOwnProperty("trx_num"))
                object.trx_num = message.trx_num;
            if (message.precision != null && message.hasOwnProperty("precision"))
                object.precision = message.precision;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.start_time != null && message.hasOwnProperty("start_time"))
                if (typeof message.start_time === "number")
                    object.start_time = options.longs === String ? String(message.start_time) : message.start_time;
                else
                    object.start_time = options.longs === String ? $util.Long.prototype.toString.call(message.start_time) : options.longs === Number ? new $util.LongBits(message.start_time.low >>> 0, message.start_time.high >>> 0).toNumber() : message.start_time;
            if (message.end_time != null && message.hasOwnProperty("end_time"))
                if (typeof message.end_time === "number")
                    object.end_time = options.longs === String ? String(message.end_time) : message.end_time;
                else
                    object.end_time = options.longs === String ? $util.Long.prototype.toString.call(message.end_time) : options.longs === Number ? new $util.LongBits(message.end_time.low >>> 0, message.end_time.high >>> 0).toNumber() : message.end_time;
            if (message.order != null && message.hasOwnProperty("order"))
                if (typeof message.order === "number")
                    object.order = options.longs === String ? String(message.order) : message.order;
                else
                    object.order = options.longs === String ? $util.Long.prototype.toString.call(message.order) : options.longs === Number ? new $util.LongBits(message.order.low >>> 0, message.order.high >>> 0).toNumber() : message.order;
            if (message.vote_score != null && message.hasOwnProperty("vote_score"))
                object.vote_score = message.vote_score;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            if (message.free_asset_net_limit != null && message.hasOwnProperty("free_asset_net_limit"))
                if (typeof message.free_asset_net_limit === "number")
                    object.free_asset_net_limit = options.longs === String ? String(message.free_asset_net_limit) : message.free_asset_net_limit;
                else
                    object.free_asset_net_limit = options.longs === String ? $util.Long.prototype.toString.call(message.free_asset_net_limit) : options.longs === Number ? new $util.LongBits(message.free_asset_net_limit.low >>> 0, message.free_asset_net_limit.high >>> 0).toNumber() : message.free_asset_net_limit;
            if (message.public_free_asset_net_limit != null && message.hasOwnProperty("public_free_asset_net_limit"))
                if (typeof message.public_free_asset_net_limit === "number")
                    object.public_free_asset_net_limit = options.longs === String ? String(message.public_free_asset_net_limit) : message.public_free_asset_net_limit;
                else
                    object.public_free_asset_net_limit = options.longs === String ? $util.Long.prototype.toString.call(message.public_free_asset_net_limit) : options.longs === Number ? new $util.LongBits(message.public_free_asset_net_limit.low >>> 0, message.public_free_asset_net_limit.high >>> 0).toNumber() : message.public_free_asset_net_limit;
            if (message.public_free_asset_net_usage != null && message.hasOwnProperty("public_free_asset_net_usage"))
                if (typeof message.public_free_asset_net_usage === "number")
                    object.public_free_asset_net_usage = options.longs === String ? String(message.public_free_asset_net_usage) : message.public_free_asset_net_usage;
                else
                    object.public_free_asset_net_usage = options.longs === String ? $util.Long.prototype.toString.call(message.public_free_asset_net_usage) : options.longs === Number ? new $util.LongBits(message.public_free_asset_net_usage.low >>> 0, message.public_free_asset_net_usage.high >>> 0).toNumber() : message.public_free_asset_net_usage;
            if (message.public_latest_free_net_time != null && message.hasOwnProperty("public_latest_free_net_time"))
                if (typeof message.public_latest_free_net_time === "number")
                    object.public_latest_free_net_time = options.longs === String ? String(message.public_latest_free_net_time) : message.public_latest_free_net_time;
                else
                    object.public_latest_free_net_time = options.longs === String ? $util.Long.prototype.toString.call(message.public_latest_free_net_time) : options.longs === Number ? new $util.LongBits(message.public_latest_free_net_time.low >>> 0, message.public_latest_free_net_time.high >>> 0).toNumber() : message.public_latest_free_net_time;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this AssetIssueContract to JSON.
         * @function toJSON
         * @memberof protocol.AssetIssueContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AssetIssueContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        AssetIssueContract.FrozenSupply = (function() {

            /**
             * Properties of a FrozenSupply.
             * @memberof protocol.AssetIssueContract
             * @interface IFrozenSupply
             * @property {number|Long|null} [frozen_amount] FrozenSupply frozen_amount
             * @property {number|Long|null} [frozen_days] FrozenSupply frozen_days
             */

            /**
             * Constructs a new FrozenSupply.
             * @memberof protocol.AssetIssueContract
             * @classdesc Represents a FrozenSupply.
             * @implements IFrozenSupply
             * @constructor
             * @param {protocol.AssetIssueContract.IFrozenSupply=} [properties] Properties to set
             */
            function FrozenSupply(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FrozenSupply frozen_amount.
             * @member {number|Long} frozen_amount
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @instance
             */
            FrozenSupply.prototype.frozen_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * FrozenSupply frozen_days.
             * @member {number|Long} frozen_days
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @instance
             */
            FrozenSupply.prototype.frozen_days = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new FrozenSupply instance using the specified properties.
             * @function create
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.IFrozenSupply=} [properties] Properties to set
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply instance
             */
            FrozenSupply.create = function create(properties) {
                return new FrozenSupply(properties);
            };

            /**
             * Encodes the specified FrozenSupply message. Does not implicitly {@link protocol.AssetIssueContract.FrozenSupply.verify|verify} messages.
             * @function encode
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.IFrozenSupply} message FrozenSupply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FrozenSupply.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frozen_amount != null && message.hasOwnProperty("frozen_amount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.frozen_amount);
                if (message.frozen_days != null && message.hasOwnProperty("frozen_days"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.frozen_days);
                return writer;
            };

            /**
             * Encodes the specified FrozenSupply message, length delimited. Does not implicitly {@link protocol.AssetIssueContract.FrozenSupply.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.IFrozenSupply} message FrozenSupply message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FrozenSupply.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FrozenSupply message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FrozenSupply.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AssetIssueContract.FrozenSupply();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frozen_amount = reader.int64();
                        break;
                    case 2:
                        message.frozen_days = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FrozenSupply message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FrozenSupply.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FrozenSupply message.
             * @function verify
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FrozenSupply.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frozen_amount != null && message.hasOwnProperty("frozen_amount"))
                    if (!$util.isInteger(message.frozen_amount) && !(message.frozen_amount && $util.isInteger(message.frozen_amount.low) && $util.isInteger(message.frozen_amount.high)))
                        return "frozen_amount: integer|Long expected";
                if (message.frozen_days != null && message.hasOwnProperty("frozen_days"))
                    if (!$util.isInteger(message.frozen_days) && !(message.frozen_days && $util.isInteger(message.frozen_days.low) && $util.isInteger(message.frozen_days.high)))
                        return "frozen_days: integer|Long expected";
                return null;
            };

            /**
             * Creates a FrozenSupply message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.AssetIssueContract.FrozenSupply} FrozenSupply
             */
            FrozenSupply.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.AssetIssueContract.FrozenSupply)
                    return object;
                var message = new $root.protocol.AssetIssueContract.FrozenSupply();
                if (object.frozen_amount != null)
                    if ($util.Long)
                        (message.frozen_amount = $util.Long.fromValue(object.frozen_amount)).unsigned = false;
                    else if (typeof object.frozen_amount === "string")
                        message.frozen_amount = parseInt(object.frozen_amount, 10);
                    else if (typeof object.frozen_amount === "number")
                        message.frozen_amount = object.frozen_amount;
                    else if (typeof object.frozen_amount === "object")
                        message.frozen_amount = new $util.LongBits(object.frozen_amount.low >>> 0, object.frozen_amount.high >>> 0).toNumber();
                if (object.frozen_days != null)
                    if ($util.Long)
                        (message.frozen_days = $util.Long.fromValue(object.frozen_days)).unsigned = false;
                    else if (typeof object.frozen_days === "string")
                        message.frozen_days = parseInt(object.frozen_days, 10);
                    else if (typeof object.frozen_days === "number")
                        message.frozen_days = object.frozen_days;
                    else if (typeof object.frozen_days === "object")
                        message.frozen_days = new $util.LongBits(object.frozen_days.low >>> 0, object.frozen_days.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a FrozenSupply message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @static
             * @param {protocol.AssetIssueContract.FrozenSupply} message FrozenSupply
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FrozenSupply.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozen_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frozen_amount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozen_days = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frozen_days = options.longs === String ? "0" : 0;
                }
                if (message.frozen_amount != null && message.hasOwnProperty("frozen_amount"))
                    if (typeof message.frozen_amount === "number")
                        object.frozen_amount = options.longs === String ? String(message.frozen_amount) : message.frozen_amount;
                    else
                        object.frozen_amount = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_amount) : options.longs === Number ? new $util.LongBits(message.frozen_amount.low >>> 0, message.frozen_amount.high >>> 0).toNumber() : message.frozen_amount;
                if (message.frozen_days != null && message.hasOwnProperty("frozen_days"))
                    if (typeof message.frozen_days === "number")
                        object.frozen_days = options.longs === String ? String(message.frozen_days) : message.frozen_days;
                    else
                        object.frozen_days = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_days) : options.longs === Number ? new $util.LongBits(message.frozen_days.low >>> 0, message.frozen_days.high >>> 0).toNumber() : message.frozen_days;
                return object;
            };

            /**
             * Converts this FrozenSupply to JSON.
             * @function toJSON
             * @memberof protocol.AssetIssueContract.FrozenSupply
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FrozenSupply.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FrozenSupply;
        })();

        return AssetIssueContract;
    })();

    protocol.ParticipateAssetIssueContract = (function() {

        /**
         * Properties of a ParticipateAssetIssueContract.
         * @memberof protocol
         * @interface IParticipateAssetIssueContract
         * @property {Uint8Array|null} [owner_address] ParticipateAssetIssueContract owner_address
         * @property {Uint8Array|null} [to_address] ParticipateAssetIssueContract to_address
         * @property {Uint8Array|null} [asset_name] ParticipateAssetIssueContract asset_name
         * @property {number|Long|null} [amount] ParticipateAssetIssueContract amount
         */

        /**
         * Constructs a new ParticipateAssetIssueContract.
         * @memberof protocol
         * @classdesc Represents a ParticipateAssetIssueContract.
         * @implements IParticipateAssetIssueContract
         * @constructor
         * @param {protocol.IParticipateAssetIssueContract=} [properties] Properties to set
         */
        function ParticipateAssetIssueContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ParticipateAssetIssueContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ParticipateAssetIssueContract to_address.
         * @member {Uint8Array} to_address
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.to_address = $util.newBuffer([]);

        /**
         * ParticipateAssetIssueContract asset_name.
         * @member {Uint8Array} asset_name
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.asset_name = $util.newBuffer([]);

        /**
         * ParticipateAssetIssueContract amount.
         * @member {number|Long} amount
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         */
        ParticipateAssetIssueContract.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ParticipateAssetIssueContract instance using the specified properties.
         * @function create
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.IParticipateAssetIssueContract=} [properties] Properties to set
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract instance
         */
        ParticipateAssetIssueContract.create = function create(properties) {
            return new ParticipateAssetIssueContract(properties);
        };

        /**
         * Encodes the specified ParticipateAssetIssueContract message. Does not implicitly {@link protocol.ParticipateAssetIssueContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.IParticipateAssetIssueContract} message ParticipateAssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParticipateAssetIssueContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to_address);
            if (message.asset_name != null && message.hasOwnProperty("asset_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.asset_name);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ParticipateAssetIssueContract message, length delimited. Does not implicitly {@link protocol.ParticipateAssetIssueContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.IParticipateAssetIssueContract} message ParticipateAssetIssueContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ParticipateAssetIssueContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ParticipateAssetIssueContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParticipateAssetIssueContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ParticipateAssetIssueContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.to_address = reader.bytes();
                    break;
                case 3:
                    message.asset_name = reader.bytes();
                    break;
                case 4:
                    message.amount = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ParticipateAssetIssueContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ParticipateAssetIssueContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ParticipateAssetIssueContract message.
         * @function verify
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ParticipateAssetIssueContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                if (!(message.to_address && typeof message.to_address.length === "number" || $util.isString(message.to_address)))
                    return "to_address: buffer expected";
            if (message.asset_name != null && message.hasOwnProperty("asset_name"))
                if (!(message.asset_name && typeof message.asset_name.length === "number" || $util.isString(message.asset_name)))
                    return "asset_name: buffer expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            return null;
        };

        /**
         * Creates a ParticipateAssetIssueContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ParticipateAssetIssueContract} ParticipateAssetIssueContract
         */
        ParticipateAssetIssueContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ParticipateAssetIssueContract)
                return object;
            var message = new $root.protocol.ParticipateAssetIssueContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.to_address != null)
                if (typeof object.to_address === "string")
                    $util.base64.decode(object.to_address, message.to_address = $util.newBuffer($util.base64.length(object.to_address)), 0);
                else if (object.to_address.length)
                    message.to_address = object.to_address;
            if (object.asset_name != null)
                if (typeof object.asset_name === "string")
                    $util.base64.decode(object.asset_name, message.asset_name = $util.newBuffer($util.base64.length(object.asset_name)), 0);
                else if (object.asset_name.length)
                    message.asset_name = object.asset_name;
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ParticipateAssetIssueContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ParticipateAssetIssueContract
         * @static
         * @param {protocol.ParticipateAssetIssueContract} message ParticipateAssetIssueContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ParticipateAssetIssueContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.to_address = "";
                else {
                    object.to_address = [];
                    if (options.bytes !== Array)
                        object.to_address = $util.newBuffer(object.to_address);
                }
                if (options.bytes === String)
                    object.asset_name = "";
                else {
                    object.asset_name = [];
                    if (options.bytes !== Array)
                        object.asset_name = $util.newBuffer(object.asset_name);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.to_address != null && message.hasOwnProperty("to_address"))
                object.to_address = options.bytes === String ? $util.base64.encode(message.to_address, 0, message.to_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.to_address) : message.to_address;
            if (message.asset_name != null && message.hasOwnProperty("asset_name"))
                object.asset_name = options.bytes === String ? $util.base64.encode(message.asset_name, 0, message.asset_name.length) : options.bytes === Array ? Array.prototype.slice.call(message.asset_name) : message.asset_name;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            return object;
        };

        /**
         * Converts this ParticipateAssetIssueContract to JSON.
         * @function toJSON
         * @memberof protocol.ParticipateAssetIssueContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ParticipateAssetIssueContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ParticipateAssetIssueContract;
    })();

    /**
     * ResourceCode enum.
     * @name protocol.ResourceCode
     * @enum {string}
     * @property {number} BANDWIDTH=0 BANDWIDTH value
     * @property {number} ENERGY=1 ENERGY value
     */
    protocol.ResourceCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "BANDWIDTH"] = 0;
        values[valuesById[1] = "ENERGY"] = 1;
        return values;
    })();

    protocol.FreezeBalanceContract = (function() {

        /**
         * Properties of a FreezeBalanceContract.
         * @memberof protocol
         * @interface IFreezeBalanceContract
         * @property {Uint8Array|null} [owner_address] FreezeBalanceContract owner_address
         * @property {number|Long|null} [frozen_balance] FreezeBalanceContract frozen_balance
         * @property {number|Long|null} [frozen_duration] FreezeBalanceContract frozen_duration
         * @property {protocol.ResourceCode|null} [resource] FreezeBalanceContract resource
         * @property {Uint8Array|null} [receiver_address] FreezeBalanceContract receiver_address
         */

        /**
         * Constructs a new FreezeBalanceContract.
         * @memberof protocol
         * @classdesc Represents a FreezeBalanceContract.
         * @implements IFreezeBalanceContract
         * @constructor
         * @param {protocol.IFreezeBalanceContract=} [properties] Properties to set
         */
        function FreezeBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FreezeBalanceContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * FreezeBalanceContract frozen_balance.
         * @member {number|Long} frozen_balance
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.frozen_balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FreezeBalanceContract frozen_duration.
         * @member {number|Long} frozen_duration
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.frozen_duration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FreezeBalanceContract resource.
         * @member {protocol.ResourceCode} resource
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.resource = 0;

        /**
         * FreezeBalanceContract receiver_address.
         * @member {Uint8Array} receiver_address
         * @memberof protocol.FreezeBalanceContract
         * @instance
         */
        FreezeBalanceContract.prototype.receiver_address = $util.newBuffer([]);

        /**
         * Creates a new FreezeBalanceContract instance using the specified properties.
         * @function create
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.IFreezeBalanceContract=} [properties] Properties to set
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract instance
         */
        FreezeBalanceContract.create = function create(properties) {
            return new FreezeBalanceContract(properties);
        };

        /**
         * Encodes the specified FreezeBalanceContract message. Does not implicitly {@link protocol.FreezeBalanceContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.IFreezeBalanceContract} message FreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.frozen_balance != null && message.hasOwnProperty("frozen_balance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.frozen_balance);
            if (message.frozen_duration != null && message.hasOwnProperty("frozen_duration"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.frozen_duration);
            if (message.resource != null && message.hasOwnProperty("resource"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.resource);
            if (message.receiver_address != null && message.hasOwnProperty("receiver_address"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.receiver_address);
            return writer;
        };

        /**
         * Encodes the specified FreezeBalanceContract message, length delimited. Does not implicitly {@link protocol.FreezeBalanceContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.IFreezeBalanceContract} message FreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FreezeBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FreezeBalanceContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.FreezeBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.frozen_balance = reader.int64();
                    break;
                case 3:
                    message.frozen_duration = reader.int64();
                    break;
                case 10:
                    message.resource = reader.int32();
                    break;
                case 15:
                    message.receiver_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FreezeBalanceContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FreezeBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FreezeBalanceContract message.
         * @function verify
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FreezeBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.frozen_balance != null && message.hasOwnProperty("frozen_balance"))
                if (!$util.isInteger(message.frozen_balance) && !(message.frozen_balance && $util.isInteger(message.frozen_balance.low) && $util.isInteger(message.frozen_balance.high)))
                    return "frozen_balance: integer|Long expected";
            if (message.frozen_duration != null && message.hasOwnProperty("frozen_duration"))
                if (!$util.isInteger(message.frozen_duration) && !(message.frozen_duration && $util.isInteger(message.frozen_duration.low) && $util.isInteger(message.frozen_duration.high)))
                    return "frozen_duration: integer|Long expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                switch (message.resource) {
                default:
                    return "resource: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.receiver_address != null && message.hasOwnProperty("receiver_address"))
                if (!(message.receiver_address && typeof message.receiver_address.length === "number" || $util.isString(message.receiver_address)))
                    return "receiver_address: buffer expected";
            return null;
        };

        /**
         * Creates a FreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.FreezeBalanceContract} FreezeBalanceContract
         */
        FreezeBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.FreezeBalanceContract)
                return object;
            var message = new $root.protocol.FreezeBalanceContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.frozen_balance != null)
                if ($util.Long)
                    (message.frozen_balance = $util.Long.fromValue(object.frozen_balance)).unsigned = false;
                else if (typeof object.frozen_balance === "string")
                    message.frozen_balance = parseInt(object.frozen_balance, 10);
                else if (typeof object.frozen_balance === "number")
                    message.frozen_balance = object.frozen_balance;
                else if (typeof object.frozen_balance === "object")
                    message.frozen_balance = new $util.LongBits(object.frozen_balance.low >>> 0, object.frozen_balance.high >>> 0).toNumber();
            if (object.frozen_duration != null)
                if ($util.Long)
                    (message.frozen_duration = $util.Long.fromValue(object.frozen_duration)).unsigned = false;
                else if (typeof object.frozen_duration === "string")
                    message.frozen_duration = parseInt(object.frozen_duration, 10);
                else if (typeof object.frozen_duration === "number")
                    message.frozen_duration = object.frozen_duration;
                else if (typeof object.frozen_duration === "object")
                    message.frozen_duration = new $util.LongBits(object.frozen_duration.low >>> 0, object.frozen_duration.high >>> 0).toNumber();
            switch (object.resource) {
            case "BANDWIDTH":
            case 0:
                message.resource = 0;
                break;
            case "ENERGY":
            case 1:
                message.resource = 1;
                break;
            }
            if (object.receiver_address != null)
                if (typeof object.receiver_address === "string")
                    $util.base64.decode(object.receiver_address, message.receiver_address = $util.newBuffer($util.base64.length(object.receiver_address)), 0);
                else if (object.receiver_address.length)
                    message.receiver_address = object.receiver_address;
            return message;
        };

        /**
         * Creates a plain object from a FreezeBalanceContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.FreezeBalanceContract
         * @static
         * @param {protocol.FreezeBalanceContract} message FreezeBalanceContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FreezeBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozen_balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozen_balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozen_duration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozen_duration = options.longs === String ? "0" : 0;
                object.resource = options.enums === String ? "BANDWIDTH" : 0;
                if (options.bytes === String)
                    object.receiver_address = "";
                else {
                    object.receiver_address = [];
                    if (options.bytes !== Array)
                        object.receiver_address = $util.newBuffer(object.receiver_address);
                }
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.frozen_balance != null && message.hasOwnProperty("frozen_balance"))
                if (typeof message.frozen_balance === "number")
                    object.frozen_balance = options.longs === String ? String(message.frozen_balance) : message.frozen_balance;
                else
                    object.frozen_balance = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_balance) : options.longs === Number ? new $util.LongBits(message.frozen_balance.low >>> 0, message.frozen_balance.high >>> 0).toNumber() : message.frozen_balance;
            if (message.frozen_duration != null && message.hasOwnProperty("frozen_duration"))
                if (typeof message.frozen_duration === "number")
                    object.frozen_duration = options.longs === String ? String(message.frozen_duration) : message.frozen_duration;
                else
                    object.frozen_duration = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_duration) : options.longs === Number ? new $util.LongBits(message.frozen_duration.low >>> 0, message.frozen_duration.high >>> 0).toNumber() : message.frozen_duration;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = options.enums === String ? $root.protocol.ResourceCode[message.resource] : message.resource;
            if (message.receiver_address != null && message.hasOwnProperty("receiver_address"))
                object.receiver_address = options.bytes === String ? $util.base64.encode(message.receiver_address, 0, message.receiver_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiver_address) : message.receiver_address;
            return object;
        };

        /**
         * Converts this FreezeBalanceContract to JSON.
         * @function toJSON
         * @memberof protocol.FreezeBalanceContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FreezeBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FreezeBalanceContract;
    })();

    protocol.UnfreezeBalanceContract = (function() {

        /**
         * Properties of an UnfreezeBalanceContract.
         * @memberof protocol
         * @interface IUnfreezeBalanceContract
         * @property {Uint8Array|null} [owner_address] UnfreezeBalanceContract owner_address
         * @property {protocol.ResourceCode|null} [resource] UnfreezeBalanceContract resource
         * @property {Uint8Array|null} [receiver_address] UnfreezeBalanceContract receiver_address
         */

        /**
         * Constructs a new UnfreezeBalanceContract.
         * @memberof protocol
         * @classdesc Represents an UnfreezeBalanceContract.
         * @implements IUnfreezeBalanceContract
         * @constructor
         * @param {protocol.IUnfreezeBalanceContract=} [properties] Properties to set
         */
        function UnfreezeBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnfreezeBalanceContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         */
        UnfreezeBalanceContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * UnfreezeBalanceContract resource.
         * @member {protocol.ResourceCode} resource
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         */
        UnfreezeBalanceContract.prototype.resource = 0;

        /**
         * UnfreezeBalanceContract receiver_address.
         * @member {Uint8Array} receiver_address
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         */
        UnfreezeBalanceContract.prototype.receiver_address = $util.newBuffer([]);

        /**
         * Creates a new UnfreezeBalanceContract instance using the specified properties.
         * @function create
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.IUnfreezeBalanceContract=} [properties] Properties to set
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract instance
         */
        UnfreezeBalanceContract.create = function create(properties) {
            return new UnfreezeBalanceContract(properties);
        };

        /**
         * Encodes the specified UnfreezeBalanceContract message. Does not implicitly {@link protocol.UnfreezeBalanceContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.IUnfreezeBalanceContract} message UnfreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.resource != null && message.hasOwnProperty("resource"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.resource);
            if (message.receiver_address != null && message.hasOwnProperty("receiver_address"))
                writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.receiver_address);
            return writer;
        };

        /**
         * Encodes the specified UnfreezeBalanceContract message, length delimited. Does not implicitly {@link protocol.UnfreezeBalanceContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.IUnfreezeBalanceContract} message UnfreezeBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnfreezeBalanceContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UnfreezeBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 10:
                    message.resource = reader.int32();
                    break;
                case 15:
                    message.receiver_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnfreezeBalanceContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnfreezeBalanceContract message.
         * @function verify
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnfreezeBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.resource != null && message.hasOwnProperty("resource"))
                switch (message.resource) {
                default:
                    return "resource: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.receiver_address != null && message.hasOwnProperty("receiver_address"))
                if (!(message.receiver_address && typeof message.receiver_address.length === "number" || $util.isString(message.receiver_address)))
                    return "receiver_address: buffer expected";
            return null;
        };

        /**
         * Creates an UnfreezeBalanceContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UnfreezeBalanceContract} UnfreezeBalanceContract
         */
        UnfreezeBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UnfreezeBalanceContract)
                return object;
            var message = new $root.protocol.UnfreezeBalanceContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            switch (object.resource) {
            case "BANDWIDTH":
            case 0:
                message.resource = 0;
                break;
            case "ENERGY":
            case 1:
                message.resource = 1;
                break;
            }
            if (object.receiver_address != null)
                if (typeof object.receiver_address === "string")
                    $util.base64.decode(object.receiver_address, message.receiver_address = $util.newBuffer($util.base64.length(object.receiver_address)), 0);
                else if (object.receiver_address.length)
                    message.receiver_address = object.receiver_address;
            return message;
        };

        /**
         * Creates a plain object from an UnfreezeBalanceContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UnfreezeBalanceContract
         * @static
         * @param {protocol.UnfreezeBalanceContract} message UnfreezeBalanceContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnfreezeBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                object.resource = options.enums === String ? "BANDWIDTH" : 0;
                if (options.bytes === String)
                    object.receiver_address = "";
                else {
                    object.receiver_address = [];
                    if (options.bytes !== Array)
                        object.receiver_address = $util.newBuffer(object.receiver_address);
                }
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.resource != null && message.hasOwnProperty("resource"))
                object.resource = options.enums === String ? $root.protocol.ResourceCode[message.resource] : message.resource;
            if (message.receiver_address != null && message.hasOwnProperty("receiver_address"))
                object.receiver_address = options.bytes === String ? $util.base64.encode(message.receiver_address, 0, message.receiver_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.receiver_address) : message.receiver_address;
            return object;
        };

        /**
         * Converts this UnfreezeBalanceContract to JSON.
         * @function toJSON
         * @memberof protocol.UnfreezeBalanceContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnfreezeBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnfreezeBalanceContract;
    })();

    protocol.UnfreezeAssetContract = (function() {

        /**
         * Properties of an UnfreezeAssetContract.
         * @memberof protocol
         * @interface IUnfreezeAssetContract
         * @property {Uint8Array|null} [owner_address] UnfreezeAssetContract owner_address
         */

        /**
         * Constructs a new UnfreezeAssetContract.
         * @memberof protocol
         * @classdesc Represents an UnfreezeAssetContract.
         * @implements IUnfreezeAssetContract
         * @constructor
         * @param {protocol.IUnfreezeAssetContract=} [properties] Properties to set
         */
        function UnfreezeAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnfreezeAssetContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.UnfreezeAssetContract
         * @instance
         */
        UnfreezeAssetContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * Creates a new UnfreezeAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.IUnfreezeAssetContract=} [properties] Properties to set
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract instance
         */
        UnfreezeAssetContract.create = function create(properties) {
            return new UnfreezeAssetContract(properties);
        };

        /**
         * Encodes the specified UnfreezeAssetContract message. Does not implicitly {@link protocol.UnfreezeAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.IUnfreezeAssetContract} message UnfreezeAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            return writer;
        };

        /**
         * Encodes the specified UnfreezeAssetContract message, length delimited. Does not implicitly {@link protocol.UnfreezeAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.IUnfreezeAssetContract} message UnfreezeAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnfreezeAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnfreezeAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UnfreezeAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnfreezeAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnfreezeAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnfreezeAssetContract message.
         * @function verify
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnfreezeAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            return null;
        };

        /**
         * Creates an UnfreezeAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UnfreezeAssetContract} UnfreezeAssetContract
         */
        UnfreezeAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UnfreezeAssetContract)
                return object;
            var message = new $root.protocol.UnfreezeAssetContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            return message;
        };

        /**
         * Creates a plain object from an UnfreezeAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UnfreezeAssetContract
         * @static
         * @param {protocol.UnfreezeAssetContract} message UnfreezeAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnfreezeAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            return object;
        };

        /**
         * Converts this UnfreezeAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.UnfreezeAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnfreezeAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnfreezeAssetContract;
    })();

    protocol.WithdrawBalanceContract = (function() {

        /**
         * Properties of a WithdrawBalanceContract.
         * @memberof protocol
         * @interface IWithdrawBalanceContract
         * @property {Uint8Array|null} [owner_address] WithdrawBalanceContract owner_address
         */

        /**
         * Constructs a new WithdrawBalanceContract.
         * @memberof protocol
         * @classdesc Represents a WithdrawBalanceContract.
         * @implements IWithdrawBalanceContract
         * @constructor
         * @param {protocol.IWithdrawBalanceContract=} [properties] Properties to set
         */
        function WithdrawBalanceContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WithdrawBalanceContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.WithdrawBalanceContract
         * @instance
         */
        WithdrawBalanceContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * Creates a new WithdrawBalanceContract instance using the specified properties.
         * @function create
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.IWithdrawBalanceContract=} [properties] Properties to set
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract instance
         */
        WithdrawBalanceContract.create = function create(properties) {
            return new WithdrawBalanceContract(properties);
        };

        /**
         * Encodes the specified WithdrawBalanceContract message. Does not implicitly {@link protocol.WithdrawBalanceContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.IWithdrawBalanceContract} message WithdrawBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WithdrawBalanceContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            return writer;
        };

        /**
         * Encodes the specified WithdrawBalanceContract message, length delimited. Does not implicitly {@link protocol.WithdrawBalanceContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.IWithdrawBalanceContract} message WithdrawBalanceContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WithdrawBalanceContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WithdrawBalanceContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WithdrawBalanceContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.WithdrawBalanceContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WithdrawBalanceContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WithdrawBalanceContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WithdrawBalanceContract message.
         * @function verify
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WithdrawBalanceContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            return null;
        };

        /**
         * Creates a WithdrawBalanceContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.WithdrawBalanceContract} WithdrawBalanceContract
         */
        WithdrawBalanceContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.WithdrawBalanceContract)
                return object;
            var message = new $root.protocol.WithdrawBalanceContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            return message;
        };

        /**
         * Creates a plain object from a WithdrawBalanceContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.WithdrawBalanceContract
         * @static
         * @param {protocol.WithdrawBalanceContract} message WithdrawBalanceContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WithdrawBalanceContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            return object;
        };

        /**
         * Converts this WithdrawBalanceContract to JSON.
         * @function toJSON
         * @memberof protocol.WithdrawBalanceContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WithdrawBalanceContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WithdrawBalanceContract;
    })();

    protocol.UpdateAssetContract = (function() {

        /**
         * Properties of an UpdateAssetContract.
         * @memberof protocol
         * @interface IUpdateAssetContract
         * @property {Uint8Array|null} [owner_address] UpdateAssetContract owner_address
         * @property {Uint8Array|null} [description] UpdateAssetContract description
         * @property {Uint8Array|null} [url] UpdateAssetContract url
         * @property {number|Long|null} [new_limit] UpdateAssetContract new_limit
         * @property {number|Long|null} [new_public_limit] UpdateAssetContract new_public_limit
         */

        /**
         * Constructs a new UpdateAssetContract.
         * @memberof protocol
         * @classdesc Represents an UpdateAssetContract.
         * @implements IUpdateAssetContract
         * @constructor
         * @param {protocol.IUpdateAssetContract=} [properties] Properties to set
         */
        function UpdateAssetContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateAssetContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * UpdateAssetContract description.
         * @member {Uint8Array} description
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.description = $util.newBuffer([]);

        /**
         * UpdateAssetContract url.
         * @member {Uint8Array} url
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.url = $util.newBuffer([]);

        /**
         * UpdateAssetContract new_limit.
         * @member {number|Long} new_limit
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.new_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UpdateAssetContract new_public_limit.
         * @member {number|Long} new_public_limit
         * @memberof protocol.UpdateAssetContract
         * @instance
         */
        UpdateAssetContract.prototype.new_public_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UpdateAssetContract instance using the specified properties.
         * @function create
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.IUpdateAssetContract=} [properties] Properties to set
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract instance
         */
        UpdateAssetContract.create = function create(properties) {
            return new UpdateAssetContract(properties);
        };

        /**
         * Encodes the specified UpdateAssetContract message. Does not implicitly {@link protocol.UpdateAssetContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.IUpdateAssetContract} message UpdateAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAssetContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.description);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.url);
            if (message.new_limit != null && message.hasOwnProperty("new_limit"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.new_limit);
            if (message.new_public_limit != null && message.hasOwnProperty("new_public_limit"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.new_public_limit);
            return writer;
        };

        /**
         * Encodes the specified UpdateAssetContract message, length delimited. Does not implicitly {@link protocol.UpdateAssetContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.IUpdateAssetContract} message UpdateAssetContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateAssetContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateAssetContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAssetContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.UpdateAssetContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.description = reader.bytes();
                    break;
                case 3:
                    message.url = reader.bytes();
                    break;
                case 4:
                    message.new_limit = reader.int64();
                    break;
                case 5:
                    message.new_public_limit = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateAssetContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateAssetContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateAssetContract message.
         * @function verify
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateAssetContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!(message.description && typeof message.description.length === "number" || $util.isString(message.description)))
                    return "description: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!(message.url && typeof message.url.length === "number" || $util.isString(message.url)))
                    return "url: buffer expected";
            if (message.new_limit != null && message.hasOwnProperty("new_limit"))
                if (!$util.isInteger(message.new_limit) && !(message.new_limit && $util.isInteger(message.new_limit.low) && $util.isInteger(message.new_limit.high)))
                    return "new_limit: integer|Long expected";
            if (message.new_public_limit != null && message.hasOwnProperty("new_public_limit"))
                if (!$util.isInteger(message.new_public_limit) && !(message.new_public_limit && $util.isInteger(message.new_public_limit.low) && $util.isInteger(message.new_public_limit.high)))
                    return "new_public_limit: integer|Long expected";
            return null;
        };

        /**
         * Creates an UpdateAssetContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.UpdateAssetContract} UpdateAssetContract
         */
        UpdateAssetContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.UpdateAssetContract)
                return object;
            var message = new $root.protocol.UpdateAssetContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.description != null)
                if (typeof object.description === "string")
                    $util.base64.decode(object.description, message.description = $util.newBuffer($util.base64.length(object.description)), 0);
                else if (object.description.length)
                    message.description = object.description;
            if (object.url != null)
                if (typeof object.url === "string")
                    $util.base64.decode(object.url, message.url = $util.newBuffer($util.base64.length(object.url)), 0);
                else if (object.url.length)
                    message.url = object.url;
            if (object.new_limit != null)
                if ($util.Long)
                    (message.new_limit = $util.Long.fromValue(object.new_limit)).unsigned = false;
                else if (typeof object.new_limit === "string")
                    message.new_limit = parseInt(object.new_limit, 10);
                else if (typeof object.new_limit === "number")
                    message.new_limit = object.new_limit;
                else if (typeof object.new_limit === "object")
                    message.new_limit = new $util.LongBits(object.new_limit.low >>> 0, object.new_limit.high >>> 0).toNumber();
            if (object.new_public_limit != null)
                if ($util.Long)
                    (message.new_public_limit = $util.Long.fromValue(object.new_public_limit)).unsigned = false;
                else if (typeof object.new_public_limit === "string")
                    message.new_public_limit = parseInt(object.new_public_limit, 10);
                else if (typeof object.new_public_limit === "number")
                    message.new_public_limit = object.new_public_limit;
                else if (typeof object.new_public_limit === "object")
                    message.new_public_limit = new $util.LongBits(object.new_public_limit.low >>> 0, object.new_public_limit.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an UpdateAssetContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.UpdateAssetContract
         * @static
         * @param {protocol.UpdateAssetContract} message UpdateAssetContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UpdateAssetContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.description = "";
                else {
                    object.description = [];
                    if (options.bytes !== Array)
                        object.description = $util.newBuffer(object.description);
                }
                if (options.bytes === String)
                    object.url = "";
                else {
                    object.url = [];
                    if (options.bytes !== Array)
                        object.url = $util.newBuffer(object.url);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.new_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.new_limit = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.new_public_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.new_public_limit = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = options.bytes === String ? $util.base64.encode(message.description, 0, message.description.length) : options.bytes === Array ? Array.prototype.slice.call(message.description) : message.description;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = options.bytes === String ? $util.base64.encode(message.url, 0, message.url.length) : options.bytes === Array ? Array.prototype.slice.call(message.url) : message.url;
            if (message.new_limit != null && message.hasOwnProperty("new_limit"))
                if (typeof message.new_limit === "number")
                    object.new_limit = options.longs === String ? String(message.new_limit) : message.new_limit;
                else
                    object.new_limit = options.longs === String ? $util.Long.prototype.toString.call(message.new_limit) : options.longs === Number ? new $util.LongBits(message.new_limit.low >>> 0, message.new_limit.high >>> 0).toNumber() : message.new_limit;
            if (message.new_public_limit != null && message.hasOwnProperty("new_public_limit"))
                if (typeof message.new_public_limit === "number")
                    object.new_public_limit = options.longs === String ? String(message.new_public_limit) : message.new_public_limit;
                else
                    object.new_public_limit = options.longs === String ? $util.Long.prototype.toString.call(message.new_public_limit) : options.longs === Number ? new $util.LongBits(message.new_public_limit.low >>> 0, message.new_public_limit.high >>> 0).toNumber() : message.new_public_limit;
            return object;
        };

        /**
         * Converts this UpdateAssetContract to JSON.
         * @function toJSON
         * @memberof protocol.UpdateAssetContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UpdateAssetContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UpdateAssetContract;
    })();

    protocol.ProposalCreateContract = (function() {

        /**
         * Properties of a ProposalCreateContract.
         * @memberof protocol
         * @interface IProposalCreateContract
         * @property {Uint8Array|null} [owner_address] ProposalCreateContract owner_address
         * @property {Object.<string,number|Long>|null} [parameters] ProposalCreateContract parameters
         */

        /**
         * Constructs a new ProposalCreateContract.
         * @memberof protocol
         * @classdesc Represents a ProposalCreateContract.
         * @implements IProposalCreateContract
         * @constructor
         * @param {protocol.IProposalCreateContract=} [properties] Properties to set
         */
        function ProposalCreateContract(properties) {
            this.parameters = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalCreateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ProposalCreateContract
         * @instance
         */
        ProposalCreateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ProposalCreateContract parameters.
         * @member {Object.<string,number|Long>} parameters
         * @memberof protocol.ProposalCreateContract
         * @instance
         */
        ProposalCreateContract.prototype.parameters = $util.emptyObject;

        /**
         * Creates a new ProposalCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.IProposalCreateContract=} [properties] Properties to set
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract instance
         */
        ProposalCreateContract.create = function create(properties) {
            return new ProposalCreateContract(properties);
        };

        /**
         * Encodes the specified ProposalCreateContract message. Does not implicitly {@link protocol.ProposalCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.IProposalCreateContract} message ProposalCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.parameters != null && message.hasOwnProperty("parameters"))
                for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.parameters[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ProposalCreateContract message, length delimited. Does not implicitly {@link protocol.ProposalCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.IProposalCreateContract} message ProposalCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalCreateContract(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.parameters === $util.emptyObject)
                        message.parameters = {};
                    key = reader.int64();
                    reader.pos++;
                    message.parameters[typeof key === "object" ? $util.longToHash(key) : key] = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalCreateContract message.
         * @function verify
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!$util.isObject(message.parameters))
                    return "parameters: object expected";
                var key = Object.keys(message.parameters);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "parameters: integer|Long key{k:int64} expected";
                    if (!$util.isInteger(message.parameters[key[i]]) && !(message.parameters[key[i]] && $util.isInteger(message.parameters[key[i]].low) && $util.isInteger(message.parameters[key[i]].high)))
                        return "parameters: integer|Long{k:int64} expected";
                }
            }
            return null;
        };

        /**
         * Creates a ProposalCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ProposalCreateContract} ProposalCreateContract
         */
        ProposalCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalCreateContract)
                return object;
            var message = new $root.protocol.ProposalCreateContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.parameters) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".protocol.ProposalCreateContract.parameters: object expected");
                message.parameters = {};
                for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.parameters[keys[i]] = $util.Long.fromValue(object.parameters[keys[i]])).unsigned = false;
                    else if (typeof object.parameters[keys[i]] === "string")
                        message.parameters[keys[i]] = parseInt(object.parameters[keys[i]], 10);
                    else if (typeof object.parameters[keys[i]] === "number")
                        message.parameters[keys[i]] = object.parameters[keys[i]];
                    else if (typeof object.parameters[keys[i]] === "object")
                        message.parameters[keys[i]] = new $util.LongBits(object.parameters[keys[i]].low >>> 0, object.parameters[keys[i]].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a ProposalCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ProposalCreateContract
         * @static
         * @param {protocol.ProposalCreateContract} message ProposalCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.parameters = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            var keys2;
            if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                object.parameters = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.parameters[keys2[j]] === "number")
                        object.parameters[keys2[j]] = options.longs === String ? String(message.parameters[keys2[j]]) : message.parameters[keys2[j]];
                    else
                        object.parameters[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.parameters[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.parameters[keys2[j]].low >>> 0, message.parameters[keys2[j]].high >>> 0).toNumber() : message.parameters[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ProposalCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.ProposalCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalCreateContract;
    })();

    protocol.ProposalApproveContract = (function() {

        /**
         * Properties of a ProposalApproveContract.
         * @memberof protocol
         * @interface IProposalApproveContract
         * @property {Uint8Array|null} [owner_address] ProposalApproveContract owner_address
         * @property {number|Long|null} [proposal_id] ProposalApproveContract proposal_id
         * @property {boolean|null} [is_add_approval] ProposalApproveContract is_add_approval
         */

        /**
         * Constructs a new ProposalApproveContract.
         * @memberof protocol
         * @classdesc Represents a ProposalApproveContract.
         * @implements IProposalApproveContract
         * @constructor
         * @param {protocol.IProposalApproveContract=} [properties] Properties to set
         */
        function ProposalApproveContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalApproveContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ProposalApproveContract
         * @instance
         */
        ProposalApproveContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ProposalApproveContract proposal_id.
         * @member {number|Long} proposal_id
         * @memberof protocol.ProposalApproveContract
         * @instance
         */
        ProposalApproveContract.prototype.proposal_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ProposalApproveContract is_add_approval.
         * @member {boolean} is_add_approval
         * @memberof protocol.ProposalApproveContract
         * @instance
         */
        ProposalApproveContract.prototype.is_add_approval = false;

        /**
         * Creates a new ProposalApproveContract instance using the specified properties.
         * @function create
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.IProposalApproveContract=} [properties] Properties to set
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract instance
         */
        ProposalApproveContract.create = function create(properties) {
            return new ProposalApproveContract(properties);
        };

        /**
         * Encodes the specified ProposalApproveContract message. Does not implicitly {@link protocol.ProposalApproveContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.IProposalApproveContract} message ProposalApproveContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalApproveContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.proposal_id);
            if (message.is_add_approval != null && message.hasOwnProperty("is_add_approval"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_add_approval);
            return writer;
        };

        /**
         * Encodes the specified ProposalApproveContract message, length delimited. Does not implicitly {@link protocol.ProposalApproveContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.IProposalApproveContract} message ProposalApproveContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalApproveContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalApproveContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalApproveContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalApproveContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.proposal_id = reader.int64();
                    break;
                case 3:
                    message.is_add_approval = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalApproveContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalApproveContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalApproveContract message.
         * @function verify
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalApproveContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                if (!$util.isInteger(message.proposal_id) && !(message.proposal_id && $util.isInteger(message.proposal_id.low) && $util.isInteger(message.proposal_id.high)))
                    return "proposal_id: integer|Long expected";
            if (message.is_add_approval != null && message.hasOwnProperty("is_add_approval"))
                if (typeof message.is_add_approval !== "boolean")
                    return "is_add_approval: boolean expected";
            return null;
        };

        /**
         * Creates a ProposalApproveContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ProposalApproveContract} ProposalApproveContract
         */
        ProposalApproveContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalApproveContract)
                return object;
            var message = new $root.protocol.ProposalApproveContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.proposal_id != null)
                if ($util.Long)
                    (message.proposal_id = $util.Long.fromValue(object.proposal_id)).unsigned = false;
                else if (typeof object.proposal_id === "string")
                    message.proposal_id = parseInt(object.proposal_id, 10);
                else if (typeof object.proposal_id === "number")
                    message.proposal_id = object.proposal_id;
                else if (typeof object.proposal_id === "object")
                    message.proposal_id = new $util.LongBits(object.proposal_id.low >>> 0, object.proposal_id.high >>> 0).toNumber();
            if (object.is_add_approval != null)
                message.is_add_approval = Boolean(object.is_add_approval);
            return message;
        };

        /**
         * Creates a plain object from a ProposalApproveContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ProposalApproveContract
         * @static
         * @param {protocol.ProposalApproveContract} message ProposalApproveContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalApproveContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposal_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proposal_id = options.longs === String ? "0" : 0;
                object.is_add_approval = false;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                if (typeof message.proposal_id === "number")
                    object.proposal_id = options.longs === String ? String(message.proposal_id) : message.proposal_id;
                else
                    object.proposal_id = options.longs === String ? $util.Long.prototype.toString.call(message.proposal_id) : options.longs === Number ? new $util.LongBits(message.proposal_id.low >>> 0, message.proposal_id.high >>> 0).toNumber() : message.proposal_id;
            if (message.is_add_approval != null && message.hasOwnProperty("is_add_approval"))
                object.is_add_approval = message.is_add_approval;
            return object;
        };

        /**
         * Converts this ProposalApproveContract to JSON.
         * @function toJSON
         * @memberof protocol.ProposalApproveContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalApproveContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalApproveContract;
    })();

    protocol.ProposalDeleteContract = (function() {

        /**
         * Properties of a ProposalDeleteContract.
         * @memberof protocol
         * @interface IProposalDeleteContract
         * @property {Uint8Array|null} [owner_address] ProposalDeleteContract owner_address
         * @property {number|Long|null} [proposal_id] ProposalDeleteContract proposal_id
         */

        /**
         * Constructs a new ProposalDeleteContract.
         * @memberof protocol
         * @classdesc Represents a ProposalDeleteContract.
         * @implements IProposalDeleteContract
         * @constructor
         * @param {protocol.IProposalDeleteContract=} [properties] Properties to set
         */
        function ProposalDeleteContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProposalDeleteContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ProposalDeleteContract
         * @instance
         */
        ProposalDeleteContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ProposalDeleteContract proposal_id.
         * @member {number|Long} proposal_id
         * @memberof protocol.ProposalDeleteContract
         * @instance
         */
        ProposalDeleteContract.prototype.proposal_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ProposalDeleteContract instance using the specified properties.
         * @function create
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.IProposalDeleteContract=} [properties] Properties to set
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract instance
         */
        ProposalDeleteContract.create = function create(properties) {
            return new ProposalDeleteContract(properties);
        };

        /**
         * Encodes the specified ProposalDeleteContract message. Does not implicitly {@link protocol.ProposalDeleteContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.IProposalDeleteContract} message ProposalDeleteContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalDeleteContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.proposal_id);
            return writer;
        };

        /**
         * Encodes the specified ProposalDeleteContract message, length delimited. Does not implicitly {@link protocol.ProposalDeleteContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.IProposalDeleteContract} message ProposalDeleteContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProposalDeleteContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProposalDeleteContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalDeleteContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ProposalDeleteContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.proposal_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProposalDeleteContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProposalDeleteContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProposalDeleteContract message.
         * @function verify
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProposalDeleteContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                if (!$util.isInteger(message.proposal_id) && !(message.proposal_id && $util.isInteger(message.proposal_id.low) && $util.isInteger(message.proposal_id.high)))
                    return "proposal_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a ProposalDeleteContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ProposalDeleteContract} ProposalDeleteContract
         */
        ProposalDeleteContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ProposalDeleteContract)
                return object;
            var message = new $root.protocol.ProposalDeleteContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.proposal_id != null)
                if ($util.Long)
                    (message.proposal_id = $util.Long.fromValue(object.proposal_id)).unsigned = false;
                else if (typeof object.proposal_id === "string")
                    message.proposal_id = parseInt(object.proposal_id, 10);
                else if (typeof object.proposal_id === "number")
                    message.proposal_id = object.proposal_id;
                else if (typeof object.proposal_id === "object")
                    message.proposal_id = new $util.LongBits(object.proposal_id.low >>> 0, object.proposal_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ProposalDeleteContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ProposalDeleteContract
         * @static
         * @param {protocol.ProposalDeleteContract} message ProposalDeleteContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProposalDeleteContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposal_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proposal_id = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                if (typeof message.proposal_id === "number")
                    object.proposal_id = options.longs === String ? String(message.proposal_id) : message.proposal_id;
                else
                    object.proposal_id = options.longs === String ? $util.Long.prototype.toString.call(message.proposal_id) : options.longs === Number ? new $util.LongBits(message.proposal_id.low >>> 0, message.proposal_id.high >>> 0).toNumber() : message.proposal_id;
            return object;
        };

        /**
         * Converts this ProposalDeleteContract to JSON.
         * @function toJSON
         * @memberof protocol.ProposalDeleteContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProposalDeleteContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ProposalDeleteContract;
    })();

    protocol.CreateSmartContract = (function() {

        /**
         * Properties of a CreateSmartContract.
         * @memberof protocol
         * @interface ICreateSmartContract
         * @property {Uint8Array|null} [owner_address] CreateSmartContract owner_address
         * @property {protocol.ISmartContract|null} [new_contract] CreateSmartContract new_contract
         * @property {number|Long|null} [call_token_value] CreateSmartContract call_token_value
         * @property {number|Long|null} [token_id] CreateSmartContract token_id
         */

        /**
         * Constructs a new CreateSmartContract.
         * @memberof protocol
         * @classdesc Represents a CreateSmartContract.
         * @implements ICreateSmartContract
         * @constructor
         * @param {protocol.ICreateSmartContract=} [properties] Properties to set
         */
        function CreateSmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateSmartContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * CreateSmartContract new_contract.
         * @member {protocol.ISmartContract|null|undefined} new_contract
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.new_contract = null;

        /**
         * CreateSmartContract call_token_value.
         * @member {number|Long} call_token_value
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.call_token_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateSmartContract token_id.
         * @member {number|Long} token_id
         * @memberof protocol.CreateSmartContract
         * @instance
         */
        CreateSmartContract.prototype.token_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CreateSmartContract instance using the specified properties.
         * @function create
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.ICreateSmartContract=} [properties] Properties to set
         * @returns {protocol.CreateSmartContract} CreateSmartContract instance
         */
        CreateSmartContract.create = function create(properties) {
            return new CreateSmartContract(properties);
        };

        /**
         * Encodes the specified CreateSmartContract message. Does not implicitly {@link protocol.CreateSmartContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.ICreateSmartContract} message CreateSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.new_contract != null && message.hasOwnProperty("new_contract"))
                $root.protocol.SmartContract.encode(message.new_contract, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.call_token_value != null && message.hasOwnProperty("call_token_value"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.call_token_value);
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.token_id);
            return writer;
        };

        /**
         * Encodes the specified CreateSmartContract message, length delimited. Does not implicitly {@link protocol.CreateSmartContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.ICreateSmartContract} message CreateSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateSmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateSmartContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.CreateSmartContract} CreateSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.CreateSmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.new_contract = $root.protocol.SmartContract.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.call_token_value = reader.int64();
                    break;
                case 4:
                    message.token_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateSmartContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.CreateSmartContract} CreateSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateSmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateSmartContract message.
         * @function verify
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateSmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.new_contract != null && message.hasOwnProperty("new_contract")) {
                var error = $root.protocol.SmartContract.verify(message.new_contract);
                if (error)
                    return "new_contract." + error;
            }
            if (message.call_token_value != null && message.hasOwnProperty("call_token_value"))
                if (!$util.isInteger(message.call_token_value) && !(message.call_token_value && $util.isInteger(message.call_token_value.low) && $util.isInteger(message.call_token_value.high)))
                    return "call_token_value: integer|Long expected";
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (!$util.isInteger(message.token_id) && !(message.token_id && $util.isInteger(message.token_id.low) && $util.isInteger(message.token_id.high)))
                    return "token_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a CreateSmartContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.CreateSmartContract} CreateSmartContract
         */
        CreateSmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.CreateSmartContract)
                return object;
            var message = new $root.protocol.CreateSmartContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.new_contract != null) {
                if (typeof object.new_contract !== "object")
                    throw TypeError(".protocol.CreateSmartContract.new_contract: object expected");
                message.new_contract = $root.protocol.SmartContract.fromObject(object.new_contract);
            }
            if (object.call_token_value != null)
                if ($util.Long)
                    (message.call_token_value = $util.Long.fromValue(object.call_token_value)).unsigned = false;
                else if (typeof object.call_token_value === "string")
                    message.call_token_value = parseInt(object.call_token_value, 10);
                else if (typeof object.call_token_value === "number")
                    message.call_token_value = object.call_token_value;
                else if (typeof object.call_token_value === "object")
                    message.call_token_value = new $util.LongBits(object.call_token_value.low >>> 0, object.call_token_value.high >>> 0).toNumber();
            if (object.token_id != null)
                if ($util.Long)
                    (message.token_id = $util.Long.fromValue(object.token_id)).unsigned = false;
                else if (typeof object.token_id === "string")
                    message.token_id = parseInt(object.token_id, 10);
                else if (typeof object.token_id === "number")
                    message.token_id = object.token_id;
                else if (typeof object.token_id === "object")
                    message.token_id = new $util.LongBits(object.token_id.low >>> 0, object.token_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CreateSmartContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.CreateSmartContract
         * @static
         * @param {protocol.CreateSmartContract} message CreateSmartContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CreateSmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                object.new_contract = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.call_token_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.call_token_value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.token_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.token_id = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.new_contract != null && message.hasOwnProperty("new_contract"))
                object.new_contract = $root.protocol.SmartContract.toObject(message.new_contract, options);
            if (message.call_token_value != null && message.hasOwnProperty("call_token_value"))
                if (typeof message.call_token_value === "number")
                    object.call_token_value = options.longs === String ? String(message.call_token_value) : message.call_token_value;
                else
                    object.call_token_value = options.longs === String ? $util.Long.prototype.toString.call(message.call_token_value) : options.longs === Number ? new $util.LongBits(message.call_token_value.low >>> 0, message.call_token_value.high >>> 0).toNumber() : message.call_token_value;
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (typeof message.token_id === "number")
                    object.token_id = options.longs === String ? String(message.token_id) : message.token_id;
                else
                    object.token_id = options.longs === String ? $util.Long.prototype.toString.call(message.token_id) : options.longs === Number ? new $util.LongBits(message.token_id.low >>> 0, message.token_id.high >>> 0).toNumber() : message.token_id;
            return object;
        };

        /**
         * Converts this CreateSmartContract to JSON.
         * @function toJSON
         * @memberof protocol.CreateSmartContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CreateSmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CreateSmartContract;
    })();

    protocol.TriggerSmartContract = (function() {

        /**
         * Properties of a TriggerSmartContract.
         * @memberof protocol
         * @interface ITriggerSmartContract
         * @property {Uint8Array|null} [owner_address] TriggerSmartContract owner_address
         * @property {Uint8Array|null} [contract_address] TriggerSmartContract contract_address
         * @property {number|Long|null} [call_value] TriggerSmartContract call_value
         * @property {Uint8Array|null} [data] TriggerSmartContract data
         * @property {number|Long|null} [call_token_value] TriggerSmartContract call_token_value
         * @property {number|Long|null} [token_id] TriggerSmartContract token_id
         */

        /**
         * Constructs a new TriggerSmartContract.
         * @memberof protocol
         * @classdesc Represents a TriggerSmartContract.
         * @implements ITriggerSmartContract
         * @constructor
         * @param {protocol.ITriggerSmartContract=} [properties] Properties to set
         */
        function TriggerSmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TriggerSmartContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * TriggerSmartContract contract_address.
         * @member {Uint8Array} contract_address
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.contract_address = $util.newBuffer([]);

        /**
         * TriggerSmartContract call_value.
         * @member {number|Long} call_value
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.call_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TriggerSmartContract data.
         * @member {Uint8Array} data
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.data = $util.newBuffer([]);

        /**
         * TriggerSmartContract call_token_value.
         * @member {number|Long} call_token_value
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.call_token_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TriggerSmartContract token_id.
         * @member {number|Long} token_id
         * @memberof protocol.TriggerSmartContract
         * @instance
         */
        TriggerSmartContract.prototype.token_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TriggerSmartContract instance using the specified properties.
         * @function create
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.ITriggerSmartContract=} [properties] Properties to set
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract instance
         */
        TriggerSmartContract.create = function create(properties) {
            return new TriggerSmartContract(properties);
        };

        /**
         * Encodes the specified TriggerSmartContract message. Does not implicitly {@link protocol.TriggerSmartContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.ITriggerSmartContract} message TriggerSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerSmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract_address);
            if (message.call_value != null && message.hasOwnProperty("call_value"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.call_value);
            if (message.data != null && message.hasOwnProperty("data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);
            if (message.call_token_value != null && message.hasOwnProperty("call_token_value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.call_token_value);
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.token_id);
            return writer;
        };

        /**
         * Encodes the specified TriggerSmartContract message, length delimited. Does not implicitly {@link protocol.TriggerSmartContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.ITriggerSmartContract} message TriggerSmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TriggerSmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TriggerSmartContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerSmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TriggerSmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.contract_address = reader.bytes();
                    break;
                case 3:
                    message.call_value = reader.int64();
                    break;
                case 4:
                    message.data = reader.bytes();
                    break;
                case 5:
                    message.call_token_value = reader.int64();
                    break;
                case 6:
                    message.token_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TriggerSmartContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TriggerSmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TriggerSmartContract message.
         * @function verify
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TriggerSmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                if (!(message.contract_address && typeof message.contract_address.length === "number" || $util.isString(message.contract_address)))
                    return "contract_address: buffer expected";
            if (message.call_value != null && message.hasOwnProperty("call_value"))
                if (!$util.isInteger(message.call_value) && !(message.call_value && $util.isInteger(message.call_value.low) && $util.isInteger(message.call_value.high)))
                    return "call_value: integer|Long expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.call_token_value != null && message.hasOwnProperty("call_token_value"))
                if (!$util.isInteger(message.call_token_value) && !(message.call_token_value && $util.isInteger(message.call_token_value.low) && $util.isInteger(message.call_token_value.high)))
                    return "call_token_value: integer|Long expected";
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (!$util.isInteger(message.token_id) && !(message.token_id && $util.isInteger(message.token_id.low) && $util.isInteger(message.token_id.high)))
                    return "token_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a TriggerSmartContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TriggerSmartContract} TriggerSmartContract
         */
        TriggerSmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TriggerSmartContract)
                return object;
            var message = new $root.protocol.TriggerSmartContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.contract_address != null)
                if (typeof object.contract_address === "string")
                    $util.base64.decode(object.contract_address, message.contract_address = $util.newBuffer($util.base64.length(object.contract_address)), 0);
                else if (object.contract_address.length)
                    message.contract_address = object.contract_address;
            if (object.call_value != null)
                if ($util.Long)
                    (message.call_value = $util.Long.fromValue(object.call_value)).unsigned = false;
                else if (typeof object.call_value === "string")
                    message.call_value = parseInt(object.call_value, 10);
                else if (typeof object.call_value === "number")
                    message.call_value = object.call_value;
                else if (typeof object.call_value === "object")
                    message.call_value = new $util.LongBits(object.call_value.low >>> 0, object.call_value.high >>> 0).toNumber();
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                    message.data = object.data;
            if (object.call_token_value != null)
                if ($util.Long)
                    (message.call_token_value = $util.Long.fromValue(object.call_token_value)).unsigned = false;
                else if (typeof object.call_token_value === "string")
                    message.call_token_value = parseInt(object.call_token_value, 10);
                else if (typeof object.call_token_value === "number")
                    message.call_token_value = object.call_token_value;
                else if (typeof object.call_token_value === "object")
                    message.call_token_value = new $util.LongBits(object.call_token_value.low >>> 0, object.call_token_value.high >>> 0).toNumber();
            if (object.token_id != null)
                if ($util.Long)
                    (message.token_id = $util.Long.fromValue(object.token_id)).unsigned = false;
                else if (typeof object.token_id === "string")
                    message.token_id = parseInt(object.token_id, 10);
                else if (typeof object.token_id === "number")
                    message.token_id = object.token_id;
                else if (typeof object.token_id === "object")
                    message.token_id = new $util.LongBits(object.token_id.low >>> 0, object.token_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TriggerSmartContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TriggerSmartContract
         * @static
         * @param {protocol.TriggerSmartContract} message TriggerSmartContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TriggerSmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.contract_address = "";
                else {
                    object.contract_address = [];
                    if (options.bytes !== Array)
                        object.contract_address = $util.newBuffer(object.contract_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.call_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.call_value = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.call_token_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.call_token_value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.token_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.token_id = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                object.contract_address = options.bytes === String ? $util.base64.encode(message.contract_address, 0, message.contract_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_address) : message.contract_address;
            if (message.call_value != null && message.hasOwnProperty("call_value"))
                if (typeof message.call_value === "number")
                    object.call_value = options.longs === String ? String(message.call_value) : message.call_value;
                else
                    object.call_value = options.longs === String ? $util.Long.prototype.toString.call(message.call_value) : options.longs === Number ? new $util.LongBits(message.call_value.low >>> 0, message.call_value.high >>> 0).toNumber() : message.call_value;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.call_token_value != null && message.hasOwnProperty("call_token_value"))
                if (typeof message.call_token_value === "number")
                    object.call_token_value = options.longs === String ? String(message.call_token_value) : message.call_token_value;
                else
                    object.call_token_value = options.longs === String ? $util.Long.prototype.toString.call(message.call_token_value) : options.longs === Number ? new $util.LongBits(message.call_token_value.low >>> 0, message.call_token_value.high >>> 0).toNumber() : message.call_token_value;
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (typeof message.token_id === "number")
                    object.token_id = options.longs === String ? String(message.token_id) : message.token_id;
                else
                    object.token_id = options.longs === String ? $util.Long.prototype.toString.call(message.token_id) : options.longs === Number ? new $util.LongBits(message.token_id.low >>> 0, message.token_id.high >>> 0).toNumber() : message.token_id;
            return object;
        };

        /**
         * Converts this TriggerSmartContract to JSON.
         * @function toJSON
         * @memberof protocol.TriggerSmartContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TriggerSmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TriggerSmartContract;
    })();

    protocol.BuyStorageContract = (function() {

        /**
         * Properties of a BuyStorageContract.
         * @memberof protocol
         * @interface IBuyStorageContract
         * @property {Uint8Array|null} [owner_address] BuyStorageContract owner_address
         * @property {number|Long|null} [quant] BuyStorageContract quant
         */

        /**
         * Constructs a new BuyStorageContract.
         * @memberof protocol
         * @classdesc Represents a BuyStorageContract.
         * @implements IBuyStorageContract
         * @constructor
         * @param {protocol.IBuyStorageContract=} [properties] Properties to set
         */
        function BuyStorageContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyStorageContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.BuyStorageContract
         * @instance
         */
        BuyStorageContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * BuyStorageContract quant.
         * @member {number|Long} quant
         * @memberof protocol.BuyStorageContract
         * @instance
         */
        BuyStorageContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BuyStorageContract instance using the specified properties.
         * @function create
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.IBuyStorageContract=} [properties] Properties to set
         * @returns {protocol.BuyStorageContract} BuyStorageContract instance
         */
        BuyStorageContract.create = function create(properties) {
            return new BuyStorageContract(properties);
        };

        /**
         * Encodes the specified BuyStorageContract message. Does not implicitly {@link protocol.BuyStorageContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.IBuyStorageContract} message BuyStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.quant != null && message.hasOwnProperty("quant"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.quant);
            return writer;
        };

        /**
         * Encodes the specified BuyStorageContract message, length delimited. Does not implicitly {@link protocol.BuyStorageContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.IBuyStorageContract} message BuyStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyStorageContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BuyStorageContract} BuyStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BuyStorageContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.quant = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyStorageContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BuyStorageContract} BuyStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyStorageContract message.
         * @function verify
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyStorageContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };

        /**
         * Creates a BuyStorageContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BuyStorageContract} BuyStorageContract
         */
        BuyStorageContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BuyStorageContract)
                return object;
            var message = new $root.protocol.BuyStorageContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BuyStorageContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BuyStorageContract
         * @static
         * @param {protocol.BuyStorageContract} message BuyStorageContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuyStorageContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };

        /**
         * Converts this BuyStorageContract to JSON.
         * @function toJSON
         * @memberof protocol.BuyStorageContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuyStorageContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuyStorageContract;
    })();

    protocol.BuyStorageBytesContract = (function() {

        /**
         * Properties of a BuyStorageBytesContract.
         * @memberof protocol
         * @interface IBuyStorageBytesContract
         * @property {Uint8Array|null} [owner_address] BuyStorageBytesContract owner_address
         * @property {number|Long|null} [bytes] BuyStorageBytesContract bytes
         */

        /**
         * Constructs a new BuyStorageBytesContract.
         * @memberof protocol
         * @classdesc Represents a BuyStorageBytesContract.
         * @implements IBuyStorageBytesContract
         * @constructor
         * @param {protocol.IBuyStorageBytesContract=} [properties] Properties to set
         */
        function BuyStorageBytesContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyStorageBytesContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.BuyStorageBytesContract
         * @instance
         */
        BuyStorageBytesContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * BuyStorageBytesContract bytes.
         * @member {number|Long} bytes
         * @memberof protocol.BuyStorageBytesContract
         * @instance
         */
        BuyStorageBytesContract.prototype.bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new BuyStorageBytesContract instance using the specified properties.
         * @function create
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.IBuyStorageBytesContract=} [properties] Properties to set
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract instance
         */
        BuyStorageBytesContract.create = function create(properties) {
            return new BuyStorageBytesContract(properties);
        };

        /**
         * Encodes the specified BuyStorageBytesContract message. Does not implicitly {@link protocol.BuyStorageBytesContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.IBuyStorageBytesContract} message BuyStorageBytesContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageBytesContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.bytes);
            return writer;
        };

        /**
         * Encodes the specified BuyStorageBytesContract message, length delimited. Does not implicitly {@link protocol.BuyStorageBytesContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.IBuyStorageBytesContract} message BuyStorageBytesContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyStorageBytesContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyStorageBytesContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageBytesContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BuyStorageBytesContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.bytes = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyStorageBytesContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyStorageBytesContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyStorageBytesContract message.
         * @function verify
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyStorageBytesContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (!$util.isInteger(message.bytes) && !(message.bytes && $util.isInteger(message.bytes.low) && $util.isInteger(message.bytes.high)))
                    return "bytes: integer|Long expected";
            return null;
        };

        /**
         * Creates a BuyStorageBytesContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BuyStorageBytesContract} BuyStorageBytesContract
         */
        BuyStorageBytesContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BuyStorageBytesContract)
                return object;
            var message = new $root.protocol.BuyStorageBytesContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.bytes != null)
                if ($util.Long)
                    (message.bytes = $util.Long.fromValue(object.bytes)).unsigned = false;
                else if (typeof object.bytes === "string")
                    message.bytes = parseInt(object.bytes, 10);
                else if (typeof object.bytes === "number")
                    message.bytes = object.bytes;
                else if (typeof object.bytes === "object")
                    message.bytes = new $util.LongBits(object.bytes.low >>> 0, object.bytes.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a BuyStorageBytesContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BuyStorageBytesContract
         * @static
         * @param {protocol.BuyStorageBytesContract} message BuyStorageBytesContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BuyStorageBytesContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytes = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.bytes != null && message.hasOwnProperty("bytes"))
                if (typeof message.bytes === "number")
                    object.bytes = options.longs === String ? String(message.bytes) : message.bytes;
                else
                    object.bytes = options.longs === String ? $util.Long.prototype.toString.call(message.bytes) : options.longs === Number ? new $util.LongBits(message.bytes.low >>> 0, message.bytes.high >>> 0).toNumber() : message.bytes;
            return object;
        };

        /**
         * Converts this BuyStorageBytesContract to JSON.
         * @function toJSON
         * @memberof protocol.BuyStorageBytesContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BuyStorageBytesContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BuyStorageBytesContract;
    })();

    protocol.SellStorageContract = (function() {

        /**
         * Properties of a SellStorageContract.
         * @memberof protocol
         * @interface ISellStorageContract
         * @property {Uint8Array|null} [owner_address] SellStorageContract owner_address
         * @property {number|Long|null} [storage_bytes] SellStorageContract storage_bytes
         */

        /**
         * Constructs a new SellStorageContract.
         * @memberof protocol
         * @classdesc Represents a SellStorageContract.
         * @implements ISellStorageContract
         * @constructor
         * @param {protocol.ISellStorageContract=} [properties] Properties to set
         */
        function SellStorageContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SellStorageContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.SellStorageContract
         * @instance
         */
        SellStorageContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * SellStorageContract storage_bytes.
         * @member {number|Long} storage_bytes
         * @memberof protocol.SellStorageContract
         * @instance
         */
        SellStorageContract.prototype.storage_bytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SellStorageContract instance using the specified properties.
         * @function create
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.ISellStorageContract=} [properties] Properties to set
         * @returns {protocol.SellStorageContract} SellStorageContract instance
         */
        SellStorageContract.create = function create(properties) {
            return new SellStorageContract(properties);
        };

        /**
         * Encodes the specified SellStorageContract message. Does not implicitly {@link protocol.SellStorageContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.ISellStorageContract} message SellStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellStorageContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.storage_bytes != null && message.hasOwnProperty("storage_bytes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.storage_bytes);
            return writer;
        };

        /**
         * Encodes the specified SellStorageContract message, length delimited. Does not implicitly {@link protocol.SellStorageContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.ISellStorageContract} message SellStorageContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SellStorageContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SellStorageContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.SellStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.SellStorageContract} SellStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellStorageContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SellStorageContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.storage_bytes = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SellStorageContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.SellStorageContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.SellStorageContract} SellStorageContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SellStorageContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SellStorageContract message.
         * @function verify
         * @memberof protocol.SellStorageContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SellStorageContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.storage_bytes != null && message.hasOwnProperty("storage_bytes"))
                if (!$util.isInteger(message.storage_bytes) && !(message.storage_bytes && $util.isInteger(message.storage_bytes.low) && $util.isInteger(message.storage_bytes.high)))
                    return "storage_bytes: integer|Long expected";
            return null;
        };

        /**
         * Creates a SellStorageContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.SellStorageContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.SellStorageContract} SellStorageContract
         */
        SellStorageContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SellStorageContract)
                return object;
            var message = new $root.protocol.SellStorageContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.storage_bytes != null)
                if ($util.Long)
                    (message.storage_bytes = $util.Long.fromValue(object.storage_bytes)).unsigned = false;
                else if (typeof object.storage_bytes === "string")
                    message.storage_bytes = parseInt(object.storage_bytes, 10);
                else if (typeof object.storage_bytes === "number")
                    message.storage_bytes = object.storage_bytes;
                else if (typeof object.storage_bytes === "object")
                    message.storage_bytes = new $util.LongBits(object.storage_bytes.low >>> 0, object.storage_bytes.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SellStorageContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.SellStorageContract
         * @static
         * @param {protocol.SellStorageContract} message SellStorageContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SellStorageContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.storage_bytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.storage_bytes = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.storage_bytes != null && message.hasOwnProperty("storage_bytes"))
                if (typeof message.storage_bytes === "number")
                    object.storage_bytes = options.longs === String ? String(message.storage_bytes) : message.storage_bytes;
                else
                    object.storage_bytes = options.longs === String ? $util.Long.prototype.toString.call(message.storage_bytes) : options.longs === Number ? new $util.LongBits(message.storage_bytes.low >>> 0, message.storage_bytes.high >>> 0).toNumber() : message.storage_bytes;
            return object;
        };

        /**
         * Converts this SellStorageContract to JSON.
         * @function toJSON
         * @memberof protocol.SellStorageContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SellStorageContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SellStorageContract;
    })();

    protocol.ExchangeCreateContract = (function() {

        /**
         * Properties of an ExchangeCreateContract.
         * @memberof protocol
         * @interface IExchangeCreateContract
         * @property {Uint8Array|null} [owner_address] ExchangeCreateContract owner_address
         * @property {Uint8Array|null} [first_token_id] ExchangeCreateContract first_token_id
         * @property {number|Long|null} [first_token_balance] ExchangeCreateContract first_token_balance
         * @property {Uint8Array|null} [second_token_id] ExchangeCreateContract second_token_id
         * @property {number|Long|null} [second_token_balance] ExchangeCreateContract second_token_balance
         */

        /**
         * Constructs a new ExchangeCreateContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeCreateContract.
         * @implements IExchangeCreateContract
         * @constructor
         * @param {protocol.IExchangeCreateContract=} [properties] Properties to set
         */
        function ExchangeCreateContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeCreateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ExchangeCreateContract first_token_id.
         * @member {Uint8Array} first_token_id
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.first_token_id = $util.newBuffer([]);

        /**
         * ExchangeCreateContract first_token_balance.
         * @member {number|Long} first_token_balance
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.first_token_balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeCreateContract second_token_id.
         * @member {Uint8Array} second_token_id
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.second_token_id = $util.newBuffer([]);

        /**
         * ExchangeCreateContract second_token_balance.
         * @member {number|Long} second_token_balance
         * @memberof protocol.ExchangeCreateContract
         * @instance
         */
        ExchangeCreateContract.prototype.second_token_balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeCreateContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.IExchangeCreateContract=} [properties] Properties to set
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract instance
         */
        ExchangeCreateContract.create = function create(properties) {
            return new ExchangeCreateContract(properties);
        };

        /**
         * Encodes the specified ExchangeCreateContract message. Does not implicitly {@link protocol.ExchangeCreateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.IExchangeCreateContract} message ExchangeCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCreateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.first_token_id != null && message.hasOwnProperty("first_token_id"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.first_token_id);
            if (message.first_token_balance != null && message.hasOwnProperty("first_token_balance"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.first_token_balance);
            if (message.second_token_id != null && message.hasOwnProperty("second_token_id"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.second_token_id);
            if (message.second_token_balance != null && message.hasOwnProperty("second_token_balance"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.second_token_balance);
            return writer;
        };

        /**
         * Encodes the specified ExchangeCreateContract message, length delimited. Does not implicitly {@link protocol.ExchangeCreateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.IExchangeCreateContract} message ExchangeCreateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCreateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeCreateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCreateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeCreateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.first_token_id = reader.bytes();
                    break;
                case 3:
                    message.first_token_balance = reader.int64();
                    break;
                case 4:
                    message.second_token_id = reader.bytes();
                    break;
                case 5:
                    message.second_token_balance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeCreateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCreateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeCreateContract message.
         * @function verify
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeCreateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.first_token_id != null && message.hasOwnProperty("first_token_id"))
                if (!(message.first_token_id && typeof message.first_token_id.length === "number" || $util.isString(message.first_token_id)))
                    return "first_token_id: buffer expected";
            if (message.first_token_balance != null && message.hasOwnProperty("first_token_balance"))
                if (!$util.isInteger(message.first_token_balance) && !(message.first_token_balance && $util.isInteger(message.first_token_balance.low) && $util.isInteger(message.first_token_balance.high)))
                    return "first_token_balance: integer|Long expected";
            if (message.second_token_id != null && message.hasOwnProperty("second_token_id"))
                if (!(message.second_token_id && typeof message.second_token_id.length === "number" || $util.isString(message.second_token_id)))
                    return "second_token_id: buffer expected";
            if (message.second_token_balance != null && message.hasOwnProperty("second_token_balance"))
                if (!$util.isInteger(message.second_token_balance) && !(message.second_token_balance && $util.isInteger(message.second_token_balance.low) && $util.isInteger(message.second_token_balance.high)))
                    return "second_token_balance: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeCreateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeCreateContract} ExchangeCreateContract
         */
        ExchangeCreateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeCreateContract)
                return object;
            var message = new $root.protocol.ExchangeCreateContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.first_token_id != null)
                if (typeof object.first_token_id === "string")
                    $util.base64.decode(object.first_token_id, message.first_token_id = $util.newBuffer($util.base64.length(object.first_token_id)), 0);
                else if (object.first_token_id.length)
                    message.first_token_id = object.first_token_id;
            if (object.first_token_balance != null)
                if ($util.Long)
                    (message.first_token_balance = $util.Long.fromValue(object.first_token_balance)).unsigned = false;
                else if (typeof object.first_token_balance === "string")
                    message.first_token_balance = parseInt(object.first_token_balance, 10);
                else if (typeof object.first_token_balance === "number")
                    message.first_token_balance = object.first_token_balance;
                else if (typeof object.first_token_balance === "object")
                    message.first_token_balance = new $util.LongBits(object.first_token_balance.low >>> 0, object.first_token_balance.high >>> 0).toNumber();
            if (object.second_token_id != null)
                if (typeof object.second_token_id === "string")
                    $util.base64.decode(object.second_token_id, message.second_token_id = $util.newBuffer($util.base64.length(object.second_token_id)), 0);
                else if (object.second_token_id.length)
                    message.second_token_id = object.second_token_id;
            if (object.second_token_balance != null)
                if ($util.Long)
                    (message.second_token_balance = $util.Long.fromValue(object.second_token_balance)).unsigned = false;
                else if (typeof object.second_token_balance === "string")
                    message.second_token_balance = parseInt(object.second_token_balance, 10);
                else if (typeof object.second_token_balance === "number")
                    message.second_token_balance = object.second_token_balance;
                else if (typeof object.second_token_balance === "object")
                    message.second_token_balance = new $util.LongBits(object.second_token_balance.low >>> 0, object.second_token_balance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeCreateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeCreateContract
         * @static
         * @param {protocol.ExchangeCreateContract} message ExchangeCreateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeCreateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if (options.bytes === String)
                    object.first_token_id = "";
                else {
                    object.first_token_id = [];
                    if (options.bytes !== Array)
                        object.first_token_id = $util.newBuffer(object.first_token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.first_token_balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.first_token_balance = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.second_token_id = "";
                else {
                    object.second_token_id = [];
                    if (options.bytes !== Array)
                        object.second_token_id = $util.newBuffer(object.second_token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.second_token_balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.second_token_balance = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.first_token_id != null && message.hasOwnProperty("first_token_id"))
                object.first_token_id = options.bytes === String ? $util.base64.encode(message.first_token_id, 0, message.first_token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.first_token_id) : message.first_token_id;
            if (message.first_token_balance != null && message.hasOwnProperty("first_token_balance"))
                if (typeof message.first_token_balance === "number")
                    object.first_token_balance = options.longs === String ? String(message.first_token_balance) : message.first_token_balance;
                else
                    object.first_token_balance = options.longs === String ? $util.Long.prototype.toString.call(message.first_token_balance) : options.longs === Number ? new $util.LongBits(message.first_token_balance.low >>> 0, message.first_token_balance.high >>> 0).toNumber() : message.first_token_balance;
            if (message.second_token_id != null && message.hasOwnProperty("second_token_id"))
                object.second_token_id = options.bytes === String ? $util.base64.encode(message.second_token_id, 0, message.second_token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.second_token_id) : message.second_token_id;
            if (message.second_token_balance != null && message.hasOwnProperty("second_token_balance"))
                if (typeof message.second_token_balance === "number")
                    object.second_token_balance = options.longs === String ? String(message.second_token_balance) : message.second_token_balance;
                else
                    object.second_token_balance = options.longs === String ? $util.Long.prototype.toString.call(message.second_token_balance) : options.longs === Number ? new $util.LongBits(message.second_token_balance.low >>> 0, message.second_token_balance.high >>> 0).toNumber() : message.second_token_balance;
            return object;
        };

        /**
         * Converts this ExchangeCreateContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeCreateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeCreateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeCreateContract;
    })();

    protocol.ExchangeInjectContract = (function() {

        /**
         * Properties of an ExchangeInjectContract.
         * @memberof protocol
         * @interface IExchangeInjectContract
         * @property {Uint8Array|null} [owner_address] ExchangeInjectContract owner_address
         * @property {number|Long|null} [exchange_id] ExchangeInjectContract exchange_id
         * @property {Uint8Array|null} [token_id] ExchangeInjectContract token_id
         * @property {number|Long|null} [quant] ExchangeInjectContract quant
         */

        /**
         * Constructs a new ExchangeInjectContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeInjectContract.
         * @implements IExchangeInjectContract
         * @constructor
         * @param {protocol.IExchangeInjectContract=} [properties] Properties to set
         */
        function ExchangeInjectContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeInjectContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ExchangeInjectContract exchange_id.
         * @member {number|Long} exchange_id
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.exchange_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeInjectContract token_id.
         * @member {Uint8Array} token_id
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.token_id = $util.newBuffer([]);

        /**
         * ExchangeInjectContract quant.
         * @member {number|Long} quant
         * @memberof protocol.ExchangeInjectContract
         * @instance
         */
        ExchangeInjectContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeInjectContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.IExchangeInjectContract=} [properties] Properties to set
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract instance
         */
        ExchangeInjectContract.create = function create(properties) {
            return new ExchangeInjectContract(properties);
        };

        /**
         * Encodes the specified ExchangeInjectContract message. Does not implicitly {@link protocol.ExchangeInjectContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.IExchangeInjectContract} message ExchangeInjectContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeInjectContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exchange_id);
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.token_id);
            if (message.quant != null && message.hasOwnProperty("quant"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quant);
            return writer;
        };

        /**
         * Encodes the specified ExchangeInjectContract message, length delimited. Does not implicitly {@link protocol.ExchangeInjectContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.IExchangeInjectContract} message ExchangeInjectContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeInjectContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeInjectContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeInjectContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeInjectContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.exchange_id = reader.int64();
                    break;
                case 3:
                    message.token_id = reader.bytes();
                    break;
                case 4:
                    message.quant = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeInjectContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeInjectContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeInjectContract message.
         * @function verify
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeInjectContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (!$util.isInteger(message.exchange_id) && !(message.exchange_id && $util.isInteger(message.exchange_id.low) && $util.isInteger(message.exchange_id.high)))
                    return "exchange_id: integer|Long expected";
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (!(message.token_id && typeof message.token_id.length === "number" || $util.isString(message.token_id)))
                    return "token_id: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeInjectContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeInjectContract} ExchangeInjectContract
         */
        ExchangeInjectContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeInjectContract)
                return object;
            var message = new $root.protocol.ExchangeInjectContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.exchange_id != null)
                if ($util.Long)
                    (message.exchange_id = $util.Long.fromValue(object.exchange_id)).unsigned = false;
                else if (typeof object.exchange_id === "string")
                    message.exchange_id = parseInt(object.exchange_id, 10);
                else if (typeof object.exchange_id === "number")
                    message.exchange_id = object.exchange_id;
                else if (typeof object.exchange_id === "object")
                    message.exchange_id = new $util.LongBits(object.exchange_id.low >>> 0, object.exchange_id.high >>> 0).toNumber();
            if (object.token_id != null)
                if (typeof object.token_id === "string")
                    $util.base64.decode(object.token_id, message.token_id = $util.newBuffer($util.base64.length(object.token_id)), 0);
                else if (object.token_id.length)
                    message.token_id = object.token_id;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeInjectContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeInjectContract
         * @static
         * @param {protocol.ExchangeInjectContract} message ExchangeInjectContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeInjectContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.token_id = "";
                else {
                    object.token_id = [];
                    if (options.bytes !== Array)
                        object.token_id = $util.newBuffer(object.token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (typeof message.exchange_id === "number")
                    object.exchange_id = options.longs === String ? String(message.exchange_id) : message.exchange_id;
                else
                    object.exchange_id = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_id) : options.longs === Number ? new $util.LongBits(message.exchange_id.low >>> 0, message.exchange_id.high >>> 0).toNumber() : message.exchange_id;
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                object.token_id = options.bytes === String ? $util.base64.encode(message.token_id, 0, message.token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.token_id) : message.token_id;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };

        /**
         * Converts this ExchangeInjectContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeInjectContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeInjectContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeInjectContract;
    })();

    protocol.ExchangeWithdrawContract = (function() {

        /**
         * Properties of an ExchangeWithdrawContract.
         * @memberof protocol
         * @interface IExchangeWithdrawContract
         * @property {Uint8Array|null} [owner_address] ExchangeWithdrawContract owner_address
         * @property {number|Long|null} [exchange_id] ExchangeWithdrawContract exchange_id
         * @property {Uint8Array|null} [token_id] ExchangeWithdrawContract token_id
         * @property {number|Long|null} [quant] ExchangeWithdrawContract quant
         */

        /**
         * Constructs a new ExchangeWithdrawContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeWithdrawContract.
         * @implements IExchangeWithdrawContract
         * @constructor
         * @param {protocol.IExchangeWithdrawContract=} [properties] Properties to set
         */
        function ExchangeWithdrawContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeWithdrawContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ExchangeWithdrawContract exchange_id.
         * @member {number|Long} exchange_id
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.exchange_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeWithdrawContract token_id.
         * @member {Uint8Array} token_id
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.token_id = $util.newBuffer([]);

        /**
         * ExchangeWithdrawContract quant.
         * @member {number|Long} quant
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         */
        ExchangeWithdrawContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeWithdrawContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.IExchangeWithdrawContract=} [properties] Properties to set
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract instance
         */
        ExchangeWithdrawContract.create = function create(properties) {
            return new ExchangeWithdrawContract(properties);
        };

        /**
         * Encodes the specified ExchangeWithdrawContract message. Does not implicitly {@link protocol.ExchangeWithdrawContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.IExchangeWithdrawContract} message ExchangeWithdrawContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeWithdrawContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exchange_id);
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.token_id);
            if (message.quant != null && message.hasOwnProperty("quant"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quant);
            return writer;
        };

        /**
         * Encodes the specified ExchangeWithdrawContract message, length delimited. Does not implicitly {@link protocol.ExchangeWithdrawContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.IExchangeWithdrawContract} message ExchangeWithdrawContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeWithdrawContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeWithdrawContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeWithdrawContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeWithdrawContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.exchange_id = reader.int64();
                    break;
                case 3:
                    message.token_id = reader.bytes();
                    break;
                case 4:
                    message.quant = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeWithdrawContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeWithdrawContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeWithdrawContract message.
         * @function verify
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeWithdrawContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (!$util.isInteger(message.exchange_id) && !(message.exchange_id && $util.isInteger(message.exchange_id.low) && $util.isInteger(message.exchange_id.high)))
                    return "exchange_id: integer|Long expected";
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (!(message.token_id && typeof message.token_id.length === "number" || $util.isString(message.token_id)))
                    return "token_id: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeWithdrawContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeWithdrawContract} ExchangeWithdrawContract
         */
        ExchangeWithdrawContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeWithdrawContract)
                return object;
            var message = new $root.protocol.ExchangeWithdrawContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.exchange_id != null)
                if ($util.Long)
                    (message.exchange_id = $util.Long.fromValue(object.exchange_id)).unsigned = false;
                else if (typeof object.exchange_id === "string")
                    message.exchange_id = parseInt(object.exchange_id, 10);
                else if (typeof object.exchange_id === "number")
                    message.exchange_id = object.exchange_id;
                else if (typeof object.exchange_id === "object")
                    message.exchange_id = new $util.LongBits(object.exchange_id.low >>> 0, object.exchange_id.high >>> 0).toNumber();
            if (object.token_id != null)
                if (typeof object.token_id === "string")
                    $util.base64.decode(object.token_id, message.token_id = $util.newBuffer($util.base64.length(object.token_id)), 0);
                else if (object.token_id.length)
                    message.token_id = object.token_id;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeWithdrawContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeWithdrawContract
         * @static
         * @param {protocol.ExchangeWithdrawContract} message ExchangeWithdrawContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeWithdrawContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.token_id = "";
                else {
                    object.token_id = [];
                    if (options.bytes !== Array)
                        object.token_id = $util.newBuffer(object.token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (typeof message.exchange_id === "number")
                    object.exchange_id = options.longs === String ? String(message.exchange_id) : message.exchange_id;
                else
                    object.exchange_id = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_id) : options.longs === Number ? new $util.LongBits(message.exchange_id.low >>> 0, message.exchange_id.high >>> 0).toNumber() : message.exchange_id;
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                object.token_id = options.bytes === String ? $util.base64.encode(message.token_id, 0, message.token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.token_id) : message.token_id;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            return object;
        };

        /**
         * Converts this ExchangeWithdrawContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeWithdrawContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeWithdrawContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeWithdrawContract;
    })();

    protocol.ExchangeTransactionContract = (function() {

        /**
         * Properties of an ExchangeTransactionContract.
         * @memberof protocol
         * @interface IExchangeTransactionContract
         * @property {Uint8Array|null} [owner_address] ExchangeTransactionContract owner_address
         * @property {number|Long|null} [exchange_id] ExchangeTransactionContract exchange_id
         * @property {Uint8Array|null} [token_id] ExchangeTransactionContract token_id
         * @property {number|Long|null} [quant] ExchangeTransactionContract quant
         * @property {number|Long|null} [expected] ExchangeTransactionContract expected
         */

        /**
         * Constructs a new ExchangeTransactionContract.
         * @memberof protocol
         * @classdesc Represents an ExchangeTransactionContract.
         * @implements IExchangeTransactionContract
         * @constructor
         * @param {protocol.IExchangeTransactionContract=} [properties] Properties to set
         */
        function ExchangeTransactionContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeTransactionContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * ExchangeTransactionContract exchange_id.
         * @member {number|Long} exchange_id
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.exchange_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionContract token_id.
         * @member {Uint8Array} token_id
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.token_id = $util.newBuffer([]);

        /**
         * ExchangeTransactionContract quant.
         * @member {number|Long} quant
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.quant = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ExchangeTransactionContract expected.
         * @member {number|Long} expected
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         */
        ExchangeTransactionContract.prototype.expected = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ExchangeTransactionContract instance using the specified properties.
         * @function create
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.IExchangeTransactionContract=} [properties] Properties to set
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract instance
         */
        ExchangeTransactionContract.create = function create(properties) {
            return new ExchangeTransactionContract(properties);
        };

        /**
         * Encodes the specified ExchangeTransactionContract message. Does not implicitly {@link protocol.ExchangeTransactionContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.IExchangeTransactionContract} message ExchangeTransactionContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTransactionContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exchange_id);
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.token_id);
            if (message.quant != null && message.hasOwnProperty("quant"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.quant);
            if (message.expected != null && message.hasOwnProperty("expected"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expected);
            return writer;
        };

        /**
         * Encodes the specified ExchangeTransactionContract message, length delimited. Does not implicitly {@link protocol.ExchangeTransactionContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.IExchangeTransactionContract} message ExchangeTransactionContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeTransactionContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeTransactionContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTransactionContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ExchangeTransactionContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.exchange_id = reader.int64();
                    break;
                case 3:
                    message.token_id = reader.bytes();
                    break;
                case 4:
                    message.quant = reader.int64();
                    break;
                case 5:
                    message.expected = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeTransactionContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeTransactionContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeTransactionContract message.
         * @function verify
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeTransactionContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (!$util.isInteger(message.exchange_id) && !(message.exchange_id && $util.isInteger(message.exchange_id.low) && $util.isInteger(message.exchange_id.high)))
                    return "exchange_id: integer|Long expected";
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                if (!(message.token_id && typeof message.token_id.length === "number" || $util.isString(message.token_id)))
                    return "token_id: buffer expected";
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (!$util.isInteger(message.quant) && !(message.quant && $util.isInteger(message.quant.low) && $util.isInteger(message.quant.high)))
                    return "quant: integer|Long expected";
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (!$util.isInteger(message.expected) && !(message.expected && $util.isInteger(message.expected.low) && $util.isInteger(message.expected.high)))
                    return "expected: integer|Long expected";
            return null;
        };

        /**
         * Creates an ExchangeTransactionContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ExchangeTransactionContract} ExchangeTransactionContract
         */
        ExchangeTransactionContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ExchangeTransactionContract)
                return object;
            var message = new $root.protocol.ExchangeTransactionContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.exchange_id != null)
                if ($util.Long)
                    (message.exchange_id = $util.Long.fromValue(object.exchange_id)).unsigned = false;
                else if (typeof object.exchange_id === "string")
                    message.exchange_id = parseInt(object.exchange_id, 10);
                else if (typeof object.exchange_id === "number")
                    message.exchange_id = object.exchange_id;
                else if (typeof object.exchange_id === "object")
                    message.exchange_id = new $util.LongBits(object.exchange_id.low >>> 0, object.exchange_id.high >>> 0).toNumber();
            if (object.token_id != null)
                if (typeof object.token_id === "string")
                    $util.base64.decode(object.token_id, message.token_id = $util.newBuffer($util.base64.length(object.token_id)), 0);
                else if (object.token_id.length)
                    message.token_id = object.token_id;
            if (object.quant != null)
                if ($util.Long)
                    (message.quant = $util.Long.fromValue(object.quant)).unsigned = false;
                else if (typeof object.quant === "string")
                    message.quant = parseInt(object.quant, 10);
                else if (typeof object.quant === "number")
                    message.quant = object.quant;
                else if (typeof object.quant === "object")
                    message.quant = new $util.LongBits(object.quant.low >>> 0, object.quant.high >>> 0).toNumber();
            if (object.expected != null)
                if ($util.Long)
                    (message.expected = $util.Long.fromValue(object.expected)).unsigned = false;
                else if (typeof object.expected === "string")
                    message.expected = parseInt(object.expected, 10);
                else if (typeof object.expected === "number")
                    message.expected = object.expected;
                else if (typeof object.expected === "object")
                    message.expected = new $util.LongBits(object.expected.low >>> 0, object.expected.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an ExchangeTransactionContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ExchangeTransactionContract
         * @static
         * @param {protocol.ExchangeTransactionContract} message ExchangeTransactionContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExchangeTransactionContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.token_id = "";
                else {
                    object.token_id = [];
                    if (options.bytes !== Array)
                        object.token_id = $util.newBuffer(object.token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.quant = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.quant = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expected = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expected = options.longs === String ? "0" : 0;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (typeof message.exchange_id === "number")
                    object.exchange_id = options.longs === String ? String(message.exchange_id) : message.exchange_id;
                else
                    object.exchange_id = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_id) : options.longs === Number ? new $util.LongBits(message.exchange_id.low >>> 0, message.exchange_id.high >>> 0).toNumber() : message.exchange_id;
            if (message.token_id != null && message.hasOwnProperty("token_id"))
                object.token_id = options.bytes === String ? $util.base64.encode(message.token_id, 0, message.token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.token_id) : message.token_id;
            if (message.quant != null && message.hasOwnProperty("quant"))
                if (typeof message.quant === "number")
                    object.quant = options.longs === String ? String(message.quant) : message.quant;
                else
                    object.quant = options.longs === String ? $util.Long.prototype.toString.call(message.quant) : options.longs === Number ? new $util.LongBits(message.quant.low >>> 0, message.quant.high >>> 0).toNumber() : message.quant;
            if (message.expected != null && message.hasOwnProperty("expected"))
                if (typeof message.expected === "number")
                    object.expected = options.longs === String ? String(message.expected) : message.expected;
                else
                    object.expected = options.longs === String ? $util.Long.prototype.toString.call(message.expected) : options.longs === Number ? new $util.LongBits(message.expected.low >>> 0, message.expected.high >>> 0).toNumber() : message.expected;
            return object;
        };

        /**
         * Converts this ExchangeTransactionContract to JSON.
         * @function toJSON
         * @memberof protocol.ExchangeTransactionContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExchangeTransactionContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExchangeTransactionContract;
    })();

    protocol.AccountPermissionUpdateContract = (function() {

        /**
         * Properties of an AccountPermissionUpdateContract.
         * @memberof protocol
         * @interface IAccountPermissionUpdateContract
         * @property {Uint8Array|null} [owner_address] AccountPermissionUpdateContract owner_address
         * @property {protocol.IPermission|null} [owner] AccountPermissionUpdateContract owner
         * @property {protocol.IPermission|null} [witness] AccountPermissionUpdateContract witness
         * @property {Array.<protocol.IPermission>|null} [actives] AccountPermissionUpdateContract actives
         */

        /**
         * Constructs a new AccountPermissionUpdateContract.
         * @memberof protocol
         * @classdesc Represents an AccountPermissionUpdateContract.
         * @implements IAccountPermissionUpdateContract
         * @constructor
         * @param {protocol.IAccountPermissionUpdateContract=} [properties] Properties to set
         */
        function AccountPermissionUpdateContract(properties) {
            this.actives = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountPermissionUpdateContract owner_address.
         * @member {Uint8Array} owner_address
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.owner_address = $util.newBuffer([]);

        /**
         * AccountPermissionUpdateContract owner.
         * @member {protocol.IPermission|null|undefined} owner
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.owner = null;

        /**
         * AccountPermissionUpdateContract witness.
         * @member {protocol.IPermission|null|undefined} witness
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.witness = null;

        /**
         * AccountPermissionUpdateContract actives.
         * @member {Array.<protocol.IPermission>} actives
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         */
        AccountPermissionUpdateContract.prototype.actives = $util.emptyArray;

        /**
         * Creates a new AccountPermissionUpdateContract instance using the specified properties.
         * @function create
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.IAccountPermissionUpdateContract=} [properties] Properties to set
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract instance
         */
        AccountPermissionUpdateContract.create = function create(properties) {
            return new AccountPermissionUpdateContract(properties);
        };

        /**
         * Encodes the specified AccountPermissionUpdateContract message. Does not implicitly {@link protocol.AccountPermissionUpdateContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.IAccountPermissionUpdateContract} message AccountPermissionUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPermissionUpdateContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner_address);
            if (message.owner != null && message.hasOwnProperty("owner"))
                $root.protocol.Permission.encode(message.owner, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.witness != null && message.hasOwnProperty("witness"))
                $root.protocol.Permission.encode(message.witness, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.actives != null && message.actives.length)
                for (var i = 0; i < message.actives.length; ++i)
                    $root.protocol.Permission.encode(message.actives[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountPermissionUpdateContract message, length delimited. Does not implicitly {@link protocol.AccountPermissionUpdateContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.IAccountPermissionUpdateContract} message AccountPermissionUpdateContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountPermissionUpdateContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountPermissionUpdateContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPermissionUpdateContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountPermissionUpdateContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.owner_address = reader.bytes();
                    break;
                case 2:
                    message.owner = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.witness = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 4:
                    if (!(message.actives && message.actives.length))
                        message.actives = [];
                    message.actives.push($root.protocol.Permission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountPermissionUpdateContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountPermissionUpdateContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountPermissionUpdateContract message.
         * @function verify
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountPermissionUpdateContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                if (!(message.owner_address && typeof message.owner_address.length === "number" || $util.isString(message.owner_address)))
                    return "owner_address: buffer expected";
            if (message.owner != null && message.hasOwnProperty("owner")) {
                var error = $root.protocol.Permission.verify(message.owner);
                if (error)
                    return "owner." + error;
            }
            if (message.witness != null && message.hasOwnProperty("witness")) {
                var error = $root.protocol.Permission.verify(message.witness);
                if (error)
                    return "witness." + error;
            }
            if (message.actives != null && message.hasOwnProperty("actives")) {
                if (!Array.isArray(message.actives))
                    return "actives: array expected";
                for (var i = 0; i < message.actives.length; ++i) {
                    var error = $root.protocol.Permission.verify(message.actives[i]);
                    if (error)
                        return "actives." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AccountPermissionUpdateContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountPermissionUpdateContract} AccountPermissionUpdateContract
         */
        AccountPermissionUpdateContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountPermissionUpdateContract)
                return object;
            var message = new $root.protocol.AccountPermissionUpdateContract();
            if (object.owner_address != null)
                if (typeof object.owner_address === "string")
                    $util.base64.decode(object.owner_address, message.owner_address = $util.newBuffer($util.base64.length(object.owner_address)), 0);
                else if (object.owner_address.length)
                    message.owner_address = object.owner_address;
            if (object.owner != null) {
                if (typeof object.owner !== "object")
                    throw TypeError(".protocol.AccountPermissionUpdateContract.owner: object expected");
                message.owner = $root.protocol.Permission.fromObject(object.owner);
            }
            if (object.witness != null) {
                if (typeof object.witness !== "object")
                    throw TypeError(".protocol.AccountPermissionUpdateContract.witness: object expected");
                message.witness = $root.protocol.Permission.fromObject(object.witness);
            }
            if (object.actives) {
                if (!Array.isArray(object.actives))
                    throw TypeError(".protocol.AccountPermissionUpdateContract.actives: array expected");
                message.actives = [];
                for (var i = 0; i < object.actives.length; ++i) {
                    if (typeof object.actives[i] !== "object")
                        throw TypeError(".protocol.AccountPermissionUpdateContract.actives: object expected");
                    message.actives[i] = $root.protocol.Permission.fromObject(object.actives[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountPermissionUpdateContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountPermissionUpdateContract
         * @static
         * @param {protocol.AccountPermissionUpdateContract} message AccountPermissionUpdateContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountPermissionUpdateContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.actives = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.owner_address = "";
                else {
                    object.owner_address = [];
                    if (options.bytes !== Array)
                        object.owner_address = $util.newBuffer(object.owner_address);
                }
                object.owner = null;
                object.witness = null;
            }
            if (message.owner_address != null && message.hasOwnProperty("owner_address"))
                object.owner_address = options.bytes === String ? $util.base64.encode(message.owner_address, 0, message.owner_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner_address) : message.owner_address;
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = $root.protocol.Permission.toObject(message.owner, options);
            if (message.witness != null && message.hasOwnProperty("witness"))
                object.witness = $root.protocol.Permission.toObject(message.witness, options);
            if (message.actives && message.actives.length) {
                object.actives = [];
                for (var j = 0; j < message.actives.length; ++j)
                    object.actives[j] = $root.protocol.Permission.toObject(message.actives[j], options);
            }
            return object;
        };

        /**
         * Converts this AccountPermissionUpdateContract to JSON.
         * @function toJSON
         * @memberof protocol.AccountPermissionUpdateContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountPermissionUpdateContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountPermissionUpdateContract;
    })();

    /**
     * AccountType enum.
     * @name protocol.AccountType
     * @enum {string}
     * @property {number} Normal=0 Normal value
     * @property {number} AssetIssue=1 AssetIssue value
     * @property {number} Contract=2 Contract value
     */
    protocol.AccountType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Normal"] = 0;
        values[valuesById[1] = "AssetIssue"] = 1;
        values[valuesById[2] = "Contract"] = 2;
        return values;
    })();

    protocol.AccountId = (function() {

        /**
         * Properties of an AccountId.
         * @memberof protocol
         * @interface IAccountId
         * @property {Uint8Array|null} [name] AccountId name
         * @property {Uint8Array|null} [address] AccountId address
         */

        /**
         * Constructs a new AccountId.
         * @memberof protocol
         * @classdesc Represents an AccountId.
         * @implements IAccountId
         * @constructor
         * @param {protocol.IAccountId=} [properties] Properties to set
         */
        function AccountId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountId name.
         * @member {Uint8Array} name
         * @memberof protocol.AccountId
         * @instance
         */
        AccountId.prototype.name = $util.newBuffer([]);

        /**
         * AccountId address.
         * @member {Uint8Array} address
         * @memberof protocol.AccountId
         * @instance
         */
        AccountId.prototype.address = $util.newBuffer([]);

        /**
         * Creates a new AccountId instance using the specified properties.
         * @function create
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.IAccountId=} [properties] Properties to set
         * @returns {protocol.AccountId} AccountId instance
         */
        AccountId.create = function create(properties) {
            return new AccountId(properties);
        };

        /**
         * Encodes the specified AccountId message. Does not implicitly {@link protocol.AccountId.verify|verify} messages.
         * @function encode
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.IAccountId} message AccountId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.name);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);
            return writer;
        };

        /**
         * Encodes the specified AccountId message, length delimited. Does not implicitly {@link protocol.AccountId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.IAccountId} message AccountId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountId message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.AccountId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.AccountId} AccountId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.AccountId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.bytes();
                    break;
                case 2:
                    message.address = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.AccountId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.AccountId} AccountId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountId message.
         * @function verify
         * @memberof protocol.AccountId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!(message.name && typeof message.name.length === "number" || $util.isString(message.name)))
                    return "name: buffer expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            return null;
        };

        /**
         * Creates an AccountId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.AccountId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.AccountId} AccountId
         */
        AccountId.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.AccountId)
                return object;
            var message = new $root.protocol.AccountId();
            if (object.name != null)
                if (typeof object.name === "string")
                    $util.base64.decode(object.name, message.name = $util.newBuffer($util.base64.length(object.name)), 0);
                else if (object.name.length)
                    message.name = object.name;
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            return message;
        };

        /**
         * Creates a plain object from an AccountId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.AccountId
         * @static
         * @param {protocol.AccountId} message AccountId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.name = "";
                else {
                    object.name = [];
                    if (options.bytes !== Array)
                        object.name = $util.newBuffer(object.name);
                }
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = options.bytes === String ? $util.base64.encode(message.name, 0, message.name.length) : options.bytes === Array ? Array.prototype.slice.call(message.name) : message.name;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            return object;
        };

        /**
         * Converts this AccountId to JSON.
         * @function toJSON
         * @memberof protocol.AccountId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AccountId;
    })();

    protocol.Vote = (function() {

        /**
         * Properties of a Vote.
         * @memberof protocol
         * @interface IVote
         * @property {Uint8Array|null} [vote_address] Vote vote_address
         * @property {number|Long|null} [vote_count] Vote vote_count
         */

        /**
         * Constructs a new Vote.
         * @memberof protocol
         * @classdesc Represents a Vote.
         * @implements IVote
         * @constructor
         * @param {protocol.IVote=} [properties] Properties to set
         */
        function Vote(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Vote vote_address.
         * @member {Uint8Array} vote_address
         * @memberof protocol.Vote
         * @instance
         */
        Vote.prototype.vote_address = $util.newBuffer([]);

        /**
         * Vote vote_count.
         * @member {number|Long} vote_count
         * @memberof protocol.Vote
         * @instance
         */
        Vote.prototype.vote_count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Vote instance using the specified properties.
         * @function create
         * @memberof protocol.Vote
         * @static
         * @param {protocol.IVote=} [properties] Properties to set
         * @returns {protocol.Vote} Vote instance
         */
        Vote.create = function create(properties) {
            return new Vote(properties);
        };

        /**
         * Encodes the specified Vote message. Does not implicitly {@link protocol.Vote.verify|verify} messages.
         * @function encode
         * @memberof protocol.Vote
         * @static
         * @param {protocol.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vote_address != null && message.hasOwnProperty("vote_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.vote_address);
            if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.vote_count);
            return writer;
        };

        /**
         * Encodes the specified Vote message, length delimited. Does not implicitly {@link protocol.Vote.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Vote
         * @static
         * @param {protocol.IVote} message Vote message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Vote.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Vote message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Vote();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.vote_address = reader.bytes();
                    break;
                case 2:
                    message.vote_count = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Vote message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Vote
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Vote} Vote
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Vote.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Vote message.
         * @function verify
         * @memberof protocol.Vote
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Vote.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vote_address != null && message.hasOwnProperty("vote_address"))
                if (!(message.vote_address && typeof message.vote_address.length === "number" || $util.isString(message.vote_address)))
                    return "vote_address: buffer expected";
            if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                if (!$util.isInteger(message.vote_count) && !(message.vote_count && $util.isInteger(message.vote_count.low) && $util.isInteger(message.vote_count.high)))
                    return "vote_count: integer|Long expected";
            return null;
        };

        /**
         * Creates a Vote message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Vote
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Vote} Vote
         */
        Vote.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Vote)
                return object;
            var message = new $root.protocol.Vote();
            if (object.vote_address != null)
                if (typeof object.vote_address === "string")
                    $util.base64.decode(object.vote_address, message.vote_address = $util.newBuffer($util.base64.length(object.vote_address)), 0);
                else if (object.vote_address.length)
                    message.vote_address = object.vote_address;
            if (object.vote_count != null)
                if ($util.Long)
                    (message.vote_count = $util.Long.fromValue(object.vote_count)).unsigned = false;
                else if (typeof object.vote_count === "string")
                    message.vote_count = parseInt(object.vote_count, 10);
                else if (typeof object.vote_count === "number")
                    message.vote_count = object.vote_count;
                else if (typeof object.vote_count === "object")
                    message.vote_count = new $util.LongBits(object.vote_count.low >>> 0, object.vote_count.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Vote message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Vote
         * @static
         * @param {protocol.Vote} message Vote
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Vote.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.vote_address = "";
                else {
                    object.vote_address = [];
                    if (options.bytes !== Array)
                        object.vote_address = $util.newBuffer(object.vote_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vote_count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vote_count = options.longs === String ? "0" : 0;
            }
            if (message.vote_address != null && message.hasOwnProperty("vote_address"))
                object.vote_address = options.bytes === String ? $util.base64.encode(message.vote_address, 0, message.vote_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.vote_address) : message.vote_address;
            if (message.vote_count != null && message.hasOwnProperty("vote_count"))
                if (typeof message.vote_count === "number")
                    object.vote_count = options.longs === String ? String(message.vote_count) : message.vote_count;
                else
                    object.vote_count = options.longs === String ? $util.Long.prototype.toString.call(message.vote_count) : options.longs === Number ? new $util.LongBits(message.vote_count.low >>> 0, message.vote_count.high >>> 0).toNumber() : message.vote_count;
            return object;
        };

        /**
         * Converts this Vote to JSON.
         * @function toJSON
         * @memberof protocol.Vote
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Vote.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Vote;
    })();

    protocol.Proposal = (function() {

        /**
         * Properties of a Proposal.
         * @memberof protocol
         * @interface IProposal
         * @property {number|Long|null} [proposal_id] Proposal proposal_id
         * @property {Uint8Array|null} [proposer_address] Proposal proposer_address
         * @property {Object.<string,number|Long>|null} [parameters] Proposal parameters
         * @property {number|Long|null} [expiration_time] Proposal expiration_time
         * @property {number|Long|null} [create_time] Proposal create_time
         * @property {Array.<Uint8Array>|null} [approvals] Proposal approvals
         * @property {protocol.Proposal.State|null} [state] Proposal state
         */

        /**
         * Constructs a new Proposal.
         * @memberof protocol
         * @classdesc Represents a Proposal.
         * @implements IProposal
         * @constructor
         * @param {protocol.IProposal=} [properties] Properties to set
         */
        function Proposal(properties) {
            this.parameters = {};
            this.approvals = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Proposal proposal_id.
         * @member {number|Long} proposal_id
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.proposal_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proposal proposer_address.
         * @member {Uint8Array} proposer_address
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.proposer_address = $util.newBuffer([]);

        /**
         * Proposal parameters.
         * @member {Object.<string,number|Long>} parameters
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.parameters = $util.emptyObject;

        /**
         * Proposal expiration_time.
         * @member {number|Long} expiration_time
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.expiration_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proposal create_time.
         * @member {number|Long} create_time
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Proposal approvals.
         * @member {Array.<Uint8Array>} approvals
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.approvals = $util.emptyArray;

        /**
         * Proposal state.
         * @member {protocol.Proposal.State} state
         * @memberof protocol.Proposal
         * @instance
         */
        Proposal.prototype.state = 0;

        /**
         * Creates a new Proposal instance using the specified properties.
         * @function create
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.IProposal=} [properties] Properties to set
         * @returns {protocol.Proposal} Proposal instance
         */
        Proposal.create = function create(properties) {
            return new Proposal(properties);
        };

        /**
         * Encodes the specified Proposal message. Does not implicitly {@link protocol.Proposal.verify|verify} messages.
         * @function encode
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.proposal_id);
            if (message.proposer_address != null && message.hasOwnProperty("proposer_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.proposer_address);
            if (message.parameters != null && message.hasOwnProperty("parameters"))
                for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.parameters[keys[i]]).ldelim();
            if (message.expiration_time != null && message.hasOwnProperty("expiration_time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.expiration_time);
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.create_time);
            if (message.approvals != null && message.approvals.length)
                for (var i = 0; i < message.approvals.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.approvals[i]);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified Proposal message, length delimited. Does not implicitly {@link protocol.Proposal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.IProposal} message Proposal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Proposal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Proposal(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.proposal_id = reader.int64();
                    break;
                case 2:
                    message.proposer_address = reader.bytes();
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.parameters === $util.emptyObject)
                        message.parameters = {};
                    key = reader.int64();
                    reader.pos++;
                    message.parameters[typeof key === "object" ? $util.longToHash(key) : key] = reader.int64();
                    break;
                case 4:
                    message.expiration_time = reader.int64();
                    break;
                case 5:
                    message.create_time = reader.int64();
                    break;
                case 6:
                    if (!(message.approvals && message.approvals.length))
                        message.approvals = [];
                    message.approvals.push(reader.bytes());
                    break;
                case 7:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Proposal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Proposal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Proposal} Proposal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Proposal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Proposal message.
         * @function verify
         * @memberof protocol.Proposal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Proposal.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                if (!$util.isInteger(message.proposal_id) && !(message.proposal_id && $util.isInteger(message.proposal_id.low) && $util.isInteger(message.proposal_id.high)))
                    return "proposal_id: integer|Long expected";
            if (message.proposer_address != null && message.hasOwnProperty("proposer_address"))
                if (!(message.proposer_address && typeof message.proposer_address.length === "number" || $util.isString(message.proposer_address)))
                    return "proposer_address: buffer expected";
            if (message.parameters != null && message.hasOwnProperty("parameters")) {
                if (!$util.isObject(message.parameters))
                    return "parameters: object expected";
                var key = Object.keys(message.parameters);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key64Re.test(key[i]))
                        return "parameters: integer|Long key{k:int64} expected";
                    if (!$util.isInteger(message.parameters[key[i]]) && !(message.parameters[key[i]] && $util.isInteger(message.parameters[key[i]].low) && $util.isInteger(message.parameters[key[i]].high)))
                        return "parameters: integer|Long{k:int64} expected";
                }
            }
            if (message.expiration_time != null && message.hasOwnProperty("expiration_time"))
                if (!$util.isInteger(message.expiration_time) && !(message.expiration_time && $util.isInteger(message.expiration_time.low) && $util.isInteger(message.expiration_time.high)))
                    return "expiration_time: integer|Long expected";
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                if (!$util.isInteger(message.create_time) && !(message.create_time && $util.isInteger(message.create_time.low) && $util.isInteger(message.create_time.high)))
                    return "create_time: integer|Long expected";
            if (message.approvals != null && message.hasOwnProperty("approvals")) {
                if (!Array.isArray(message.approvals))
                    return "approvals: array expected";
                for (var i = 0; i < message.approvals.length; ++i)
                    if (!(message.approvals[i] && typeof message.approvals[i].length === "number" || $util.isString(message.approvals[i])))
                        return "approvals: buffer[] expected";
            }
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a Proposal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Proposal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Proposal} Proposal
         */
        Proposal.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Proposal)
                return object;
            var message = new $root.protocol.Proposal();
            if (object.proposal_id != null)
                if ($util.Long)
                    (message.proposal_id = $util.Long.fromValue(object.proposal_id)).unsigned = false;
                else if (typeof object.proposal_id === "string")
                    message.proposal_id = parseInt(object.proposal_id, 10);
                else if (typeof object.proposal_id === "number")
                    message.proposal_id = object.proposal_id;
                else if (typeof object.proposal_id === "object")
                    message.proposal_id = new $util.LongBits(object.proposal_id.low >>> 0, object.proposal_id.high >>> 0).toNumber();
            if (object.proposer_address != null)
                if (typeof object.proposer_address === "string")
                    $util.base64.decode(object.proposer_address, message.proposer_address = $util.newBuffer($util.base64.length(object.proposer_address)), 0);
                else if (object.proposer_address.length)
                    message.proposer_address = object.proposer_address;
            if (object.parameters) {
                if (typeof object.parameters !== "object")
                    throw TypeError(".protocol.Proposal.parameters: object expected");
                message.parameters = {};
                for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.parameters[keys[i]] = $util.Long.fromValue(object.parameters[keys[i]])).unsigned = false;
                    else if (typeof object.parameters[keys[i]] === "string")
                        message.parameters[keys[i]] = parseInt(object.parameters[keys[i]], 10);
                    else if (typeof object.parameters[keys[i]] === "number")
                        message.parameters[keys[i]] = object.parameters[keys[i]];
                    else if (typeof object.parameters[keys[i]] === "object")
                        message.parameters[keys[i]] = new $util.LongBits(object.parameters[keys[i]].low >>> 0, object.parameters[keys[i]].high >>> 0).toNumber();
            }
            if (object.expiration_time != null)
                if ($util.Long)
                    (message.expiration_time = $util.Long.fromValue(object.expiration_time)).unsigned = false;
                else if (typeof object.expiration_time === "string")
                    message.expiration_time = parseInt(object.expiration_time, 10);
                else if (typeof object.expiration_time === "number")
                    message.expiration_time = object.expiration_time;
                else if (typeof object.expiration_time === "object")
                    message.expiration_time = new $util.LongBits(object.expiration_time.low >>> 0, object.expiration_time.high >>> 0).toNumber();
            if (object.create_time != null)
                if ($util.Long)
                    (message.create_time = $util.Long.fromValue(object.create_time)).unsigned = false;
                else if (typeof object.create_time === "string")
                    message.create_time = parseInt(object.create_time, 10);
                else if (typeof object.create_time === "number")
                    message.create_time = object.create_time;
                else if (typeof object.create_time === "object")
                    message.create_time = new $util.LongBits(object.create_time.low >>> 0, object.create_time.high >>> 0).toNumber();
            if (object.approvals) {
                if (!Array.isArray(object.approvals))
                    throw TypeError(".protocol.Proposal.approvals: array expected");
                message.approvals = [];
                for (var i = 0; i < object.approvals.length; ++i)
                    if (typeof object.approvals[i] === "string")
                        $util.base64.decode(object.approvals[i], message.approvals[i] = $util.newBuffer($util.base64.length(object.approvals[i])), 0);
                    else if (object.approvals[i].length)
                        message.approvals[i] = object.approvals[i];
            }
            switch (object.state) {
            case "PENDING":
            case 0:
                message.state = 0;
                break;
            case "DISAPPROVED":
            case 1:
                message.state = 1;
                break;
            case "APPROVED":
            case 2:
                message.state = 2;
                break;
            case "CANCELED":
            case 3:
                message.state = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Proposal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Proposal
         * @static
         * @param {protocol.Proposal} message Proposal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Proposal.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.approvals = [];
            if (options.objects || options.defaults)
                object.parameters = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.proposal_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.proposal_id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.proposer_address = "";
                else {
                    object.proposer_address = [];
                    if (options.bytes !== Array)
                        object.proposer_address = $util.newBuffer(object.proposer_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expiration_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiration_time = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.create_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.create_time = options.longs === String ? "0" : 0;
                object.state = options.enums === String ? "PENDING" : 0;
            }
            if (message.proposal_id != null && message.hasOwnProperty("proposal_id"))
                if (typeof message.proposal_id === "number")
                    object.proposal_id = options.longs === String ? String(message.proposal_id) : message.proposal_id;
                else
                    object.proposal_id = options.longs === String ? $util.Long.prototype.toString.call(message.proposal_id) : options.longs === Number ? new $util.LongBits(message.proposal_id.low >>> 0, message.proposal_id.high >>> 0).toNumber() : message.proposal_id;
            if (message.proposer_address != null && message.hasOwnProperty("proposer_address"))
                object.proposer_address = options.bytes === String ? $util.base64.encode(message.proposer_address, 0, message.proposer_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.proposer_address) : message.proposer_address;
            var keys2;
            if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                object.parameters = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.parameters[keys2[j]] === "number")
                        object.parameters[keys2[j]] = options.longs === String ? String(message.parameters[keys2[j]]) : message.parameters[keys2[j]];
                    else
                        object.parameters[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.parameters[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.parameters[keys2[j]].low >>> 0, message.parameters[keys2[j]].high >>> 0).toNumber() : message.parameters[keys2[j]];
            }
            if (message.expiration_time != null && message.hasOwnProperty("expiration_time"))
                if (typeof message.expiration_time === "number")
                    object.expiration_time = options.longs === String ? String(message.expiration_time) : message.expiration_time;
                else
                    object.expiration_time = options.longs === String ? $util.Long.prototype.toString.call(message.expiration_time) : options.longs === Number ? new $util.LongBits(message.expiration_time.low >>> 0, message.expiration_time.high >>> 0).toNumber() : message.expiration_time;
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                if (typeof message.create_time === "number")
                    object.create_time = options.longs === String ? String(message.create_time) : message.create_time;
                else
                    object.create_time = options.longs === String ? $util.Long.prototype.toString.call(message.create_time) : options.longs === Number ? new $util.LongBits(message.create_time.low >>> 0, message.create_time.high >>> 0).toNumber() : message.create_time;
            if (message.approvals && message.approvals.length) {
                object.approvals = [];
                for (var j = 0; j < message.approvals.length; ++j)
                    object.approvals[j] = options.bytes === String ? $util.base64.encode(message.approvals[j], 0, message.approvals[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.approvals[j]) : message.approvals[j];
            }
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.protocol.Proposal.State[message.state] : message.state;
            return object;
        };

        /**
         * Converts this Proposal to JSON.
         * @function toJSON
         * @memberof protocol.Proposal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Proposal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * State enum.
         * @name protocol.Proposal.State
         * @enum {string}
         * @property {number} PENDING=0 PENDING value
         * @property {number} DISAPPROVED=1 DISAPPROVED value
         * @property {number} APPROVED=2 APPROVED value
         * @property {number} CANCELED=3 CANCELED value
         */
        Proposal.State = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "PENDING"] = 0;
            values[valuesById[1] = "DISAPPROVED"] = 1;
            values[valuesById[2] = "APPROVED"] = 2;
            values[valuesById[3] = "CANCELED"] = 3;
            return values;
        })();

        return Proposal;
    })();

    protocol.Exchange = (function() {

        /**
         * Properties of an Exchange.
         * @memberof protocol
         * @interface IExchange
         * @property {number|Long|null} [exchange_id] Exchange exchange_id
         * @property {Uint8Array|null} [creator_address] Exchange creator_address
         * @property {number|Long|null} [create_time] Exchange create_time
         * @property {Uint8Array|null} [first_token_id] Exchange first_token_id
         * @property {number|Long|null} [first_token_balance] Exchange first_token_balance
         * @property {Uint8Array|null} [second_token_id] Exchange second_token_id
         * @property {number|Long|null} [second_token_balance] Exchange second_token_balance
         */

        /**
         * Constructs a new Exchange.
         * @memberof protocol
         * @classdesc Represents an Exchange.
         * @implements IExchange
         * @constructor
         * @param {protocol.IExchange=} [properties] Properties to set
         */
        function Exchange(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Exchange exchange_id.
         * @member {number|Long} exchange_id
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.exchange_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exchange creator_address.
         * @member {Uint8Array} creator_address
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.creator_address = $util.newBuffer([]);

        /**
         * Exchange create_time.
         * @member {number|Long} create_time
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exchange first_token_id.
         * @member {Uint8Array} first_token_id
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.first_token_id = $util.newBuffer([]);

        /**
         * Exchange first_token_balance.
         * @member {number|Long} first_token_balance
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.first_token_balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Exchange second_token_id.
         * @member {Uint8Array} second_token_id
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.second_token_id = $util.newBuffer([]);

        /**
         * Exchange second_token_balance.
         * @member {number|Long} second_token_balance
         * @memberof protocol.Exchange
         * @instance
         */
        Exchange.prototype.second_token_balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Exchange instance using the specified properties.
         * @function create
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.IExchange=} [properties] Properties to set
         * @returns {protocol.Exchange} Exchange instance
         */
        Exchange.create = function create(properties) {
            return new Exchange(properties);
        };

        /**
         * Encodes the specified Exchange message. Does not implicitly {@link protocol.Exchange.verify|verify} messages.
         * @function encode
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.IExchange} message Exchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Exchange.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.exchange_id);
            if (message.creator_address != null && message.hasOwnProperty("creator_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.creator_address);
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.create_time);
            if (message.first_token_id != null && message.hasOwnProperty("first_token_id"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.first_token_id);
            if (message.first_token_balance != null && message.hasOwnProperty("first_token_balance"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.first_token_balance);
            if (message.second_token_id != null && message.hasOwnProperty("second_token_id"))
                writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.second_token_id);
            if (message.second_token_balance != null && message.hasOwnProperty("second_token_balance"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.second_token_balance);
            return writer;
        };

        /**
         * Encodes the specified Exchange message, length delimited. Does not implicitly {@link protocol.Exchange.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.IExchange} message Exchange message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Exchange.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Exchange message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Exchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Exchange} Exchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Exchange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Exchange();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.exchange_id = reader.int64();
                    break;
                case 2:
                    message.creator_address = reader.bytes();
                    break;
                case 3:
                    message.create_time = reader.int64();
                    break;
                case 6:
                    message.first_token_id = reader.bytes();
                    break;
                case 7:
                    message.first_token_balance = reader.int64();
                    break;
                case 8:
                    message.second_token_id = reader.bytes();
                    break;
                case 9:
                    message.second_token_balance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Exchange message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Exchange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Exchange} Exchange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Exchange.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Exchange message.
         * @function verify
         * @memberof protocol.Exchange
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Exchange.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (!$util.isInteger(message.exchange_id) && !(message.exchange_id && $util.isInteger(message.exchange_id.low) && $util.isInteger(message.exchange_id.high)))
                    return "exchange_id: integer|Long expected";
            if (message.creator_address != null && message.hasOwnProperty("creator_address"))
                if (!(message.creator_address && typeof message.creator_address.length === "number" || $util.isString(message.creator_address)))
                    return "creator_address: buffer expected";
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                if (!$util.isInteger(message.create_time) && !(message.create_time && $util.isInteger(message.create_time.low) && $util.isInteger(message.create_time.high)))
                    return "create_time: integer|Long expected";
            if (message.first_token_id != null && message.hasOwnProperty("first_token_id"))
                if (!(message.first_token_id && typeof message.first_token_id.length === "number" || $util.isString(message.first_token_id)))
                    return "first_token_id: buffer expected";
            if (message.first_token_balance != null && message.hasOwnProperty("first_token_balance"))
                if (!$util.isInteger(message.first_token_balance) && !(message.first_token_balance && $util.isInteger(message.first_token_balance.low) && $util.isInteger(message.first_token_balance.high)))
                    return "first_token_balance: integer|Long expected";
            if (message.second_token_id != null && message.hasOwnProperty("second_token_id"))
                if (!(message.second_token_id && typeof message.second_token_id.length === "number" || $util.isString(message.second_token_id)))
                    return "second_token_id: buffer expected";
            if (message.second_token_balance != null && message.hasOwnProperty("second_token_balance"))
                if (!$util.isInteger(message.second_token_balance) && !(message.second_token_balance && $util.isInteger(message.second_token_balance.low) && $util.isInteger(message.second_token_balance.high)))
                    return "second_token_balance: integer|Long expected";
            return null;
        };

        /**
         * Creates an Exchange message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Exchange
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Exchange} Exchange
         */
        Exchange.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Exchange)
                return object;
            var message = new $root.protocol.Exchange();
            if (object.exchange_id != null)
                if ($util.Long)
                    (message.exchange_id = $util.Long.fromValue(object.exchange_id)).unsigned = false;
                else if (typeof object.exchange_id === "string")
                    message.exchange_id = parseInt(object.exchange_id, 10);
                else if (typeof object.exchange_id === "number")
                    message.exchange_id = object.exchange_id;
                else if (typeof object.exchange_id === "object")
                    message.exchange_id = new $util.LongBits(object.exchange_id.low >>> 0, object.exchange_id.high >>> 0).toNumber();
            if (object.creator_address != null)
                if (typeof object.creator_address === "string")
                    $util.base64.decode(object.creator_address, message.creator_address = $util.newBuffer($util.base64.length(object.creator_address)), 0);
                else if (object.creator_address.length)
                    message.creator_address = object.creator_address;
            if (object.create_time != null)
                if ($util.Long)
                    (message.create_time = $util.Long.fromValue(object.create_time)).unsigned = false;
                else if (typeof object.create_time === "string")
                    message.create_time = parseInt(object.create_time, 10);
                else if (typeof object.create_time === "number")
                    message.create_time = object.create_time;
                else if (typeof object.create_time === "object")
                    message.create_time = new $util.LongBits(object.create_time.low >>> 0, object.create_time.high >>> 0).toNumber();
            if (object.first_token_id != null)
                if (typeof object.first_token_id === "string")
                    $util.base64.decode(object.first_token_id, message.first_token_id = $util.newBuffer($util.base64.length(object.first_token_id)), 0);
                else if (object.first_token_id.length)
                    message.first_token_id = object.first_token_id;
            if (object.first_token_balance != null)
                if ($util.Long)
                    (message.first_token_balance = $util.Long.fromValue(object.first_token_balance)).unsigned = false;
                else if (typeof object.first_token_balance === "string")
                    message.first_token_balance = parseInt(object.first_token_balance, 10);
                else if (typeof object.first_token_balance === "number")
                    message.first_token_balance = object.first_token_balance;
                else if (typeof object.first_token_balance === "object")
                    message.first_token_balance = new $util.LongBits(object.first_token_balance.low >>> 0, object.first_token_balance.high >>> 0).toNumber();
            if (object.second_token_id != null)
                if (typeof object.second_token_id === "string")
                    $util.base64.decode(object.second_token_id, message.second_token_id = $util.newBuffer($util.base64.length(object.second_token_id)), 0);
                else if (object.second_token_id.length)
                    message.second_token_id = object.second_token_id;
            if (object.second_token_balance != null)
                if ($util.Long)
                    (message.second_token_balance = $util.Long.fromValue(object.second_token_balance)).unsigned = false;
                else if (typeof object.second_token_balance === "string")
                    message.second_token_balance = parseInt(object.second_token_balance, 10);
                else if (typeof object.second_token_balance === "number")
                    message.second_token_balance = object.second_token_balance;
                else if (typeof object.second_token_balance === "object")
                    message.second_token_balance = new $util.LongBits(object.second_token_balance.low >>> 0, object.second_token_balance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Exchange message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Exchange
         * @static
         * @param {protocol.Exchange} message Exchange
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Exchange.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_id = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.creator_address = "";
                else {
                    object.creator_address = [];
                    if (options.bytes !== Array)
                        object.creator_address = $util.newBuffer(object.creator_address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.create_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.create_time = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.first_token_id = "";
                else {
                    object.first_token_id = [];
                    if (options.bytes !== Array)
                        object.first_token_id = $util.newBuffer(object.first_token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.first_token_balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.first_token_balance = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.second_token_id = "";
                else {
                    object.second_token_id = [];
                    if (options.bytes !== Array)
                        object.second_token_id = $util.newBuffer(object.second_token_id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.second_token_balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.second_token_balance = options.longs === String ? "0" : 0;
            }
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (typeof message.exchange_id === "number")
                    object.exchange_id = options.longs === String ? String(message.exchange_id) : message.exchange_id;
                else
                    object.exchange_id = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_id) : options.longs === Number ? new $util.LongBits(message.exchange_id.low >>> 0, message.exchange_id.high >>> 0).toNumber() : message.exchange_id;
            if (message.creator_address != null && message.hasOwnProperty("creator_address"))
                object.creator_address = options.bytes === String ? $util.base64.encode(message.creator_address, 0, message.creator_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.creator_address) : message.creator_address;
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                if (typeof message.create_time === "number")
                    object.create_time = options.longs === String ? String(message.create_time) : message.create_time;
                else
                    object.create_time = options.longs === String ? $util.Long.prototype.toString.call(message.create_time) : options.longs === Number ? new $util.LongBits(message.create_time.low >>> 0, message.create_time.high >>> 0).toNumber() : message.create_time;
            if (message.first_token_id != null && message.hasOwnProperty("first_token_id"))
                object.first_token_id = options.bytes === String ? $util.base64.encode(message.first_token_id, 0, message.first_token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.first_token_id) : message.first_token_id;
            if (message.first_token_balance != null && message.hasOwnProperty("first_token_balance"))
                if (typeof message.first_token_balance === "number")
                    object.first_token_balance = options.longs === String ? String(message.first_token_balance) : message.first_token_balance;
                else
                    object.first_token_balance = options.longs === String ? $util.Long.prototype.toString.call(message.first_token_balance) : options.longs === Number ? new $util.LongBits(message.first_token_balance.low >>> 0, message.first_token_balance.high >>> 0).toNumber() : message.first_token_balance;
            if (message.second_token_id != null && message.hasOwnProperty("second_token_id"))
                object.second_token_id = options.bytes === String ? $util.base64.encode(message.second_token_id, 0, message.second_token_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.second_token_id) : message.second_token_id;
            if (message.second_token_balance != null && message.hasOwnProperty("second_token_balance"))
                if (typeof message.second_token_balance === "number")
                    object.second_token_balance = options.longs === String ? String(message.second_token_balance) : message.second_token_balance;
                else
                    object.second_token_balance = options.longs === String ? $util.Long.prototype.toString.call(message.second_token_balance) : options.longs === Number ? new $util.LongBits(message.second_token_balance.low >>> 0, message.second_token_balance.high >>> 0).toNumber() : message.second_token_balance;
            return object;
        };

        /**
         * Converts this Exchange to JSON.
         * @function toJSON
         * @memberof protocol.Exchange
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Exchange.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Exchange;
    })();

    protocol.ChainParameters = (function() {

        /**
         * Properties of a ChainParameters.
         * @memberof protocol
         * @interface IChainParameters
         * @property {Array.<protocol.ChainParameters.IChainParameter>|null} [chainParameter] ChainParameters chainParameter
         */

        /**
         * Constructs a new ChainParameters.
         * @memberof protocol
         * @classdesc Represents a ChainParameters.
         * @implements IChainParameters
         * @constructor
         * @param {protocol.IChainParameters=} [properties] Properties to set
         */
        function ChainParameters(properties) {
            this.chainParameter = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChainParameters chainParameter.
         * @member {Array.<protocol.ChainParameters.IChainParameter>} chainParameter
         * @memberof protocol.ChainParameters
         * @instance
         */
        ChainParameters.prototype.chainParameter = $util.emptyArray;

        /**
         * Creates a new ChainParameters instance using the specified properties.
         * @function create
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.IChainParameters=} [properties] Properties to set
         * @returns {protocol.ChainParameters} ChainParameters instance
         */
        ChainParameters.create = function create(properties) {
            return new ChainParameters(properties);
        };

        /**
         * Encodes the specified ChainParameters message. Does not implicitly {@link protocol.ChainParameters.verify|verify} messages.
         * @function encode
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.IChainParameters} message ChainParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainParameters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chainParameter != null && message.chainParameter.length)
                for (var i = 0; i < message.chainParameter.length; ++i)
                    $root.protocol.ChainParameters.ChainParameter.encode(message.chainParameter[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChainParameters message, length delimited. Does not implicitly {@link protocol.ChainParameters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.IChainParameters} message ChainParameters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainParameters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChainParameters message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ChainParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ChainParameters} ChainParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainParameters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainParameters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chainParameter && message.chainParameter.length))
                        message.chainParameter = [];
                    message.chainParameter.push($root.protocol.ChainParameters.ChainParameter.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChainParameters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ChainParameters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ChainParameters} ChainParameters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainParameters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChainParameters message.
         * @function verify
         * @memberof protocol.ChainParameters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChainParameters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chainParameter != null && message.hasOwnProperty("chainParameter")) {
                if (!Array.isArray(message.chainParameter))
                    return "chainParameter: array expected";
                for (var i = 0; i < message.chainParameter.length; ++i) {
                    var error = $root.protocol.ChainParameters.ChainParameter.verify(message.chainParameter[i]);
                    if (error)
                        return "chainParameter." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChainParameters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ChainParameters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ChainParameters} ChainParameters
         */
        ChainParameters.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ChainParameters)
                return object;
            var message = new $root.protocol.ChainParameters();
            if (object.chainParameter) {
                if (!Array.isArray(object.chainParameter))
                    throw TypeError(".protocol.ChainParameters.chainParameter: array expected");
                message.chainParameter = [];
                for (var i = 0; i < object.chainParameter.length; ++i) {
                    if (typeof object.chainParameter[i] !== "object")
                        throw TypeError(".protocol.ChainParameters.chainParameter: object expected");
                    message.chainParameter[i] = $root.protocol.ChainParameters.ChainParameter.fromObject(object.chainParameter[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChainParameters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ChainParameters
         * @static
         * @param {protocol.ChainParameters} message ChainParameters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChainParameters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.chainParameter = [];
            if (message.chainParameter && message.chainParameter.length) {
                object.chainParameter = [];
                for (var j = 0; j < message.chainParameter.length; ++j)
                    object.chainParameter[j] = $root.protocol.ChainParameters.ChainParameter.toObject(message.chainParameter[j], options);
            }
            return object;
        };

        /**
         * Converts this ChainParameters to JSON.
         * @function toJSON
         * @memberof protocol.ChainParameters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChainParameters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ChainParameters.ChainParameter = (function() {

            /**
             * Properties of a ChainParameter.
             * @memberof protocol.ChainParameters
             * @interface IChainParameter
             * @property {string|null} [key] ChainParameter key
             * @property {number|Long|null} [value] ChainParameter value
             */

            /**
             * Constructs a new ChainParameter.
             * @memberof protocol.ChainParameters
             * @classdesc Represents a ChainParameter.
             * @implements IChainParameter
             * @constructor
             * @param {protocol.ChainParameters.IChainParameter=} [properties] Properties to set
             */
            function ChainParameter(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChainParameter key.
             * @member {string} key
             * @memberof protocol.ChainParameters.ChainParameter
             * @instance
             */
            ChainParameter.prototype.key = "";

            /**
             * ChainParameter value.
             * @member {number|Long} value
             * @memberof protocol.ChainParameters.ChainParameter
             * @instance
             */
            ChainParameter.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ChainParameter instance using the specified properties.
             * @function create
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.IChainParameter=} [properties] Properties to set
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter instance
             */
            ChainParameter.create = function create(properties) {
                return new ChainParameter(properties);
            };

            /**
             * Encodes the specified ChainParameter message. Does not implicitly {@link protocol.ChainParameters.ChainParameter.verify|verify} messages.
             * @function encode
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.IChainParameter} message ChainParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChainParameter.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.key != null && message.hasOwnProperty("key"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
                return writer;
            };

            /**
             * Encodes the specified ChainParameter message, length delimited. Does not implicitly {@link protocol.ChainParameters.ChainParameter.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.IChainParameter} message ChainParameter message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChainParameter.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChainParameter message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChainParameter.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainParameters.ChainParameter();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.key = reader.string();
                        break;
                    case 2:
                        message.value = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChainParameter message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChainParameter.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChainParameter message.
             * @function verify
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChainParameter.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.key != null && message.hasOwnProperty("key"))
                    if (!$util.isString(message.key))
                        return "key: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a ChainParameter message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.ChainParameters.ChainParameter} ChainParameter
             */
            ChainParameter.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.ChainParameters.ChainParameter)
                    return object;
                var message = new $root.protocol.ChainParameters.ChainParameter();
                if (object.key != null)
                    message.key = String(object.key);
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ChainParameter message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.ChainParameters.ChainParameter
             * @static
             * @param {protocol.ChainParameters.ChainParameter} message ChainParameter
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChainParameter.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.key = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                }
                if (message.key != null && message.hasOwnProperty("key"))
                    object.key = message.key;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this ChainParameter to JSON.
             * @function toJSON
             * @memberof protocol.ChainParameters.ChainParameter
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChainParameter.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChainParameter;
        })();

        return ChainParameters;
    })();

    protocol.Account = (function() {

        /**
         * Properties of an Account.
         * @memberof protocol
         * @interface IAccount
         * @property {Uint8Array|null} [account_name] Account account_name
         * @property {protocol.AccountType|null} [type] Account type
         * @property {Uint8Array|null} [address] Account address
         * @property {number|Long|null} [balance] Account balance
         * @property {Array.<protocol.IVote>|null} [votes] Account votes
         * @property {Object.<string,number|Long>|null} [asset] Account asset
         * @property {Object.<string,number|Long>|null} [assetV2] Account assetV2
         * @property {Array.<protocol.Account.IFrozen>|null} [frozen] Account frozen
         * @property {number|Long|null} [net_usage] Account net_usage
         * @property {number|Long|null} [acquired_delegated_frozen_balance_for_bandwidth] Account acquired_delegated_frozen_balance_for_bandwidth
         * @property {number|Long|null} [delegated_frozen_balance_for_bandwidth] Account delegated_frozen_balance_for_bandwidth
         * @property {number|Long|null} [create_time] Account create_time
         * @property {number|Long|null} [latest_opration_time] Account latest_opration_time
         * @property {number|Long|null} [allowance] Account allowance
         * @property {number|Long|null} [latest_withdraw_time] Account latest_withdraw_time
         * @property {Uint8Array|null} [code] Account code
         * @property {boolean|null} [is_witness] Account is_witness
         * @property {boolean|null} [is_committee] Account is_committee
         * @property {Array.<protocol.Account.IFrozen>|null} [frozen_supply] Account frozen_supply
         * @property {Uint8Array|null} [asset_issued_name] Account asset_issued_name
         * @property {Uint8Array|null} [asset_issued_ID] Account asset_issued_ID
         * @property {Object.<string,number|Long>|null} [latest_asset_operation_time] Account latest_asset_operation_time
         * @property {Object.<string,number|Long>|null} [latest_asset_operation_timeV2] Account latest_asset_operation_timeV2
         * @property {number|Long|null} [free_net_usage] Account free_net_usage
         * @property {Object.<string,number|Long>|null} [free_asset_net_usage] Account free_asset_net_usage
         * @property {Object.<string,number|Long>|null} [free_asset_net_usageV2] Account free_asset_net_usageV2
         * @property {number|Long|null} [latest_consume_time] Account latest_consume_time
         * @property {number|Long|null} [latest_consume_free_time] Account latest_consume_free_time
         * @property {Uint8Array|null} [account_id] Account account_id
         * @property {protocol.Account.IAccountResource|null} [account_resource] Account account_resource
         * @property {Uint8Array|null} [codeHash] Account codeHash
         * @property {protocol.IPermission|null} [owner_permission] Account owner_permission
         * @property {protocol.IPermission|null} [witness_permission] Account witness_permission
         * @property {Array.<protocol.IPermission>|null} [active_permission] Account active_permission
         */

        /**
         * Constructs a new Account.
         * @memberof protocol
         * @classdesc Represents an Account.
         * @implements IAccount
         * @constructor
         * @param {protocol.IAccount=} [properties] Properties to set
         */
        function Account(properties) {
            this.votes = [];
            this.asset = {};
            this.assetV2 = {};
            this.frozen = [];
            this.frozen_supply = [];
            this.latest_asset_operation_time = {};
            this.latest_asset_operation_timeV2 = {};
            this.free_asset_net_usage = {};
            this.free_asset_net_usageV2 = {};
            this.active_permission = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Account account_name.
         * @member {Uint8Array} account_name
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.account_name = $util.newBuffer([]);

        /**
         * Account type.
         * @member {protocol.AccountType} type
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.type = 0;

        /**
         * Account address.
         * @member {Uint8Array} address
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.address = $util.newBuffer([]);

        /**
         * Account balance.
         * @member {number|Long} balance
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account votes.
         * @member {Array.<protocol.IVote>} votes
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.votes = $util.emptyArray;

        /**
         * Account asset.
         * @member {Object.<string,number|Long>} asset
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.asset = $util.emptyObject;

        /**
         * Account assetV2.
         * @member {Object.<string,number|Long>} assetV2
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.assetV2 = $util.emptyObject;

        /**
         * Account frozen.
         * @member {Array.<protocol.Account.IFrozen>} frozen
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.frozen = $util.emptyArray;

        /**
         * Account net_usage.
         * @member {number|Long} net_usage
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.net_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account acquired_delegated_frozen_balance_for_bandwidth.
         * @member {number|Long} acquired_delegated_frozen_balance_for_bandwidth
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.acquired_delegated_frozen_balance_for_bandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account delegated_frozen_balance_for_bandwidth.
         * @member {number|Long} delegated_frozen_balance_for_bandwidth
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.delegated_frozen_balance_for_bandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account create_time.
         * @member {number|Long} create_time
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.create_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account latest_opration_time.
         * @member {number|Long} latest_opration_time
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latest_opration_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account allowance.
         * @member {number|Long} allowance
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.allowance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account latest_withdraw_time.
         * @member {number|Long} latest_withdraw_time
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latest_withdraw_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account code.
         * @member {Uint8Array} code
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.code = $util.newBuffer([]);

        /**
         * Account is_witness.
         * @member {boolean} is_witness
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.is_witness = false;

        /**
         * Account is_committee.
         * @member {boolean} is_committee
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.is_committee = false;

        /**
         * Account frozen_supply.
         * @member {Array.<protocol.Account.IFrozen>} frozen_supply
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.frozen_supply = $util.emptyArray;

        /**
         * Account asset_issued_name.
         * @member {Uint8Array} asset_issued_name
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.asset_issued_name = $util.newBuffer([]);

        /**
         * Account asset_issued_ID.
         * @member {Uint8Array} asset_issued_ID
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.asset_issued_ID = $util.newBuffer([]);

        /**
         * Account latest_asset_operation_time.
         * @member {Object.<string,number|Long>} latest_asset_operation_time
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latest_asset_operation_time = $util.emptyObject;

        /**
         * Account latest_asset_operation_timeV2.
         * @member {Object.<string,number|Long>} latest_asset_operation_timeV2
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latest_asset_operation_timeV2 = $util.emptyObject;

        /**
         * Account free_net_usage.
         * @member {number|Long} free_net_usage
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.free_net_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account free_asset_net_usage.
         * @member {Object.<string,number|Long>} free_asset_net_usage
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.free_asset_net_usage = $util.emptyObject;

        /**
         * Account free_asset_net_usageV2.
         * @member {Object.<string,number|Long>} free_asset_net_usageV2
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.free_asset_net_usageV2 = $util.emptyObject;

        /**
         * Account latest_consume_time.
         * @member {number|Long} latest_consume_time
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latest_consume_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account latest_consume_free_time.
         * @member {number|Long} latest_consume_free_time
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.latest_consume_free_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Account account_id.
         * @member {Uint8Array} account_id
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.account_id = $util.newBuffer([]);

        /**
         * Account account_resource.
         * @member {protocol.Account.IAccountResource|null|undefined} account_resource
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.account_resource = null;

        /**
         * Account codeHash.
         * @member {Uint8Array} codeHash
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.codeHash = $util.newBuffer([]);

        /**
         * Account owner_permission.
         * @member {protocol.IPermission|null|undefined} owner_permission
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.owner_permission = null;

        /**
         * Account witness_permission.
         * @member {protocol.IPermission|null|undefined} witness_permission
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.witness_permission = null;

        /**
         * Account active_permission.
         * @member {Array.<protocol.IPermission>} active_permission
         * @memberof protocol.Account
         * @instance
         */
        Account.prototype.active_permission = $util.emptyArray;

        /**
         * Creates a new Account instance using the specified properties.
         * @function create
         * @memberof protocol.Account
         * @static
         * @param {protocol.IAccount=} [properties] Properties to set
         * @returns {protocol.Account} Account instance
         */
        Account.create = function create(properties) {
            return new Account(properties);
        };

        /**
         * Encodes the specified Account message. Does not implicitly {@link protocol.Account.verify|verify} messages.
         * @function encode
         * @memberof protocol.Account
         * @static
         * @param {protocol.IAccount} message Account message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Account.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account_name != null && message.hasOwnProperty("account_name"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account_name);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.address);
            if (message.balance != null && message.hasOwnProperty("balance"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.balance);
            if (message.votes != null && message.votes.length)
                for (var i = 0; i < message.votes.length; ++i)
                    $root.protocol.Vote.encode(message.votes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.asset != null && message.hasOwnProperty("asset"))
                for (var keys = Object.keys(message.asset), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.asset[keys[i]]).ldelim();
            if (message.frozen != null && message.frozen.length)
                for (var i = 0; i < message.frozen.length; ++i)
                    $root.protocol.Account.Frozen.encode(message.frozen[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.net_usage != null && message.hasOwnProperty("net_usage"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.net_usage);
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.create_time);
            if (message.latest_opration_time != null && message.hasOwnProperty("latest_opration_time"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.latest_opration_time);
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.allowance);
            if (message.latest_withdraw_time != null && message.hasOwnProperty("latest_withdraw_time"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.latest_withdraw_time);
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.code);
            if (message.is_witness != null && message.hasOwnProperty("is_witness"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.is_witness);
            if (message.is_committee != null && message.hasOwnProperty("is_committee"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.is_committee);
            if (message.frozen_supply != null && message.frozen_supply.length)
                for (var i = 0; i < message.frozen_supply.length; ++i)
                    $root.protocol.Account.Frozen.encode(message.frozen_supply[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.asset_issued_name != null && message.hasOwnProperty("asset_issued_name"))
                writer.uint32(/* id 17, wireType 2 =*/138).bytes(message.asset_issued_name);
            if (message.latest_asset_operation_time != null && message.hasOwnProperty("latest_asset_operation_time"))
                for (var keys = Object.keys(message.latest_asset_operation_time), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 18, wireType 2 =*/146).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.latest_asset_operation_time[keys[i]]).ldelim();
            if (message.free_net_usage != null && message.hasOwnProperty("free_net_usage"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.free_net_usage);
            if (message.free_asset_net_usage != null && message.hasOwnProperty("free_asset_net_usage"))
                for (var keys = Object.keys(message.free_asset_net_usage), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 20, wireType 2 =*/162).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.free_asset_net_usage[keys[i]]).ldelim();
            if (message.latest_consume_time != null && message.hasOwnProperty("latest_consume_time"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.latest_consume_time);
            if (message.latest_consume_free_time != null && message.hasOwnProperty("latest_consume_free_time"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.latest_consume_free_time);
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                writer.uint32(/* id 23, wireType 2 =*/186).bytes(message.account_id);
            if (message.account_resource != null && message.hasOwnProperty("account_resource"))
                $root.protocol.Account.AccountResource.encode(message.account_resource, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                writer.uint32(/* id 30, wireType 2 =*/242).bytes(message.codeHash);
            if (message.owner_permission != null && message.hasOwnProperty("owner_permission"))
                $root.protocol.Permission.encode(message.owner_permission, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.witness_permission != null && message.hasOwnProperty("witness_permission"))
                $root.protocol.Permission.encode(message.witness_permission, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.active_permission != null && message.active_permission.length)
                for (var i = 0; i < message.active_permission.length; ++i)
                    $root.protocol.Permission.encode(message.active_permission[i], writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.acquired_delegated_frozen_balance_for_bandwidth != null && message.hasOwnProperty("acquired_delegated_frozen_balance_for_bandwidth"))
                writer.uint32(/* id 41, wireType 0 =*/328).int64(message.acquired_delegated_frozen_balance_for_bandwidth);
            if (message.delegated_frozen_balance_for_bandwidth != null && message.hasOwnProperty("delegated_frozen_balance_for_bandwidth"))
                writer.uint32(/* id 42, wireType 0 =*/336).int64(message.delegated_frozen_balance_for_bandwidth);
            if (message.assetV2 != null && message.hasOwnProperty("assetV2"))
                for (var keys = Object.keys(message.assetV2), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 56, wireType 2 =*/450).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.assetV2[keys[i]]).ldelim();
            if (message.asset_issued_ID != null && message.hasOwnProperty("asset_issued_ID"))
                writer.uint32(/* id 57, wireType 2 =*/458).bytes(message.asset_issued_ID);
            if (message.latest_asset_operation_timeV2 != null && message.hasOwnProperty("latest_asset_operation_timeV2"))
                for (var keys = Object.keys(message.latest_asset_operation_timeV2), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 58, wireType 2 =*/466).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.latest_asset_operation_timeV2[keys[i]]).ldelim();
            if (message.free_asset_net_usageV2 != null && message.hasOwnProperty("free_asset_net_usageV2"))
                for (var keys = Object.keys(message.free_asset_net_usageV2), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 59, wireType 2 =*/474).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.free_asset_net_usageV2[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Account message, length delimited. Does not implicitly {@link protocol.Account.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Account
         * @static
         * @param {protocol.IAccount} message Account message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Account.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Account message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Account
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Account} Account
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Account.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account_name = reader.bytes();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.address = reader.bytes();
                    break;
                case 4:
                    message.balance = reader.int64();
                    break;
                case 5:
                    if (!(message.votes && message.votes.length))
                        message.votes = [];
                    message.votes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                    break;
                case 6:
                    reader.skip().pos++;
                    if (message.asset === $util.emptyObject)
                        message.asset = {};
                    key = reader.string();
                    reader.pos++;
                    message.asset[key] = reader.int64();
                    break;
                case 56:
                    reader.skip().pos++;
                    if (message.assetV2 === $util.emptyObject)
                        message.assetV2 = {};
                    key = reader.string();
                    reader.pos++;
                    message.assetV2[key] = reader.int64();
                    break;
                case 7:
                    if (!(message.frozen && message.frozen.length))
                        message.frozen = [];
                    message.frozen.push($root.protocol.Account.Frozen.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.net_usage = reader.int64();
                    break;
                case 41:
                    message.acquired_delegated_frozen_balance_for_bandwidth = reader.int64();
                    break;
                case 42:
                    message.delegated_frozen_balance_for_bandwidth = reader.int64();
                    break;
                case 9:
                    message.create_time = reader.int64();
                    break;
                case 10:
                    message.latest_opration_time = reader.int64();
                    break;
                case 11:
                    message.allowance = reader.int64();
                    break;
                case 12:
                    message.latest_withdraw_time = reader.int64();
                    break;
                case 13:
                    message.code = reader.bytes();
                    break;
                case 14:
                    message.is_witness = reader.bool();
                    break;
                case 15:
                    message.is_committee = reader.bool();
                    break;
                case 16:
                    if (!(message.frozen_supply && message.frozen_supply.length))
                        message.frozen_supply = [];
                    message.frozen_supply.push($root.protocol.Account.Frozen.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.asset_issued_name = reader.bytes();
                    break;
                case 57:
                    message.asset_issued_ID = reader.bytes();
                    break;
                case 18:
                    reader.skip().pos++;
                    if (message.latest_asset_operation_time === $util.emptyObject)
                        message.latest_asset_operation_time = {};
                    key = reader.string();
                    reader.pos++;
                    message.latest_asset_operation_time[key] = reader.int64();
                    break;
                case 58:
                    reader.skip().pos++;
                    if (message.latest_asset_operation_timeV2 === $util.emptyObject)
                        message.latest_asset_operation_timeV2 = {};
                    key = reader.string();
                    reader.pos++;
                    message.latest_asset_operation_timeV2[key] = reader.int64();
                    break;
                case 19:
                    message.free_net_usage = reader.int64();
                    break;
                case 20:
                    reader.skip().pos++;
                    if (message.free_asset_net_usage === $util.emptyObject)
                        message.free_asset_net_usage = {};
                    key = reader.string();
                    reader.pos++;
                    message.free_asset_net_usage[key] = reader.int64();
                    break;
                case 59:
                    reader.skip().pos++;
                    if (message.free_asset_net_usageV2 === $util.emptyObject)
                        message.free_asset_net_usageV2 = {};
                    key = reader.string();
                    reader.pos++;
                    message.free_asset_net_usageV2[key] = reader.int64();
                    break;
                case 21:
                    message.latest_consume_time = reader.int64();
                    break;
                case 22:
                    message.latest_consume_free_time = reader.int64();
                    break;
                case 23:
                    message.account_id = reader.bytes();
                    break;
                case 26:
                    message.account_resource = $root.protocol.Account.AccountResource.decode(reader, reader.uint32());
                    break;
                case 30:
                    message.codeHash = reader.bytes();
                    break;
                case 31:
                    message.owner_permission = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 32:
                    message.witness_permission = $root.protocol.Permission.decode(reader, reader.uint32());
                    break;
                case 33:
                    if (!(message.active_permission && message.active_permission.length))
                        message.active_permission = [];
                    message.active_permission.push($root.protocol.Permission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Account message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Account
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Account} Account
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Account.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Account message.
         * @function verify
         * @memberof protocol.Account
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Account.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account_name != null && message.hasOwnProperty("account_name"))
                if (!(message.account_name && typeof message.account_name.length === "number" || $util.isString(message.account_name)))
                    return "account_name: buffer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.votes != null && message.hasOwnProperty("votes")) {
                if (!Array.isArray(message.votes))
                    return "votes: array expected";
                for (var i = 0; i < message.votes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.votes[i]);
                    if (error)
                        return "votes." + error;
                }
            }
            if (message.asset != null && message.hasOwnProperty("asset")) {
                if (!$util.isObject(message.asset))
                    return "asset: object expected";
                var key = Object.keys(message.asset);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.asset[key[i]]) && !(message.asset[key[i]] && $util.isInteger(message.asset[key[i]].low) && $util.isInteger(message.asset[key[i]].high)))
                        return "asset: integer|Long{k:string} expected";
            }
            if (message.assetV2 != null && message.hasOwnProperty("assetV2")) {
                if (!$util.isObject(message.assetV2))
                    return "assetV2: object expected";
                var key = Object.keys(message.assetV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.assetV2[key[i]]) && !(message.assetV2[key[i]] && $util.isInteger(message.assetV2[key[i]].low) && $util.isInteger(message.assetV2[key[i]].high)))
                        return "assetV2: integer|Long{k:string} expected";
            }
            if (message.frozen != null && message.hasOwnProperty("frozen")) {
                if (!Array.isArray(message.frozen))
                    return "frozen: array expected";
                for (var i = 0; i < message.frozen.length; ++i) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozen[i]);
                    if (error)
                        return "frozen." + error;
                }
            }
            if (message.net_usage != null && message.hasOwnProperty("net_usage"))
                if (!$util.isInteger(message.net_usage) && !(message.net_usage && $util.isInteger(message.net_usage.low) && $util.isInteger(message.net_usage.high)))
                    return "net_usage: integer|Long expected";
            if (message.acquired_delegated_frozen_balance_for_bandwidth != null && message.hasOwnProperty("acquired_delegated_frozen_balance_for_bandwidth"))
                if (!$util.isInteger(message.acquired_delegated_frozen_balance_for_bandwidth) && !(message.acquired_delegated_frozen_balance_for_bandwidth && $util.isInteger(message.acquired_delegated_frozen_balance_for_bandwidth.low) && $util.isInteger(message.acquired_delegated_frozen_balance_for_bandwidth.high)))
                    return "acquired_delegated_frozen_balance_for_bandwidth: integer|Long expected";
            if (message.delegated_frozen_balance_for_bandwidth != null && message.hasOwnProperty("delegated_frozen_balance_for_bandwidth"))
                if (!$util.isInteger(message.delegated_frozen_balance_for_bandwidth) && !(message.delegated_frozen_balance_for_bandwidth && $util.isInteger(message.delegated_frozen_balance_for_bandwidth.low) && $util.isInteger(message.delegated_frozen_balance_for_bandwidth.high)))
                    return "delegated_frozen_balance_for_bandwidth: integer|Long expected";
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                if (!$util.isInteger(message.create_time) && !(message.create_time && $util.isInteger(message.create_time.low) && $util.isInteger(message.create_time.high)))
                    return "create_time: integer|Long expected";
            if (message.latest_opration_time != null && message.hasOwnProperty("latest_opration_time"))
                if (!$util.isInteger(message.latest_opration_time) && !(message.latest_opration_time && $util.isInteger(message.latest_opration_time.low) && $util.isInteger(message.latest_opration_time.high)))
                    return "latest_opration_time: integer|Long expected";
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                if (!$util.isInteger(message.allowance) && !(message.allowance && $util.isInteger(message.allowance.low) && $util.isInteger(message.allowance.high)))
                    return "allowance: integer|Long expected";
            if (message.latest_withdraw_time != null && message.hasOwnProperty("latest_withdraw_time"))
                if (!$util.isInteger(message.latest_withdraw_time) && !(message.latest_withdraw_time && $util.isInteger(message.latest_withdraw_time.low) && $util.isInteger(message.latest_withdraw_time.high)))
                    return "latest_withdraw_time: integer|Long expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!(message.code && typeof message.code.length === "number" || $util.isString(message.code)))
                    return "code: buffer expected";
            if (message.is_witness != null && message.hasOwnProperty("is_witness"))
                if (typeof message.is_witness !== "boolean")
                    return "is_witness: boolean expected";
            if (message.is_committee != null && message.hasOwnProperty("is_committee"))
                if (typeof message.is_committee !== "boolean")
                    return "is_committee: boolean expected";
            if (message.frozen_supply != null && message.hasOwnProperty("frozen_supply")) {
                if (!Array.isArray(message.frozen_supply))
                    return "frozen_supply: array expected";
                for (var i = 0; i < message.frozen_supply.length; ++i) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozen_supply[i]);
                    if (error)
                        return "frozen_supply." + error;
                }
            }
            if (message.asset_issued_name != null && message.hasOwnProperty("asset_issued_name"))
                if (!(message.asset_issued_name && typeof message.asset_issued_name.length === "number" || $util.isString(message.asset_issued_name)))
                    return "asset_issued_name: buffer expected";
            if (message.asset_issued_ID != null && message.hasOwnProperty("asset_issued_ID"))
                if (!(message.asset_issued_ID && typeof message.asset_issued_ID.length === "number" || $util.isString(message.asset_issued_ID)))
                    return "asset_issued_ID: buffer expected";
            if (message.latest_asset_operation_time != null && message.hasOwnProperty("latest_asset_operation_time")) {
                if (!$util.isObject(message.latest_asset_operation_time))
                    return "latest_asset_operation_time: object expected";
                var key = Object.keys(message.latest_asset_operation_time);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.latest_asset_operation_time[key[i]]) && !(message.latest_asset_operation_time[key[i]] && $util.isInteger(message.latest_asset_operation_time[key[i]].low) && $util.isInteger(message.latest_asset_operation_time[key[i]].high)))
                        return "latest_asset_operation_time: integer|Long{k:string} expected";
            }
            if (message.latest_asset_operation_timeV2 != null && message.hasOwnProperty("latest_asset_operation_timeV2")) {
                if (!$util.isObject(message.latest_asset_operation_timeV2))
                    return "latest_asset_operation_timeV2: object expected";
                var key = Object.keys(message.latest_asset_operation_timeV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.latest_asset_operation_timeV2[key[i]]) && !(message.latest_asset_operation_timeV2[key[i]] && $util.isInteger(message.latest_asset_operation_timeV2[key[i]].low) && $util.isInteger(message.latest_asset_operation_timeV2[key[i]].high)))
                        return "latest_asset_operation_timeV2: integer|Long{k:string} expected";
            }
            if (message.free_net_usage != null && message.hasOwnProperty("free_net_usage"))
                if (!$util.isInteger(message.free_net_usage) && !(message.free_net_usage && $util.isInteger(message.free_net_usage.low) && $util.isInteger(message.free_net_usage.high)))
                    return "free_net_usage: integer|Long expected";
            if (message.free_asset_net_usage != null && message.hasOwnProperty("free_asset_net_usage")) {
                if (!$util.isObject(message.free_asset_net_usage))
                    return "free_asset_net_usage: object expected";
                var key = Object.keys(message.free_asset_net_usage);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.free_asset_net_usage[key[i]]) && !(message.free_asset_net_usage[key[i]] && $util.isInteger(message.free_asset_net_usage[key[i]].low) && $util.isInteger(message.free_asset_net_usage[key[i]].high)))
                        return "free_asset_net_usage: integer|Long{k:string} expected";
            }
            if (message.free_asset_net_usageV2 != null && message.hasOwnProperty("free_asset_net_usageV2")) {
                if (!$util.isObject(message.free_asset_net_usageV2))
                    return "free_asset_net_usageV2: object expected";
                var key = Object.keys(message.free_asset_net_usageV2);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.free_asset_net_usageV2[key[i]]) && !(message.free_asset_net_usageV2[key[i]] && $util.isInteger(message.free_asset_net_usageV2[key[i]].low) && $util.isInteger(message.free_asset_net_usageV2[key[i]].high)))
                        return "free_asset_net_usageV2: integer|Long{k:string} expected";
            }
            if (message.latest_consume_time != null && message.hasOwnProperty("latest_consume_time"))
                if (!$util.isInteger(message.latest_consume_time) && !(message.latest_consume_time && $util.isInteger(message.latest_consume_time.low) && $util.isInteger(message.latest_consume_time.high)))
                    return "latest_consume_time: integer|Long expected";
            if (message.latest_consume_free_time != null && message.hasOwnProperty("latest_consume_free_time"))
                if (!$util.isInteger(message.latest_consume_free_time) && !(message.latest_consume_free_time && $util.isInteger(message.latest_consume_free_time.low) && $util.isInteger(message.latest_consume_free_time.high)))
                    return "latest_consume_free_time: integer|Long expected";
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                if (!(message.account_id && typeof message.account_id.length === "number" || $util.isString(message.account_id)))
                    return "account_id: buffer expected";
            if (message.account_resource != null && message.hasOwnProperty("account_resource")) {
                var error = $root.protocol.Account.AccountResource.verify(message.account_resource);
                if (error)
                    return "account_resource." + error;
            }
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                if (!(message.codeHash && typeof message.codeHash.length === "number" || $util.isString(message.codeHash)))
                    return "codeHash: buffer expected";
            if (message.owner_permission != null && message.hasOwnProperty("owner_permission")) {
                var error = $root.protocol.Permission.verify(message.owner_permission);
                if (error)
                    return "owner_permission." + error;
            }
            if (message.witness_permission != null && message.hasOwnProperty("witness_permission")) {
                var error = $root.protocol.Permission.verify(message.witness_permission);
                if (error)
                    return "witness_permission." + error;
            }
            if (message.active_permission != null && message.hasOwnProperty("active_permission")) {
                if (!Array.isArray(message.active_permission))
                    return "active_permission: array expected";
                for (var i = 0; i < message.active_permission.length; ++i) {
                    var error = $root.protocol.Permission.verify(message.active_permission[i]);
                    if (error)
                        return "active_permission." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Account message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Account
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Account} Account
         */
        Account.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Account)
                return object;
            var message = new $root.protocol.Account();
            if (object.account_name != null)
                if (typeof object.account_name === "string")
                    $util.base64.decode(object.account_name, message.account_name = $util.newBuffer($util.base64.length(object.account_name)), 0);
                else if (object.account_name.length)
                    message.account_name = object.account_name;
            switch (object.type) {
            case "Normal":
            case 0:
                message.type = 0;
                break;
            case "AssetIssue":
            case 1:
                message.type = 1;
                break;
            case "Contract":
            case 2:
                message.type = 2;
                break;
            }
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
            if (object.votes) {
                if (!Array.isArray(object.votes))
                    throw TypeError(".protocol.Account.votes: array expected");
                message.votes = [];
                for (var i = 0; i < object.votes.length; ++i) {
                    if (typeof object.votes[i] !== "object")
                        throw TypeError(".protocol.Account.votes: object expected");
                    message.votes[i] = $root.protocol.Vote.fromObject(object.votes[i]);
                }
            }
            if (object.asset) {
                if (typeof object.asset !== "object")
                    throw TypeError(".protocol.Account.asset: object expected");
                message.asset = {};
                for (var keys = Object.keys(object.asset), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.asset[keys[i]] = $util.Long.fromValue(object.asset[keys[i]])).unsigned = false;
                    else if (typeof object.asset[keys[i]] === "string")
                        message.asset[keys[i]] = parseInt(object.asset[keys[i]], 10);
                    else if (typeof object.asset[keys[i]] === "number")
                        message.asset[keys[i]] = object.asset[keys[i]];
                    else if (typeof object.asset[keys[i]] === "object")
                        message.asset[keys[i]] = new $util.LongBits(object.asset[keys[i]].low >>> 0, object.asset[keys[i]].high >>> 0).toNumber();
            }
            if (object.assetV2) {
                if (typeof object.assetV2 !== "object")
                    throw TypeError(".protocol.Account.assetV2: object expected");
                message.assetV2 = {};
                for (var keys = Object.keys(object.assetV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.assetV2[keys[i]] = $util.Long.fromValue(object.assetV2[keys[i]])).unsigned = false;
                    else if (typeof object.assetV2[keys[i]] === "string")
                        message.assetV2[keys[i]] = parseInt(object.assetV2[keys[i]], 10);
                    else if (typeof object.assetV2[keys[i]] === "number")
                        message.assetV2[keys[i]] = object.assetV2[keys[i]];
                    else if (typeof object.assetV2[keys[i]] === "object")
                        message.assetV2[keys[i]] = new $util.LongBits(object.assetV2[keys[i]].low >>> 0, object.assetV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.frozen) {
                if (!Array.isArray(object.frozen))
                    throw TypeError(".protocol.Account.frozen: array expected");
                message.frozen = [];
                for (var i = 0; i < object.frozen.length; ++i) {
                    if (typeof object.frozen[i] !== "object")
                        throw TypeError(".protocol.Account.frozen: object expected");
                    message.frozen[i] = $root.protocol.Account.Frozen.fromObject(object.frozen[i]);
                }
            }
            if (object.net_usage != null)
                if ($util.Long)
                    (message.net_usage = $util.Long.fromValue(object.net_usage)).unsigned = false;
                else if (typeof object.net_usage === "string")
                    message.net_usage = parseInt(object.net_usage, 10);
                else if (typeof object.net_usage === "number")
                    message.net_usage = object.net_usage;
                else if (typeof object.net_usage === "object")
                    message.net_usage = new $util.LongBits(object.net_usage.low >>> 0, object.net_usage.high >>> 0).toNumber();
            if (object.acquired_delegated_frozen_balance_for_bandwidth != null)
                if ($util.Long)
                    (message.acquired_delegated_frozen_balance_for_bandwidth = $util.Long.fromValue(object.acquired_delegated_frozen_balance_for_bandwidth)).unsigned = false;
                else if (typeof object.acquired_delegated_frozen_balance_for_bandwidth === "string")
                    message.acquired_delegated_frozen_balance_for_bandwidth = parseInt(object.acquired_delegated_frozen_balance_for_bandwidth, 10);
                else if (typeof object.acquired_delegated_frozen_balance_for_bandwidth === "number")
                    message.acquired_delegated_frozen_balance_for_bandwidth = object.acquired_delegated_frozen_balance_for_bandwidth;
                else if (typeof object.acquired_delegated_frozen_balance_for_bandwidth === "object")
                    message.acquired_delegated_frozen_balance_for_bandwidth = new $util.LongBits(object.acquired_delegated_frozen_balance_for_bandwidth.low >>> 0, object.acquired_delegated_frozen_balance_for_bandwidth.high >>> 0).toNumber();
            if (object.delegated_frozen_balance_for_bandwidth != null)
                if ($util.Long)
                    (message.delegated_frozen_balance_for_bandwidth = $util.Long.fromValue(object.delegated_frozen_balance_for_bandwidth)).unsigned = false;
                else if (typeof object.delegated_frozen_balance_for_bandwidth === "string")
                    message.delegated_frozen_balance_for_bandwidth = parseInt(object.delegated_frozen_balance_for_bandwidth, 10);
                else if (typeof object.delegated_frozen_balance_for_bandwidth === "number")
                    message.delegated_frozen_balance_for_bandwidth = object.delegated_frozen_balance_for_bandwidth;
                else if (typeof object.delegated_frozen_balance_for_bandwidth === "object")
                    message.delegated_frozen_balance_for_bandwidth = new $util.LongBits(object.delegated_frozen_balance_for_bandwidth.low >>> 0, object.delegated_frozen_balance_for_bandwidth.high >>> 0).toNumber();
            if (object.create_time != null)
                if ($util.Long)
                    (message.create_time = $util.Long.fromValue(object.create_time)).unsigned = false;
                else if (typeof object.create_time === "string")
                    message.create_time = parseInt(object.create_time, 10);
                else if (typeof object.create_time === "number")
                    message.create_time = object.create_time;
                else if (typeof object.create_time === "object")
                    message.create_time = new $util.LongBits(object.create_time.low >>> 0, object.create_time.high >>> 0).toNumber();
            if (object.latest_opration_time != null)
                if ($util.Long)
                    (message.latest_opration_time = $util.Long.fromValue(object.latest_opration_time)).unsigned = false;
                else if (typeof object.latest_opration_time === "string")
                    message.latest_opration_time = parseInt(object.latest_opration_time, 10);
                else if (typeof object.latest_opration_time === "number")
                    message.latest_opration_time = object.latest_opration_time;
                else if (typeof object.latest_opration_time === "object")
                    message.latest_opration_time = new $util.LongBits(object.latest_opration_time.low >>> 0, object.latest_opration_time.high >>> 0).toNumber();
            if (object.allowance != null)
                if ($util.Long)
                    (message.allowance = $util.Long.fromValue(object.allowance)).unsigned = false;
                else if (typeof object.allowance === "string")
                    message.allowance = parseInt(object.allowance, 10);
                else if (typeof object.allowance === "number")
                    message.allowance = object.allowance;
                else if (typeof object.allowance === "object")
                    message.allowance = new $util.LongBits(object.allowance.low >>> 0, object.allowance.high >>> 0).toNumber();
            if (object.latest_withdraw_time != null)
                if ($util.Long)
                    (message.latest_withdraw_time = $util.Long.fromValue(object.latest_withdraw_time)).unsigned = false;
                else if (typeof object.latest_withdraw_time === "string")
                    message.latest_withdraw_time = parseInt(object.latest_withdraw_time, 10);
                else if (typeof object.latest_withdraw_time === "number")
                    message.latest_withdraw_time = object.latest_withdraw_time;
                else if (typeof object.latest_withdraw_time === "object")
                    message.latest_withdraw_time = new $util.LongBits(object.latest_withdraw_time.low >>> 0, object.latest_withdraw_time.high >>> 0).toNumber();
            if (object.code != null)
                if (typeof object.code === "string")
                    $util.base64.decode(object.code, message.code = $util.newBuffer($util.base64.length(object.code)), 0);
                else if (object.code.length)
                    message.code = object.code;
            if (object.is_witness != null)
                message.is_witness = Boolean(object.is_witness);
            if (object.is_committee != null)
                message.is_committee = Boolean(object.is_committee);
            if (object.frozen_supply) {
                if (!Array.isArray(object.frozen_supply))
                    throw TypeError(".protocol.Account.frozen_supply: array expected");
                message.frozen_supply = [];
                for (var i = 0; i < object.frozen_supply.length; ++i) {
                    if (typeof object.frozen_supply[i] !== "object")
                        throw TypeError(".protocol.Account.frozen_supply: object expected");
                    message.frozen_supply[i] = $root.protocol.Account.Frozen.fromObject(object.frozen_supply[i]);
                }
            }
            if (object.asset_issued_name != null)
                if (typeof object.asset_issued_name === "string")
                    $util.base64.decode(object.asset_issued_name, message.asset_issued_name = $util.newBuffer($util.base64.length(object.asset_issued_name)), 0);
                else if (object.asset_issued_name.length)
                    message.asset_issued_name = object.asset_issued_name;
            if (object.asset_issued_ID != null)
                if (typeof object.asset_issued_ID === "string")
                    $util.base64.decode(object.asset_issued_ID, message.asset_issued_ID = $util.newBuffer($util.base64.length(object.asset_issued_ID)), 0);
                else if (object.asset_issued_ID.length)
                    message.asset_issued_ID = object.asset_issued_ID;
            if (object.latest_asset_operation_time) {
                if (typeof object.latest_asset_operation_time !== "object")
                    throw TypeError(".protocol.Account.latest_asset_operation_time: object expected");
                message.latest_asset_operation_time = {};
                for (var keys = Object.keys(object.latest_asset_operation_time), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.latest_asset_operation_time[keys[i]] = $util.Long.fromValue(object.latest_asset_operation_time[keys[i]])).unsigned = false;
                    else if (typeof object.latest_asset_operation_time[keys[i]] === "string")
                        message.latest_asset_operation_time[keys[i]] = parseInt(object.latest_asset_operation_time[keys[i]], 10);
                    else if (typeof object.latest_asset_operation_time[keys[i]] === "number")
                        message.latest_asset_operation_time[keys[i]] = object.latest_asset_operation_time[keys[i]];
                    else if (typeof object.latest_asset_operation_time[keys[i]] === "object")
                        message.latest_asset_operation_time[keys[i]] = new $util.LongBits(object.latest_asset_operation_time[keys[i]].low >>> 0, object.latest_asset_operation_time[keys[i]].high >>> 0).toNumber();
            }
            if (object.latest_asset_operation_timeV2) {
                if (typeof object.latest_asset_operation_timeV2 !== "object")
                    throw TypeError(".protocol.Account.latest_asset_operation_timeV2: object expected");
                message.latest_asset_operation_timeV2 = {};
                for (var keys = Object.keys(object.latest_asset_operation_timeV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.latest_asset_operation_timeV2[keys[i]] = $util.Long.fromValue(object.latest_asset_operation_timeV2[keys[i]])).unsigned = false;
                    else if (typeof object.latest_asset_operation_timeV2[keys[i]] === "string")
                        message.latest_asset_operation_timeV2[keys[i]] = parseInt(object.latest_asset_operation_timeV2[keys[i]], 10);
                    else if (typeof object.latest_asset_operation_timeV2[keys[i]] === "number")
                        message.latest_asset_operation_timeV2[keys[i]] = object.latest_asset_operation_timeV2[keys[i]];
                    else if (typeof object.latest_asset_operation_timeV2[keys[i]] === "object")
                        message.latest_asset_operation_timeV2[keys[i]] = new $util.LongBits(object.latest_asset_operation_timeV2[keys[i]].low >>> 0, object.latest_asset_operation_timeV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.free_net_usage != null)
                if ($util.Long)
                    (message.free_net_usage = $util.Long.fromValue(object.free_net_usage)).unsigned = false;
                else if (typeof object.free_net_usage === "string")
                    message.free_net_usage = parseInt(object.free_net_usage, 10);
                else if (typeof object.free_net_usage === "number")
                    message.free_net_usage = object.free_net_usage;
                else if (typeof object.free_net_usage === "object")
                    message.free_net_usage = new $util.LongBits(object.free_net_usage.low >>> 0, object.free_net_usage.high >>> 0).toNumber();
            if (object.free_asset_net_usage) {
                if (typeof object.free_asset_net_usage !== "object")
                    throw TypeError(".protocol.Account.free_asset_net_usage: object expected");
                message.free_asset_net_usage = {};
                for (var keys = Object.keys(object.free_asset_net_usage), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.free_asset_net_usage[keys[i]] = $util.Long.fromValue(object.free_asset_net_usage[keys[i]])).unsigned = false;
                    else if (typeof object.free_asset_net_usage[keys[i]] === "string")
                        message.free_asset_net_usage[keys[i]] = parseInt(object.free_asset_net_usage[keys[i]], 10);
                    else if (typeof object.free_asset_net_usage[keys[i]] === "number")
                        message.free_asset_net_usage[keys[i]] = object.free_asset_net_usage[keys[i]];
                    else if (typeof object.free_asset_net_usage[keys[i]] === "object")
                        message.free_asset_net_usage[keys[i]] = new $util.LongBits(object.free_asset_net_usage[keys[i]].low >>> 0, object.free_asset_net_usage[keys[i]].high >>> 0).toNumber();
            }
            if (object.free_asset_net_usageV2) {
                if (typeof object.free_asset_net_usageV2 !== "object")
                    throw TypeError(".protocol.Account.free_asset_net_usageV2: object expected");
                message.free_asset_net_usageV2 = {};
                for (var keys = Object.keys(object.free_asset_net_usageV2), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.free_asset_net_usageV2[keys[i]] = $util.Long.fromValue(object.free_asset_net_usageV2[keys[i]])).unsigned = false;
                    else if (typeof object.free_asset_net_usageV2[keys[i]] === "string")
                        message.free_asset_net_usageV2[keys[i]] = parseInt(object.free_asset_net_usageV2[keys[i]], 10);
                    else if (typeof object.free_asset_net_usageV2[keys[i]] === "number")
                        message.free_asset_net_usageV2[keys[i]] = object.free_asset_net_usageV2[keys[i]];
                    else if (typeof object.free_asset_net_usageV2[keys[i]] === "object")
                        message.free_asset_net_usageV2[keys[i]] = new $util.LongBits(object.free_asset_net_usageV2[keys[i]].low >>> 0, object.free_asset_net_usageV2[keys[i]].high >>> 0).toNumber();
            }
            if (object.latest_consume_time != null)
                if ($util.Long)
                    (message.latest_consume_time = $util.Long.fromValue(object.latest_consume_time)).unsigned = false;
                else if (typeof object.latest_consume_time === "string")
                    message.latest_consume_time = parseInt(object.latest_consume_time, 10);
                else if (typeof object.latest_consume_time === "number")
                    message.latest_consume_time = object.latest_consume_time;
                else if (typeof object.latest_consume_time === "object")
                    message.latest_consume_time = new $util.LongBits(object.latest_consume_time.low >>> 0, object.latest_consume_time.high >>> 0).toNumber();
            if (object.latest_consume_free_time != null)
                if ($util.Long)
                    (message.latest_consume_free_time = $util.Long.fromValue(object.latest_consume_free_time)).unsigned = false;
                else if (typeof object.latest_consume_free_time === "string")
                    message.latest_consume_free_time = parseInt(object.latest_consume_free_time, 10);
                else if (typeof object.latest_consume_free_time === "number")
                    message.latest_consume_free_time = object.latest_consume_free_time;
                else if (typeof object.latest_consume_free_time === "object")
                    message.latest_consume_free_time = new $util.LongBits(object.latest_consume_free_time.low >>> 0, object.latest_consume_free_time.high >>> 0).toNumber();
            if (object.account_id != null)
                if (typeof object.account_id === "string")
                    $util.base64.decode(object.account_id, message.account_id = $util.newBuffer($util.base64.length(object.account_id)), 0);
                else if (object.account_id.length)
                    message.account_id = object.account_id;
            if (object.account_resource != null) {
                if (typeof object.account_resource !== "object")
                    throw TypeError(".protocol.Account.account_resource: object expected");
                message.account_resource = $root.protocol.Account.AccountResource.fromObject(object.account_resource);
            }
            if (object.codeHash != null)
                if (typeof object.codeHash === "string")
                    $util.base64.decode(object.codeHash, message.codeHash = $util.newBuffer($util.base64.length(object.codeHash)), 0);
                else if (object.codeHash.length)
                    message.codeHash = object.codeHash;
            if (object.owner_permission != null) {
                if (typeof object.owner_permission !== "object")
                    throw TypeError(".protocol.Account.owner_permission: object expected");
                message.owner_permission = $root.protocol.Permission.fromObject(object.owner_permission);
            }
            if (object.witness_permission != null) {
                if (typeof object.witness_permission !== "object")
                    throw TypeError(".protocol.Account.witness_permission: object expected");
                message.witness_permission = $root.protocol.Permission.fromObject(object.witness_permission);
            }
            if (object.active_permission) {
                if (!Array.isArray(object.active_permission))
                    throw TypeError(".protocol.Account.active_permission: array expected");
                message.active_permission = [];
                for (var i = 0; i < object.active_permission.length; ++i) {
                    if (typeof object.active_permission[i] !== "object")
                        throw TypeError(".protocol.Account.active_permission: object expected");
                    message.active_permission[i] = $root.protocol.Permission.fromObject(object.active_permission[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Account message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Account
         * @static
         * @param {protocol.Account} message Account
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Account.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.votes = [];
                object.frozen = [];
                object.frozen_supply = [];
                object.active_permission = [];
            }
            if (options.objects || options.defaults) {
                object.asset = {};
                object.latest_asset_operation_time = {};
                object.free_asset_net_usage = {};
                object.assetV2 = {};
                object.latest_asset_operation_timeV2 = {};
                object.free_asset_net_usageV2 = {};
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.account_name = "";
                else {
                    object.account_name = [];
                    if (options.bytes !== Array)
                        object.account_name = $util.newBuffer(object.account_name);
                }
                object.type = options.enums === String ? "Normal" : 0;
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.net_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.net_usage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.create_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.create_time = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latest_opration_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latest_opration_time = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.allowance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.allowance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latest_withdraw_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latest_withdraw_time = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.code = "";
                else {
                    object.code = [];
                    if (options.bytes !== Array)
                        object.code = $util.newBuffer(object.code);
                }
                object.is_witness = false;
                object.is_committee = false;
                if (options.bytes === String)
                    object.asset_issued_name = "";
                else {
                    object.asset_issued_name = [];
                    if (options.bytes !== Array)
                        object.asset_issued_name = $util.newBuffer(object.asset_issued_name);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.free_net_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.free_net_usage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latest_consume_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latest_consume_time = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latest_consume_free_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latest_consume_free_time = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.account_id = "";
                else {
                    object.account_id = [];
                    if (options.bytes !== Array)
                        object.account_id = $util.newBuffer(object.account_id);
                }
                object.account_resource = null;
                if (options.bytes === String)
                    object.codeHash = "";
                else {
                    object.codeHash = [];
                    if (options.bytes !== Array)
                        object.codeHash = $util.newBuffer(object.codeHash);
                }
                object.owner_permission = null;
                object.witness_permission = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.acquired_delegated_frozen_balance_for_bandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.acquired_delegated_frozen_balance_for_bandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.delegated_frozen_balance_for_bandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.delegated_frozen_balance_for_bandwidth = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.asset_issued_ID = "";
                else {
                    object.asset_issued_ID = [];
                    if (options.bytes !== Array)
                        object.asset_issued_ID = $util.newBuffer(object.asset_issued_ID);
                }
            }
            if (message.account_name != null && message.hasOwnProperty("account_name"))
                object.account_name = options.bytes === String ? $util.base64.encode(message.account_name, 0, message.account_name.length) : options.bytes === Array ? Array.prototype.slice.call(message.account_name) : message.account_name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.AccountType[message.type] : message.type;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
            if (message.votes && message.votes.length) {
                object.votes = [];
                for (var j = 0; j < message.votes.length; ++j)
                    object.votes[j] = $root.protocol.Vote.toObject(message.votes[j], options);
            }
            var keys2;
            if (message.asset && (keys2 = Object.keys(message.asset)).length) {
                object.asset = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.asset[keys2[j]] === "number")
                        object.asset[keys2[j]] = options.longs === String ? String(message.asset[keys2[j]]) : message.asset[keys2[j]];
                    else
                        object.asset[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.asset[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.asset[keys2[j]].low >>> 0, message.asset[keys2[j]].high >>> 0).toNumber() : message.asset[keys2[j]];
            }
            if (message.frozen && message.frozen.length) {
                object.frozen = [];
                for (var j = 0; j < message.frozen.length; ++j)
                    object.frozen[j] = $root.protocol.Account.Frozen.toObject(message.frozen[j], options);
            }
            if (message.net_usage != null && message.hasOwnProperty("net_usage"))
                if (typeof message.net_usage === "number")
                    object.net_usage = options.longs === String ? String(message.net_usage) : message.net_usage;
                else
                    object.net_usage = options.longs === String ? $util.Long.prototype.toString.call(message.net_usage) : options.longs === Number ? new $util.LongBits(message.net_usage.low >>> 0, message.net_usage.high >>> 0).toNumber() : message.net_usage;
            if (message.create_time != null && message.hasOwnProperty("create_time"))
                if (typeof message.create_time === "number")
                    object.create_time = options.longs === String ? String(message.create_time) : message.create_time;
                else
                    object.create_time = options.longs === String ? $util.Long.prototype.toString.call(message.create_time) : options.longs === Number ? new $util.LongBits(message.create_time.low >>> 0, message.create_time.high >>> 0).toNumber() : message.create_time;
            if (message.latest_opration_time != null && message.hasOwnProperty("latest_opration_time"))
                if (typeof message.latest_opration_time === "number")
                    object.latest_opration_time = options.longs === String ? String(message.latest_opration_time) : message.latest_opration_time;
                else
                    object.latest_opration_time = options.longs === String ? $util.Long.prototype.toString.call(message.latest_opration_time) : options.longs === Number ? new $util.LongBits(message.latest_opration_time.low >>> 0, message.latest_opration_time.high >>> 0).toNumber() : message.latest_opration_time;
            if (message.allowance != null && message.hasOwnProperty("allowance"))
                if (typeof message.allowance === "number")
                    object.allowance = options.longs === String ? String(message.allowance) : message.allowance;
                else
                    object.allowance = options.longs === String ? $util.Long.prototype.toString.call(message.allowance) : options.longs === Number ? new $util.LongBits(message.allowance.low >>> 0, message.allowance.high >>> 0).toNumber() : message.allowance;
            if (message.latest_withdraw_time != null && message.hasOwnProperty("latest_withdraw_time"))
                if (typeof message.latest_withdraw_time === "number")
                    object.latest_withdraw_time = options.longs === String ? String(message.latest_withdraw_time) : message.latest_withdraw_time;
                else
                    object.latest_withdraw_time = options.longs === String ? $util.Long.prototype.toString.call(message.latest_withdraw_time) : options.longs === Number ? new $util.LongBits(message.latest_withdraw_time.low >>> 0, message.latest_withdraw_time.high >>> 0).toNumber() : message.latest_withdraw_time;
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = options.bytes === String ? $util.base64.encode(message.code, 0, message.code.length) : options.bytes === Array ? Array.prototype.slice.call(message.code) : message.code;
            if (message.is_witness != null && message.hasOwnProperty("is_witness"))
                object.is_witness = message.is_witness;
            if (message.is_committee != null && message.hasOwnProperty("is_committee"))
                object.is_committee = message.is_committee;
            if (message.frozen_supply && message.frozen_supply.length) {
                object.frozen_supply = [];
                for (var j = 0; j < message.frozen_supply.length; ++j)
                    object.frozen_supply[j] = $root.protocol.Account.Frozen.toObject(message.frozen_supply[j], options);
            }
            if (message.asset_issued_name != null && message.hasOwnProperty("asset_issued_name"))
                object.asset_issued_name = options.bytes === String ? $util.base64.encode(message.asset_issued_name, 0, message.asset_issued_name.length) : options.bytes === Array ? Array.prototype.slice.call(message.asset_issued_name) : message.asset_issued_name;
            if (message.latest_asset_operation_time && (keys2 = Object.keys(message.latest_asset_operation_time)).length) {
                object.latest_asset_operation_time = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.latest_asset_operation_time[keys2[j]] === "number")
                        object.latest_asset_operation_time[keys2[j]] = options.longs === String ? String(message.latest_asset_operation_time[keys2[j]]) : message.latest_asset_operation_time[keys2[j]];
                    else
                        object.latest_asset_operation_time[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.latest_asset_operation_time[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.latest_asset_operation_time[keys2[j]].low >>> 0, message.latest_asset_operation_time[keys2[j]].high >>> 0).toNumber() : message.latest_asset_operation_time[keys2[j]];
            }
            if (message.free_net_usage != null && message.hasOwnProperty("free_net_usage"))
                if (typeof message.free_net_usage === "number")
                    object.free_net_usage = options.longs === String ? String(message.free_net_usage) : message.free_net_usage;
                else
                    object.free_net_usage = options.longs === String ? $util.Long.prototype.toString.call(message.free_net_usage) : options.longs === Number ? new $util.LongBits(message.free_net_usage.low >>> 0, message.free_net_usage.high >>> 0).toNumber() : message.free_net_usage;
            if (message.free_asset_net_usage && (keys2 = Object.keys(message.free_asset_net_usage)).length) {
                object.free_asset_net_usage = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.free_asset_net_usage[keys2[j]] === "number")
                        object.free_asset_net_usage[keys2[j]] = options.longs === String ? String(message.free_asset_net_usage[keys2[j]]) : message.free_asset_net_usage[keys2[j]];
                    else
                        object.free_asset_net_usage[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.free_asset_net_usage[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.free_asset_net_usage[keys2[j]].low >>> 0, message.free_asset_net_usage[keys2[j]].high >>> 0).toNumber() : message.free_asset_net_usage[keys2[j]];
            }
            if (message.latest_consume_time != null && message.hasOwnProperty("latest_consume_time"))
                if (typeof message.latest_consume_time === "number")
                    object.latest_consume_time = options.longs === String ? String(message.latest_consume_time) : message.latest_consume_time;
                else
                    object.latest_consume_time = options.longs === String ? $util.Long.prototype.toString.call(message.latest_consume_time) : options.longs === Number ? new $util.LongBits(message.latest_consume_time.low >>> 0, message.latest_consume_time.high >>> 0).toNumber() : message.latest_consume_time;
            if (message.latest_consume_free_time != null && message.hasOwnProperty("latest_consume_free_time"))
                if (typeof message.latest_consume_free_time === "number")
                    object.latest_consume_free_time = options.longs === String ? String(message.latest_consume_free_time) : message.latest_consume_free_time;
                else
                    object.latest_consume_free_time = options.longs === String ? $util.Long.prototype.toString.call(message.latest_consume_free_time) : options.longs === Number ? new $util.LongBits(message.latest_consume_free_time.low >>> 0, message.latest_consume_free_time.high >>> 0).toNumber() : message.latest_consume_free_time;
            if (message.account_id != null && message.hasOwnProperty("account_id"))
                object.account_id = options.bytes === String ? $util.base64.encode(message.account_id, 0, message.account_id.length) : options.bytes === Array ? Array.prototype.slice.call(message.account_id) : message.account_id;
            if (message.account_resource != null && message.hasOwnProperty("account_resource"))
                object.account_resource = $root.protocol.Account.AccountResource.toObject(message.account_resource, options);
            if (message.codeHash != null && message.hasOwnProperty("codeHash"))
                object.codeHash = options.bytes === String ? $util.base64.encode(message.codeHash, 0, message.codeHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.codeHash) : message.codeHash;
            if (message.owner_permission != null && message.hasOwnProperty("owner_permission"))
                object.owner_permission = $root.protocol.Permission.toObject(message.owner_permission, options);
            if (message.witness_permission != null && message.hasOwnProperty("witness_permission"))
                object.witness_permission = $root.protocol.Permission.toObject(message.witness_permission, options);
            if (message.active_permission && message.active_permission.length) {
                object.active_permission = [];
                for (var j = 0; j < message.active_permission.length; ++j)
                    object.active_permission[j] = $root.protocol.Permission.toObject(message.active_permission[j], options);
            }
            if (message.acquired_delegated_frozen_balance_for_bandwidth != null && message.hasOwnProperty("acquired_delegated_frozen_balance_for_bandwidth"))
                if (typeof message.acquired_delegated_frozen_balance_for_bandwidth === "number")
                    object.acquired_delegated_frozen_balance_for_bandwidth = options.longs === String ? String(message.acquired_delegated_frozen_balance_for_bandwidth) : message.acquired_delegated_frozen_balance_for_bandwidth;
                else
                    object.acquired_delegated_frozen_balance_for_bandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.acquired_delegated_frozen_balance_for_bandwidth) : options.longs === Number ? new $util.LongBits(message.acquired_delegated_frozen_balance_for_bandwidth.low >>> 0, message.acquired_delegated_frozen_balance_for_bandwidth.high >>> 0).toNumber() : message.acquired_delegated_frozen_balance_for_bandwidth;
            if (message.delegated_frozen_balance_for_bandwidth != null && message.hasOwnProperty("delegated_frozen_balance_for_bandwidth"))
                if (typeof message.delegated_frozen_balance_for_bandwidth === "number")
                    object.delegated_frozen_balance_for_bandwidth = options.longs === String ? String(message.delegated_frozen_balance_for_bandwidth) : message.delegated_frozen_balance_for_bandwidth;
                else
                    object.delegated_frozen_balance_for_bandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.delegated_frozen_balance_for_bandwidth) : options.longs === Number ? new $util.LongBits(message.delegated_frozen_balance_for_bandwidth.low >>> 0, message.delegated_frozen_balance_for_bandwidth.high >>> 0).toNumber() : message.delegated_frozen_balance_for_bandwidth;
            if (message.assetV2 && (keys2 = Object.keys(message.assetV2)).length) {
                object.assetV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.assetV2[keys2[j]] === "number")
                        object.assetV2[keys2[j]] = options.longs === String ? String(message.assetV2[keys2[j]]) : message.assetV2[keys2[j]];
                    else
                        object.assetV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.assetV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.assetV2[keys2[j]].low >>> 0, message.assetV2[keys2[j]].high >>> 0).toNumber() : message.assetV2[keys2[j]];
            }
            if (message.asset_issued_ID != null && message.hasOwnProperty("asset_issued_ID"))
                object.asset_issued_ID = options.bytes === String ? $util.base64.encode(message.asset_issued_ID, 0, message.asset_issued_ID.length) : options.bytes === Array ? Array.prototype.slice.call(message.asset_issued_ID) : message.asset_issued_ID;
            if (message.latest_asset_operation_timeV2 && (keys2 = Object.keys(message.latest_asset_operation_timeV2)).length) {
                object.latest_asset_operation_timeV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.latest_asset_operation_timeV2[keys2[j]] === "number")
                        object.latest_asset_operation_timeV2[keys2[j]] = options.longs === String ? String(message.latest_asset_operation_timeV2[keys2[j]]) : message.latest_asset_operation_timeV2[keys2[j]];
                    else
                        object.latest_asset_operation_timeV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.latest_asset_operation_timeV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.latest_asset_operation_timeV2[keys2[j]].low >>> 0, message.latest_asset_operation_timeV2[keys2[j]].high >>> 0).toNumber() : message.latest_asset_operation_timeV2[keys2[j]];
            }
            if (message.free_asset_net_usageV2 && (keys2 = Object.keys(message.free_asset_net_usageV2)).length) {
                object.free_asset_net_usageV2 = {};
                for (var j = 0; j < keys2.length; ++j)
                    if (typeof message.free_asset_net_usageV2[keys2[j]] === "number")
                        object.free_asset_net_usageV2[keys2[j]] = options.longs === String ? String(message.free_asset_net_usageV2[keys2[j]]) : message.free_asset_net_usageV2[keys2[j]];
                    else
                        object.free_asset_net_usageV2[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.free_asset_net_usageV2[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.free_asset_net_usageV2[keys2[j]].low >>> 0, message.free_asset_net_usageV2[keys2[j]].high >>> 0).toNumber() : message.free_asset_net_usageV2[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this Account to JSON.
         * @function toJSON
         * @memberof protocol.Account
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Account.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Account.Frozen = (function() {

            /**
             * Properties of a Frozen.
             * @memberof protocol.Account
             * @interface IFrozen
             * @property {number|Long|null} [frozen_balance] Frozen frozen_balance
             * @property {number|Long|null} [expire_time] Frozen expire_time
             */

            /**
             * Constructs a new Frozen.
             * @memberof protocol.Account
             * @classdesc Represents a Frozen.
             * @implements IFrozen
             * @constructor
             * @param {protocol.Account.IFrozen=} [properties] Properties to set
             */
            function Frozen(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Frozen frozen_balance.
             * @member {number|Long} frozen_balance
             * @memberof protocol.Account.Frozen
             * @instance
             */
            Frozen.prototype.frozen_balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Frozen expire_time.
             * @member {number|Long} expire_time
             * @memberof protocol.Account.Frozen
             * @instance
             */
            Frozen.prototype.expire_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Frozen instance using the specified properties.
             * @function create
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.IFrozen=} [properties] Properties to set
             * @returns {protocol.Account.Frozen} Frozen instance
             */
            Frozen.create = function create(properties) {
                return new Frozen(properties);
            };

            /**
             * Encodes the specified Frozen message. Does not implicitly {@link protocol.Account.Frozen.verify|verify} messages.
             * @function encode
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.IFrozen} message Frozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Frozen.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.frozen_balance != null && message.hasOwnProperty("frozen_balance"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.frozen_balance);
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.expire_time);
                return writer;
            };

            /**
             * Encodes the specified Frozen message, length delimited. Does not implicitly {@link protocol.Account.Frozen.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.IFrozen} message Frozen message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Frozen.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Frozen message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Account.Frozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Account.Frozen} Frozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Frozen.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account.Frozen();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.frozen_balance = reader.int64();
                        break;
                    case 2:
                        message.expire_time = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Frozen message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Account.Frozen
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Account.Frozen} Frozen
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Frozen.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Frozen message.
             * @function verify
             * @memberof protocol.Account.Frozen
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Frozen.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.frozen_balance != null && message.hasOwnProperty("frozen_balance"))
                    if (!$util.isInteger(message.frozen_balance) && !(message.frozen_balance && $util.isInteger(message.frozen_balance.low) && $util.isInteger(message.frozen_balance.high)))
                        return "frozen_balance: integer|Long expected";
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    if (!$util.isInteger(message.expire_time) && !(message.expire_time && $util.isInteger(message.expire_time.low) && $util.isInteger(message.expire_time.high)))
                        return "expire_time: integer|Long expected";
                return null;
            };

            /**
             * Creates a Frozen message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Account.Frozen
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Account.Frozen} Frozen
             */
            Frozen.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Account.Frozen)
                    return object;
                var message = new $root.protocol.Account.Frozen();
                if (object.frozen_balance != null)
                    if ($util.Long)
                        (message.frozen_balance = $util.Long.fromValue(object.frozen_balance)).unsigned = false;
                    else if (typeof object.frozen_balance === "string")
                        message.frozen_balance = parseInt(object.frozen_balance, 10);
                    else if (typeof object.frozen_balance === "number")
                        message.frozen_balance = object.frozen_balance;
                    else if (typeof object.frozen_balance === "object")
                        message.frozen_balance = new $util.LongBits(object.frozen_balance.low >>> 0, object.frozen_balance.high >>> 0).toNumber();
                if (object.expire_time != null)
                    if ($util.Long)
                        (message.expire_time = $util.Long.fromValue(object.expire_time)).unsigned = false;
                    else if (typeof object.expire_time === "string")
                        message.expire_time = parseInt(object.expire_time, 10);
                    else if (typeof object.expire_time === "number")
                        message.expire_time = object.expire_time;
                    else if (typeof object.expire_time === "object")
                        message.expire_time = new $util.LongBits(object.expire_time.low >>> 0, object.expire_time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Frozen message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Account.Frozen
             * @static
             * @param {protocol.Account.Frozen} message Frozen
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Frozen.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.frozen_balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.frozen_balance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expire_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expire_time = options.longs === String ? "0" : 0;
                }
                if (message.frozen_balance != null && message.hasOwnProperty("frozen_balance"))
                    if (typeof message.frozen_balance === "number")
                        object.frozen_balance = options.longs === String ? String(message.frozen_balance) : message.frozen_balance;
                    else
                        object.frozen_balance = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_balance) : options.longs === Number ? new $util.LongBits(message.frozen_balance.low >>> 0, message.frozen_balance.high >>> 0).toNumber() : message.frozen_balance;
                if (message.expire_time != null && message.hasOwnProperty("expire_time"))
                    if (typeof message.expire_time === "number")
                        object.expire_time = options.longs === String ? String(message.expire_time) : message.expire_time;
                    else
                        object.expire_time = options.longs === String ? $util.Long.prototype.toString.call(message.expire_time) : options.longs === Number ? new $util.LongBits(message.expire_time.low >>> 0, message.expire_time.high >>> 0).toNumber() : message.expire_time;
                return object;
            };

            /**
             * Converts this Frozen to JSON.
             * @function toJSON
             * @memberof protocol.Account.Frozen
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Frozen.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Frozen;
        })();

        Account.AccountResource = (function() {

            /**
             * Properties of an AccountResource.
             * @memberof protocol.Account
             * @interface IAccountResource
             * @property {number|Long|null} [energy_usage] AccountResource energy_usage
             * @property {protocol.Account.IFrozen|null} [frozen_balance_for_energy] AccountResource frozen_balance_for_energy
             * @property {number|Long|null} [latest_consume_time_for_energy] AccountResource latest_consume_time_for_energy
             * @property {number|Long|null} [acquired_delegated_frozen_balance_for_energy] AccountResource acquired_delegated_frozen_balance_for_energy
             * @property {number|Long|null} [delegated_frozen_balance_for_energy] AccountResource delegated_frozen_balance_for_energy
             * @property {number|Long|null} [storage_limit] AccountResource storage_limit
             * @property {number|Long|null} [storage_usage] AccountResource storage_usage
             * @property {number|Long|null} [latest_exchange_storage_time] AccountResource latest_exchange_storage_time
             */

            /**
             * Constructs a new AccountResource.
             * @memberof protocol.Account
             * @classdesc Represents an AccountResource.
             * @implements IAccountResource
             * @constructor
             * @param {protocol.Account.IAccountResource=} [properties] Properties to set
             */
            function AccountResource(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AccountResource energy_usage.
             * @member {number|Long} energy_usage
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.energy_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource frozen_balance_for_energy.
             * @member {protocol.Account.IFrozen|null|undefined} frozen_balance_for_energy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.frozen_balance_for_energy = null;

            /**
             * AccountResource latest_consume_time_for_energy.
             * @member {number|Long} latest_consume_time_for_energy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.latest_consume_time_for_energy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource acquired_delegated_frozen_balance_for_energy.
             * @member {number|Long} acquired_delegated_frozen_balance_for_energy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.acquired_delegated_frozen_balance_for_energy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource delegated_frozen_balance_for_energy.
             * @member {number|Long} delegated_frozen_balance_for_energy
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.delegated_frozen_balance_for_energy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource storage_limit.
             * @member {number|Long} storage_limit
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.storage_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource storage_usage.
             * @member {number|Long} storage_usage
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.storage_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * AccountResource latest_exchange_storage_time.
             * @member {number|Long} latest_exchange_storage_time
             * @memberof protocol.Account.AccountResource
             * @instance
             */
            AccountResource.prototype.latest_exchange_storage_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new AccountResource instance using the specified properties.
             * @function create
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.IAccountResource=} [properties] Properties to set
             * @returns {protocol.Account.AccountResource} AccountResource instance
             */
            AccountResource.create = function create(properties) {
                return new AccountResource(properties);
            };

            /**
             * Encodes the specified AccountResource message. Does not implicitly {@link protocol.Account.AccountResource.verify|verify} messages.
             * @function encode
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.IAccountResource} message AccountResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountResource.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.energy_usage != null && message.hasOwnProperty("energy_usage"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.energy_usage);
                if (message.frozen_balance_for_energy != null && message.hasOwnProperty("frozen_balance_for_energy"))
                    $root.protocol.Account.Frozen.encode(message.frozen_balance_for_energy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.latest_consume_time_for_energy != null && message.hasOwnProperty("latest_consume_time_for_energy"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.latest_consume_time_for_energy);
                if (message.acquired_delegated_frozen_balance_for_energy != null && message.hasOwnProperty("acquired_delegated_frozen_balance_for_energy"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.acquired_delegated_frozen_balance_for_energy);
                if (message.delegated_frozen_balance_for_energy != null && message.hasOwnProperty("delegated_frozen_balance_for_energy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.delegated_frozen_balance_for_energy);
                if (message.storage_limit != null && message.hasOwnProperty("storage_limit"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.storage_limit);
                if (message.storage_usage != null && message.hasOwnProperty("storage_usage"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.storage_usage);
                if (message.latest_exchange_storage_time != null && message.hasOwnProperty("latest_exchange_storage_time"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.latest_exchange_storage_time);
                return writer;
            };

            /**
             * Encodes the specified AccountResource message, length delimited. Does not implicitly {@link protocol.Account.AccountResource.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.IAccountResource} message AccountResource message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AccountResource.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AccountResource message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Account.AccountResource} AccountResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountResource.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Account.AccountResource();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.energy_usage = reader.int64();
                        break;
                    case 2:
                        message.frozen_balance_for_energy = $root.protocol.Account.Frozen.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.latest_consume_time_for_energy = reader.int64();
                        break;
                    case 4:
                        message.acquired_delegated_frozen_balance_for_energy = reader.int64();
                        break;
                    case 5:
                        message.delegated_frozen_balance_for_energy = reader.int64();
                        break;
                    case 6:
                        message.storage_limit = reader.int64();
                        break;
                    case 7:
                        message.storage_usage = reader.int64();
                        break;
                    case 8:
                        message.latest_exchange_storage_time = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AccountResource message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Account.AccountResource} AccountResource
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AccountResource.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AccountResource message.
             * @function verify
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AccountResource.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.energy_usage != null && message.hasOwnProperty("energy_usage"))
                    if (!$util.isInteger(message.energy_usage) && !(message.energy_usage && $util.isInteger(message.energy_usage.low) && $util.isInteger(message.energy_usage.high)))
                        return "energy_usage: integer|Long expected";
                if (message.frozen_balance_for_energy != null && message.hasOwnProperty("frozen_balance_for_energy")) {
                    var error = $root.protocol.Account.Frozen.verify(message.frozen_balance_for_energy);
                    if (error)
                        return "frozen_balance_for_energy." + error;
                }
                if (message.latest_consume_time_for_energy != null && message.hasOwnProperty("latest_consume_time_for_energy"))
                    if (!$util.isInteger(message.latest_consume_time_for_energy) && !(message.latest_consume_time_for_energy && $util.isInteger(message.latest_consume_time_for_energy.low) && $util.isInteger(message.latest_consume_time_for_energy.high)))
                        return "latest_consume_time_for_energy: integer|Long expected";
                if (message.acquired_delegated_frozen_balance_for_energy != null && message.hasOwnProperty("acquired_delegated_frozen_balance_for_energy"))
                    if (!$util.isInteger(message.acquired_delegated_frozen_balance_for_energy) && !(message.acquired_delegated_frozen_balance_for_energy && $util.isInteger(message.acquired_delegated_frozen_balance_for_energy.low) && $util.isInteger(message.acquired_delegated_frozen_balance_for_energy.high)))
                        return "acquired_delegated_frozen_balance_for_energy: integer|Long expected";
                if (message.delegated_frozen_balance_for_energy != null && message.hasOwnProperty("delegated_frozen_balance_for_energy"))
                    if (!$util.isInteger(message.delegated_frozen_balance_for_energy) && !(message.delegated_frozen_balance_for_energy && $util.isInteger(message.delegated_frozen_balance_for_energy.low) && $util.isInteger(message.delegated_frozen_balance_for_energy.high)))
                        return "delegated_frozen_balance_for_energy: integer|Long expected";
                if (message.storage_limit != null && message.hasOwnProperty("storage_limit"))
                    if (!$util.isInteger(message.storage_limit) && !(message.storage_limit && $util.isInteger(message.storage_limit.low) && $util.isInteger(message.storage_limit.high)))
                        return "storage_limit: integer|Long expected";
                if (message.storage_usage != null && message.hasOwnProperty("storage_usage"))
                    if (!$util.isInteger(message.storage_usage) && !(message.storage_usage && $util.isInteger(message.storage_usage.low) && $util.isInteger(message.storage_usage.high)))
                        return "storage_usage: integer|Long expected";
                if (message.latest_exchange_storage_time != null && message.hasOwnProperty("latest_exchange_storage_time"))
                    if (!$util.isInteger(message.latest_exchange_storage_time) && !(message.latest_exchange_storage_time && $util.isInteger(message.latest_exchange_storage_time.low) && $util.isInteger(message.latest_exchange_storage_time.high)))
                        return "latest_exchange_storage_time: integer|Long expected";
                return null;
            };

            /**
             * Creates an AccountResource message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Account.AccountResource} AccountResource
             */
            AccountResource.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Account.AccountResource)
                    return object;
                var message = new $root.protocol.Account.AccountResource();
                if (object.energy_usage != null)
                    if ($util.Long)
                        (message.energy_usage = $util.Long.fromValue(object.energy_usage)).unsigned = false;
                    else if (typeof object.energy_usage === "string")
                        message.energy_usage = parseInt(object.energy_usage, 10);
                    else if (typeof object.energy_usage === "number")
                        message.energy_usage = object.energy_usage;
                    else if (typeof object.energy_usage === "object")
                        message.energy_usage = new $util.LongBits(object.energy_usage.low >>> 0, object.energy_usage.high >>> 0).toNumber();
                if (object.frozen_balance_for_energy != null) {
                    if (typeof object.frozen_balance_for_energy !== "object")
                        throw TypeError(".protocol.Account.AccountResource.frozen_balance_for_energy: object expected");
                    message.frozen_balance_for_energy = $root.protocol.Account.Frozen.fromObject(object.frozen_balance_for_energy);
                }
                if (object.latest_consume_time_for_energy != null)
                    if ($util.Long)
                        (message.latest_consume_time_for_energy = $util.Long.fromValue(object.latest_consume_time_for_energy)).unsigned = false;
                    else if (typeof object.latest_consume_time_for_energy === "string")
                        message.latest_consume_time_for_energy = parseInt(object.latest_consume_time_for_energy, 10);
                    else if (typeof object.latest_consume_time_for_energy === "number")
                        message.latest_consume_time_for_energy = object.latest_consume_time_for_energy;
                    else if (typeof object.latest_consume_time_for_energy === "object")
                        message.latest_consume_time_for_energy = new $util.LongBits(object.latest_consume_time_for_energy.low >>> 0, object.latest_consume_time_for_energy.high >>> 0).toNumber();
                if (object.acquired_delegated_frozen_balance_for_energy != null)
                    if ($util.Long)
                        (message.acquired_delegated_frozen_balance_for_energy = $util.Long.fromValue(object.acquired_delegated_frozen_balance_for_energy)).unsigned = false;
                    else if (typeof object.acquired_delegated_frozen_balance_for_energy === "string")
                        message.acquired_delegated_frozen_balance_for_energy = parseInt(object.acquired_delegated_frozen_balance_for_energy, 10);
                    else if (typeof object.acquired_delegated_frozen_balance_for_energy === "number")
                        message.acquired_delegated_frozen_balance_for_energy = object.acquired_delegated_frozen_balance_for_energy;
                    else if (typeof object.acquired_delegated_frozen_balance_for_energy === "object")
                        message.acquired_delegated_frozen_balance_for_energy = new $util.LongBits(object.acquired_delegated_frozen_balance_for_energy.low >>> 0, object.acquired_delegated_frozen_balance_for_energy.high >>> 0).toNumber();
                if (object.delegated_frozen_balance_for_energy != null)
                    if ($util.Long)
                        (message.delegated_frozen_balance_for_energy = $util.Long.fromValue(object.delegated_frozen_balance_for_energy)).unsigned = false;
                    else if (typeof object.delegated_frozen_balance_for_energy === "string")
                        message.delegated_frozen_balance_for_energy = parseInt(object.delegated_frozen_balance_for_energy, 10);
                    else if (typeof object.delegated_frozen_balance_for_energy === "number")
                        message.delegated_frozen_balance_for_energy = object.delegated_frozen_balance_for_energy;
                    else if (typeof object.delegated_frozen_balance_for_energy === "object")
                        message.delegated_frozen_balance_for_energy = new $util.LongBits(object.delegated_frozen_balance_for_energy.low >>> 0, object.delegated_frozen_balance_for_energy.high >>> 0).toNumber();
                if (object.storage_limit != null)
                    if ($util.Long)
                        (message.storage_limit = $util.Long.fromValue(object.storage_limit)).unsigned = false;
                    else if (typeof object.storage_limit === "string")
                        message.storage_limit = parseInt(object.storage_limit, 10);
                    else if (typeof object.storage_limit === "number")
                        message.storage_limit = object.storage_limit;
                    else if (typeof object.storage_limit === "object")
                        message.storage_limit = new $util.LongBits(object.storage_limit.low >>> 0, object.storage_limit.high >>> 0).toNumber();
                if (object.storage_usage != null)
                    if ($util.Long)
                        (message.storage_usage = $util.Long.fromValue(object.storage_usage)).unsigned = false;
                    else if (typeof object.storage_usage === "string")
                        message.storage_usage = parseInt(object.storage_usage, 10);
                    else if (typeof object.storage_usage === "number")
                        message.storage_usage = object.storage_usage;
                    else if (typeof object.storage_usage === "object")
                        message.storage_usage = new $util.LongBits(object.storage_usage.low >>> 0, object.storage_usage.high >>> 0).toNumber();
                if (object.latest_exchange_storage_time != null)
                    if ($util.Long)
                        (message.latest_exchange_storage_time = $util.Long.fromValue(object.latest_exchange_storage_time)).unsigned = false;
                    else if (typeof object.latest_exchange_storage_time === "string")
                        message.latest_exchange_storage_time = parseInt(object.latest_exchange_storage_time, 10);
                    else if (typeof object.latest_exchange_storage_time === "number")
                        message.latest_exchange_storage_time = object.latest_exchange_storage_time;
                    else if (typeof object.latest_exchange_storage_time === "object")
                        message.latest_exchange_storage_time = new $util.LongBits(object.latest_exchange_storage_time.low >>> 0, object.latest_exchange_storage_time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an AccountResource message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Account.AccountResource
             * @static
             * @param {protocol.Account.AccountResource} message AccountResource
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AccountResource.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.energy_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.energy_usage = options.longs === String ? "0" : 0;
                    object.frozen_balance_for_energy = null;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.latest_consume_time_for_energy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.latest_consume_time_for_energy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.acquired_delegated_frozen_balance_for_energy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.acquired_delegated_frozen_balance_for_energy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.delegated_frozen_balance_for_energy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.delegated_frozen_balance_for_energy = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storage_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storage_limit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.storage_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.storage_usage = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.latest_exchange_storage_time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.latest_exchange_storage_time = options.longs === String ? "0" : 0;
                }
                if (message.energy_usage != null && message.hasOwnProperty("energy_usage"))
                    if (typeof message.energy_usage === "number")
                        object.energy_usage = options.longs === String ? String(message.energy_usage) : message.energy_usage;
                    else
                        object.energy_usage = options.longs === String ? $util.Long.prototype.toString.call(message.energy_usage) : options.longs === Number ? new $util.LongBits(message.energy_usage.low >>> 0, message.energy_usage.high >>> 0).toNumber() : message.energy_usage;
                if (message.frozen_balance_for_energy != null && message.hasOwnProperty("frozen_balance_for_energy"))
                    object.frozen_balance_for_energy = $root.protocol.Account.Frozen.toObject(message.frozen_balance_for_energy, options);
                if (message.latest_consume_time_for_energy != null && message.hasOwnProperty("latest_consume_time_for_energy"))
                    if (typeof message.latest_consume_time_for_energy === "number")
                        object.latest_consume_time_for_energy = options.longs === String ? String(message.latest_consume_time_for_energy) : message.latest_consume_time_for_energy;
                    else
                        object.latest_consume_time_for_energy = options.longs === String ? $util.Long.prototype.toString.call(message.latest_consume_time_for_energy) : options.longs === Number ? new $util.LongBits(message.latest_consume_time_for_energy.low >>> 0, message.latest_consume_time_for_energy.high >>> 0).toNumber() : message.latest_consume_time_for_energy;
                if (message.acquired_delegated_frozen_balance_for_energy != null && message.hasOwnProperty("acquired_delegated_frozen_balance_for_energy"))
                    if (typeof message.acquired_delegated_frozen_balance_for_energy === "number")
                        object.acquired_delegated_frozen_balance_for_energy = options.longs === String ? String(message.acquired_delegated_frozen_balance_for_energy) : message.acquired_delegated_frozen_balance_for_energy;
                    else
                        object.acquired_delegated_frozen_balance_for_energy = options.longs === String ? $util.Long.prototype.toString.call(message.acquired_delegated_frozen_balance_for_energy) : options.longs === Number ? new $util.LongBits(message.acquired_delegated_frozen_balance_for_energy.low >>> 0, message.acquired_delegated_frozen_balance_for_energy.high >>> 0).toNumber() : message.acquired_delegated_frozen_balance_for_energy;
                if (message.delegated_frozen_balance_for_energy != null && message.hasOwnProperty("delegated_frozen_balance_for_energy"))
                    if (typeof message.delegated_frozen_balance_for_energy === "number")
                        object.delegated_frozen_balance_for_energy = options.longs === String ? String(message.delegated_frozen_balance_for_energy) : message.delegated_frozen_balance_for_energy;
                    else
                        object.delegated_frozen_balance_for_energy = options.longs === String ? $util.Long.prototype.toString.call(message.delegated_frozen_balance_for_energy) : options.longs === Number ? new $util.LongBits(message.delegated_frozen_balance_for_energy.low >>> 0, message.delegated_frozen_balance_for_energy.high >>> 0).toNumber() : message.delegated_frozen_balance_for_energy;
                if (message.storage_limit != null && message.hasOwnProperty("storage_limit"))
                    if (typeof message.storage_limit === "number")
                        object.storage_limit = options.longs === String ? String(message.storage_limit) : message.storage_limit;
                    else
                        object.storage_limit = options.longs === String ? $util.Long.prototype.toString.call(message.storage_limit) : options.longs === Number ? new $util.LongBits(message.storage_limit.low >>> 0, message.storage_limit.high >>> 0).toNumber() : message.storage_limit;
                if (message.storage_usage != null && message.hasOwnProperty("storage_usage"))
                    if (typeof message.storage_usage === "number")
                        object.storage_usage = options.longs === String ? String(message.storage_usage) : message.storage_usage;
                    else
                        object.storage_usage = options.longs === String ? $util.Long.prototype.toString.call(message.storage_usage) : options.longs === Number ? new $util.LongBits(message.storage_usage.low >>> 0, message.storage_usage.high >>> 0).toNumber() : message.storage_usage;
                if (message.latest_exchange_storage_time != null && message.hasOwnProperty("latest_exchange_storage_time"))
                    if (typeof message.latest_exchange_storage_time === "number")
                        object.latest_exchange_storage_time = options.longs === String ? String(message.latest_exchange_storage_time) : message.latest_exchange_storage_time;
                    else
                        object.latest_exchange_storage_time = options.longs === String ? $util.Long.prototype.toString.call(message.latest_exchange_storage_time) : options.longs === Number ? new $util.LongBits(message.latest_exchange_storage_time.low >>> 0, message.latest_exchange_storage_time.high >>> 0).toNumber() : message.latest_exchange_storage_time;
                return object;
            };

            /**
             * Converts this AccountResource to JSON.
             * @function toJSON
             * @memberof protocol.Account.AccountResource
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AccountResource.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return AccountResource;
        })();

        return Account;
    })();

    protocol.Key = (function() {

        /**
         * Properties of a Key.
         * @memberof protocol
         * @interface IKey
         * @property {Uint8Array|null} [address] Key address
         * @property {number|Long|null} [weight] Key weight
         */

        /**
         * Constructs a new Key.
         * @memberof protocol
         * @classdesc Represents a Key.
         * @implements IKey
         * @constructor
         * @param {protocol.IKey=} [properties] Properties to set
         */
        function Key(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Key address.
         * @member {Uint8Array} address
         * @memberof protocol.Key
         * @instance
         */
        Key.prototype.address = $util.newBuffer([]);

        /**
         * Key weight.
         * @member {number|Long} weight
         * @memberof protocol.Key
         * @instance
         */
        Key.prototype.weight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Key instance using the specified properties.
         * @function create
         * @memberof protocol.Key
         * @static
         * @param {protocol.IKey=} [properties] Properties to set
         * @returns {protocol.Key} Key instance
         */
        Key.create = function create(properties) {
            return new Key(properties);
        };

        /**
         * Encodes the specified Key message. Does not implicitly {@link protocol.Key.verify|verify} messages.
         * @function encode
         * @memberof protocol.Key
         * @static
         * @param {protocol.IKey} message Key message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.weight != null && message.hasOwnProperty("weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.weight);
            return writer;
        };

        /**
         * Encodes the specified Key message, length delimited. Does not implicitly {@link protocol.Key.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Key
         * @static
         * @param {protocol.IKey} message Key message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Key.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Key message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Key();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.weight = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Key message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Key
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Key} Key
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Key.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Key message.
         * @function verify
         * @memberof protocol.Key
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Key.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight) && !(message.weight && $util.isInteger(message.weight.low) && $util.isInteger(message.weight.high)))
                    return "weight: integer|Long expected";
            return null;
        };

        /**
         * Creates a Key message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Key
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Key} Key
         */
        Key.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Key)
                return object;
            var message = new $root.protocol.Key();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.weight != null)
                if ($util.Long)
                    (message.weight = $util.Long.fromValue(object.weight)).unsigned = false;
                else if (typeof object.weight === "string")
                    message.weight = parseInt(object.weight, 10);
                else if (typeof object.weight === "number")
                    message.weight = object.weight;
                else if (typeof object.weight === "object")
                    message.weight = new $util.LongBits(object.weight.low >>> 0, object.weight.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Key message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Key
         * @static
         * @param {protocol.Key} message Key
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Key.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.weight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.weight = options.longs === String ? "0" : 0;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (typeof message.weight === "number")
                    object.weight = options.longs === String ? String(message.weight) : message.weight;
                else
                    object.weight = options.longs === String ? $util.Long.prototype.toString.call(message.weight) : options.longs === Number ? new $util.LongBits(message.weight.low >>> 0, message.weight.high >>> 0).toNumber() : message.weight;
            return object;
        };

        /**
         * Converts this Key to JSON.
         * @function toJSON
         * @memberof protocol.Key
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Key.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Key;
    })();

    protocol.DelegatedResource = (function() {

        /**
         * Properties of a DelegatedResource.
         * @memberof protocol
         * @interface IDelegatedResource
         * @property {Uint8Array|null} [from] DelegatedResource from
         * @property {Uint8Array|null} [to] DelegatedResource to
         * @property {number|Long|null} [frozen_balance_for_bandwidth] DelegatedResource frozen_balance_for_bandwidth
         * @property {number|Long|null} [frozen_balance_for_energy] DelegatedResource frozen_balance_for_energy
         * @property {number|Long|null} [expire_time_for_bandwidth] DelegatedResource expire_time_for_bandwidth
         * @property {number|Long|null} [expire_time_for_energy] DelegatedResource expire_time_for_energy
         */

        /**
         * Constructs a new DelegatedResource.
         * @memberof protocol
         * @classdesc Represents a DelegatedResource.
         * @implements IDelegatedResource
         * @constructor
         * @param {protocol.IDelegatedResource=} [properties] Properties to set
         */
        function DelegatedResource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedResource from.
         * @member {Uint8Array} from
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.from = $util.newBuffer([]);

        /**
         * DelegatedResource to.
         * @member {Uint8Array} to
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.to = $util.newBuffer([]);

        /**
         * DelegatedResource frozen_balance_for_bandwidth.
         * @member {number|Long} frozen_balance_for_bandwidth
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.frozen_balance_for_bandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedResource frozen_balance_for_energy.
         * @member {number|Long} frozen_balance_for_energy
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.frozen_balance_for_energy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedResource expire_time_for_bandwidth.
         * @member {number|Long} expire_time_for_bandwidth
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.expire_time_for_bandwidth = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DelegatedResource expire_time_for_energy.
         * @member {number|Long} expire_time_for_energy
         * @memberof protocol.DelegatedResource
         * @instance
         */
        DelegatedResource.prototype.expire_time_for_energy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DelegatedResource instance using the specified properties.
         * @function create
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.IDelegatedResource=} [properties] Properties to set
         * @returns {protocol.DelegatedResource} DelegatedResource instance
         */
        DelegatedResource.create = function create(properties) {
            return new DelegatedResource(properties);
        };

        /**
         * Encodes the specified DelegatedResource message. Does not implicitly {@link protocol.DelegatedResource.verify|verify} messages.
         * @function encode
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.IDelegatedResource} message DelegatedResource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.from);
            if (message.to != null && message.hasOwnProperty("to"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.to);
            if (message.frozen_balance_for_bandwidth != null && message.hasOwnProperty("frozen_balance_for_bandwidth"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.frozen_balance_for_bandwidth);
            if (message.frozen_balance_for_energy != null && message.hasOwnProperty("frozen_balance_for_energy"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.frozen_balance_for_energy);
            if (message.expire_time_for_bandwidth != null && message.hasOwnProperty("expire_time_for_bandwidth"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expire_time_for_bandwidth);
            if (message.expire_time_for_energy != null && message.hasOwnProperty("expire_time_for_energy"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.expire_time_for_energy);
            return writer;
        };

        /**
         * Encodes the specified DelegatedResource message, length delimited. Does not implicitly {@link protocol.DelegatedResource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.IDelegatedResource} message DelegatedResource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedResource message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DelegatedResource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DelegatedResource} DelegatedResource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DelegatedResource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = reader.bytes();
                    break;
                case 2:
                    message.to = reader.bytes();
                    break;
                case 3:
                    message.frozen_balance_for_bandwidth = reader.int64();
                    break;
                case 4:
                    message.frozen_balance_for_energy = reader.int64();
                    break;
                case 5:
                    message.expire_time_for_bandwidth = reader.int64();
                    break;
                case 6:
                    message.expire_time_for_energy = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedResource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DelegatedResource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DelegatedResource} DelegatedResource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedResource message.
         * @function verify
         * @memberof protocol.DelegatedResource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedResource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!(message.from && typeof message.from.length === "number" || $util.isString(message.from)))
                    return "from: buffer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!(message.to && typeof message.to.length === "number" || $util.isString(message.to)))
                    return "to: buffer expected";
            if (message.frozen_balance_for_bandwidth != null && message.hasOwnProperty("frozen_balance_for_bandwidth"))
                if (!$util.isInteger(message.frozen_balance_for_bandwidth) && !(message.frozen_balance_for_bandwidth && $util.isInteger(message.frozen_balance_for_bandwidth.low) && $util.isInteger(message.frozen_balance_for_bandwidth.high)))
                    return "frozen_balance_for_bandwidth: integer|Long expected";
            if (message.frozen_balance_for_energy != null && message.hasOwnProperty("frozen_balance_for_energy"))
                if (!$util.isInteger(message.frozen_balance_for_energy) && !(message.frozen_balance_for_energy && $util.isInteger(message.frozen_balance_for_energy.low) && $util.isInteger(message.frozen_balance_for_energy.high)))
                    return "frozen_balance_for_energy: integer|Long expected";
            if (message.expire_time_for_bandwidth != null && message.hasOwnProperty("expire_time_for_bandwidth"))
                if (!$util.isInteger(message.expire_time_for_bandwidth) && !(message.expire_time_for_bandwidth && $util.isInteger(message.expire_time_for_bandwidth.low) && $util.isInteger(message.expire_time_for_bandwidth.high)))
                    return "expire_time_for_bandwidth: integer|Long expected";
            if (message.expire_time_for_energy != null && message.hasOwnProperty("expire_time_for_energy"))
                if (!$util.isInteger(message.expire_time_for_energy) && !(message.expire_time_for_energy && $util.isInteger(message.expire_time_for_energy.low) && $util.isInteger(message.expire_time_for_energy.high)))
                    return "expire_time_for_energy: integer|Long expected";
            return null;
        };

        /**
         * Creates a DelegatedResource message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DelegatedResource
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DelegatedResource} DelegatedResource
         */
        DelegatedResource.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DelegatedResource)
                return object;
            var message = new $root.protocol.DelegatedResource();
            if (object.from != null)
                if (typeof object.from === "string")
                    $util.base64.decode(object.from, message.from = $util.newBuffer($util.base64.length(object.from)), 0);
                else if (object.from.length)
                    message.from = object.from;
            if (object.to != null)
                if (typeof object.to === "string")
                    $util.base64.decode(object.to, message.to = $util.newBuffer($util.base64.length(object.to)), 0);
                else if (object.to.length)
                    message.to = object.to;
            if (object.frozen_balance_for_bandwidth != null)
                if ($util.Long)
                    (message.frozen_balance_for_bandwidth = $util.Long.fromValue(object.frozen_balance_for_bandwidth)).unsigned = false;
                else if (typeof object.frozen_balance_for_bandwidth === "string")
                    message.frozen_balance_for_bandwidth = parseInt(object.frozen_balance_for_bandwidth, 10);
                else if (typeof object.frozen_balance_for_bandwidth === "number")
                    message.frozen_balance_for_bandwidth = object.frozen_balance_for_bandwidth;
                else if (typeof object.frozen_balance_for_bandwidth === "object")
                    message.frozen_balance_for_bandwidth = new $util.LongBits(object.frozen_balance_for_bandwidth.low >>> 0, object.frozen_balance_for_bandwidth.high >>> 0).toNumber();
            if (object.frozen_balance_for_energy != null)
                if ($util.Long)
                    (message.frozen_balance_for_energy = $util.Long.fromValue(object.frozen_balance_for_energy)).unsigned = false;
                else if (typeof object.frozen_balance_for_energy === "string")
                    message.frozen_balance_for_energy = parseInt(object.frozen_balance_for_energy, 10);
                else if (typeof object.frozen_balance_for_energy === "number")
                    message.frozen_balance_for_energy = object.frozen_balance_for_energy;
                else if (typeof object.frozen_balance_for_energy === "object")
                    message.frozen_balance_for_energy = new $util.LongBits(object.frozen_balance_for_energy.low >>> 0, object.frozen_balance_for_energy.high >>> 0).toNumber();
            if (object.expire_time_for_bandwidth != null)
                if ($util.Long)
                    (message.expire_time_for_bandwidth = $util.Long.fromValue(object.expire_time_for_bandwidth)).unsigned = false;
                else if (typeof object.expire_time_for_bandwidth === "string")
                    message.expire_time_for_bandwidth = parseInt(object.expire_time_for_bandwidth, 10);
                else if (typeof object.expire_time_for_bandwidth === "number")
                    message.expire_time_for_bandwidth = object.expire_time_for_bandwidth;
                else if (typeof object.expire_time_for_bandwidth === "object")
                    message.expire_time_for_bandwidth = new $util.LongBits(object.expire_time_for_bandwidth.low >>> 0, object.expire_time_for_bandwidth.high >>> 0).toNumber();
            if (object.expire_time_for_energy != null)
                if ($util.Long)
                    (message.expire_time_for_energy = $util.Long.fromValue(object.expire_time_for_energy)).unsigned = false;
                else if (typeof object.expire_time_for_energy === "string")
                    message.expire_time_for_energy = parseInt(object.expire_time_for_energy, 10);
                else if (typeof object.expire_time_for_energy === "number")
                    message.expire_time_for_energy = object.expire_time_for_energy;
                else if (typeof object.expire_time_for_energy === "object")
                    message.expire_time_for_energy = new $util.LongBits(object.expire_time_for_energy.low >>> 0, object.expire_time_for_energy.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DelegatedResource message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DelegatedResource
         * @static
         * @param {protocol.DelegatedResource} message DelegatedResource
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedResource.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.from = "";
                else {
                    object.from = [];
                    if (options.bytes !== Array)
                        object.from = $util.newBuffer(object.from);
                }
                if (options.bytes === String)
                    object.to = "";
                else {
                    object.to = [];
                    if (options.bytes !== Array)
                        object.to = $util.newBuffer(object.to);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozen_balance_for_bandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozen_balance_for_bandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.frozen_balance_for_energy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.frozen_balance_for_energy = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expire_time_for_bandwidth = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expire_time_for_bandwidth = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.expire_time_for_energy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expire_time_for_energy = options.longs === String ? "0" : 0;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = options.bytes === String ? $util.base64.encode(message.from, 0, message.from.length) : options.bytes === Array ? Array.prototype.slice.call(message.from) : message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = options.bytes === String ? $util.base64.encode(message.to, 0, message.to.length) : options.bytes === Array ? Array.prototype.slice.call(message.to) : message.to;
            if (message.frozen_balance_for_bandwidth != null && message.hasOwnProperty("frozen_balance_for_bandwidth"))
                if (typeof message.frozen_balance_for_bandwidth === "number")
                    object.frozen_balance_for_bandwidth = options.longs === String ? String(message.frozen_balance_for_bandwidth) : message.frozen_balance_for_bandwidth;
                else
                    object.frozen_balance_for_bandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_balance_for_bandwidth) : options.longs === Number ? new $util.LongBits(message.frozen_balance_for_bandwidth.low >>> 0, message.frozen_balance_for_bandwidth.high >>> 0).toNumber() : message.frozen_balance_for_bandwidth;
            if (message.frozen_balance_for_energy != null && message.hasOwnProperty("frozen_balance_for_energy"))
                if (typeof message.frozen_balance_for_energy === "number")
                    object.frozen_balance_for_energy = options.longs === String ? String(message.frozen_balance_for_energy) : message.frozen_balance_for_energy;
                else
                    object.frozen_balance_for_energy = options.longs === String ? $util.Long.prototype.toString.call(message.frozen_balance_for_energy) : options.longs === Number ? new $util.LongBits(message.frozen_balance_for_energy.low >>> 0, message.frozen_balance_for_energy.high >>> 0).toNumber() : message.frozen_balance_for_energy;
            if (message.expire_time_for_bandwidth != null && message.hasOwnProperty("expire_time_for_bandwidth"))
                if (typeof message.expire_time_for_bandwidth === "number")
                    object.expire_time_for_bandwidth = options.longs === String ? String(message.expire_time_for_bandwidth) : message.expire_time_for_bandwidth;
                else
                    object.expire_time_for_bandwidth = options.longs === String ? $util.Long.prototype.toString.call(message.expire_time_for_bandwidth) : options.longs === Number ? new $util.LongBits(message.expire_time_for_bandwidth.low >>> 0, message.expire_time_for_bandwidth.high >>> 0).toNumber() : message.expire_time_for_bandwidth;
            if (message.expire_time_for_energy != null && message.hasOwnProperty("expire_time_for_energy"))
                if (typeof message.expire_time_for_energy === "number")
                    object.expire_time_for_energy = options.longs === String ? String(message.expire_time_for_energy) : message.expire_time_for_energy;
                else
                    object.expire_time_for_energy = options.longs === String ? $util.Long.prototype.toString.call(message.expire_time_for_energy) : options.longs === Number ? new $util.LongBits(message.expire_time_for_energy.low >>> 0, message.expire_time_for_energy.high >>> 0).toNumber() : message.expire_time_for_energy;
            return object;
        };

        /**
         * Converts this DelegatedResource to JSON.
         * @function toJSON
         * @memberof protocol.DelegatedResource
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedResource.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedResource;
    })();

    protocol.authority = (function() {

        /**
         * Properties of an authority.
         * @memberof protocol
         * @interface Iauthority
         * @property {protocol.IAccountId|null} [account] authority account
         * @property {Uint8Array|null} [permission_name] authority permission_name
         */

        /**
         * Constructs a new authority.
         * @memberof protocol
         * @classdesc Represents an authority.
         * @implements Iauthority
         * @constructor
         * @param {protocol.Iauthority=} [properties] Properties to set
         */
        function authority(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * authority account.
         * @member {protocol.IAccountId|null|undefined} account
         * @memberof protocol.authority
         * @instance
         */
        authority.prototype.account = null;

        /**
         * authority permission_name.
         * @member {Uint8Array} permission_name
         * @memberof protocol.authority
         * @instance
         */
        authority.prototype.permission_name = $util.newBuffer([]);

        /**
         * Creates a new authority instance using the specified properties.
         * @function create
         * @memberof protocol.authority
         * @static
         * @param {protocol.Iauthority=} [properties] Properties to set
         * @returns {protocol.authority} authority instance
         */
        authority.create = function create(properties) {
            return new authority(properties);
        };

        /**
         * Encodes the specified authority message. Does not implicitly {@link protocol.authority.verify|verify} messages.
         * @function encode
         * @memberof protocol.authority
         * @static
         * @param {protocol.Iauthority} message authority message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        authority.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                $root.protocol.AccountId.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.permission_name != null && message.hasOwnProperty("permission_name"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.permission_name);
            return writer;
        };

        /**
         * Encodes the specified authority message, length delimited. Does not implicitly {@link protocol.authority.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.authority
         * @static
         * @param {protocol.Iauthority} message authority message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        authority.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an authority message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.authority
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.authority} authority
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        authority.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.authority();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = $root.protocol.AccountId.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.permission_name = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an authority message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.authority
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.authority} authority
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        authority.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an authority message.
         * @function verify
         * @memberof protocol.authority
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        authority.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account")) {
                var error = $root.protocol.AccountId.verify(message.account);
                if (error)
                    return "account." + error;
            }
            if (message.permission_name != null && message.hasOwnProperty("permission_name"))
                if (!(message.permission_name && typeof message.permission_name.length === "number" || $util.isString(message.permission_name)))
                    return "permission_name: buffer expected";
            return null;
        };

        /**
         * Creates an authority message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.authority
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.authority} authority
         */
        authority.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.authority)
                return object;
            var message = new $root.protocol.authority();
            if (object.account != null) {
                if (typeof object.account !== "object")
                    throw TypeError(".protocol.authority.account: object expected");
                message.account = $root.protocol.AccountId.fromObject(object.account);
            }
            if (object.permission_name != null)
                if (typeof object.permission_name === "string")
                    $util.base64.decode(object.permission_name, message.permission_name = $util.newBuffer($util.base64.length(object.permission_name)), 0);
                else if (object.permission_name.length)
                    message.permission_name = object.permission_name;
            return message;
        };

        /**
         * Creates a plain object from an authority message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.authority
         * @static
         * @param {protocol.authority} message authority
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        authority.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.account = null;
                if (options.bytes === String)
                    object.permission_name = "";
                else {
                    object.permission_name = [];
                    if (options.bytes !== Array)
                        object.permission_name = $util.newBuffer(object.permission_name);
                }
            }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = $root.protocol.AccountId.toObject(message.account, options);
            if (message.permission_name != null && message.hasOwnProperty("permission_name"))
                object.permission_name = options.bytes === String ? $util.base64.encode(message.permission_name, 0, message.permission_name.length) : options.bytes === Array ? Array.prototype.slice.call(message.permission_name) : message.permission_name;
            return object;
        };

        /**
         * Converts this authority to JSON.
         * @function toJSON
         * @memberof protocol.authority
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        authority.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return authority;
    })();

    protocol.Permission = (function() {

        /**
         * Properties of a Permission.
         * @memberof protocol
         * @interface IPermission
         * @property {protocol.Permission.PermissionType|null} [type] Permission type
         * @property {number|null} [id] Permission id
         * @property {string|null} [permission_name] Permission permission_name
         * @property {number|Long|null} [threshold] Permission threshold
         * @property {number|null} [parent_id] Permission parent_id
         * @property {Uint8Array|null} [operations] Permission operations
         * @property {Array.<protocol.IKey>|null} [keys] Permission keys
         */

        /**
         * Constructs a new Permission.
         * @memberof protocol
         * @classdesc Represents a Permission.
         * @implements IPermission
         * @constructor
         * @param {protocol.IPermission=} [properties] Properties to set
         */
        function Permission(properties) {
            this.keys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Permission type.
         * @member {protocol.Permission.PermissionType} type
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.type = 0;

        /**
         * Permission id.
         * @member {number} id
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.id = 0;

        /**
         * Permission permission_name.
         * @member {string} permission_name
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.permission_name = "";

        /**
         * Permission threshold.
         * @member {number|Long} threshold
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.threshold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Permission parent_id.
         * @member {number} parent_id
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.parent_id = 0;

        /**
         * Permission operations.
         * @member {Uint8Array} operations
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.operations = $util.newBuffer([]);

        /**
         * Permission keys.
         * @member {Array.<protocol.IKey>} keys
         * @memberof protocol.Permission
         * @instance
         */
        Permission.prototype.keys = $util.emptyArray;

        /**
         * Creates a new Permission instance using the specified properties.
         * @function create
         * @memberof protocol.Permission
         * @static
         * @param {protocol.IPermission=} [properties] Properties to set
         * @returns {protocol.Permission} Permission instance
         */
        Permission.create = function create(properties) {
            return new Permission(properties);
        };

        /**
         * Encodes the specified Permission message. Does not implicitly {@link protocol.Permission.verify|verify} messages.
         * @function encode
         * @memberof protocol.Permission
         * @static
         * @param {protocol.IPermission} message Permission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.permission_name != null && message.hasOwnProperty("permission_name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.permission_name);
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.threshold);
            if (message.parent_id != null && message.hasOwnProperty("parent_id"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.parent_id);
            if (message.operations != null && message.hasOwnProperty("operations"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.operations);
            if (message.keys != null && message.keys.length)
                for (var i = 0; i < message.keys.length; ++i)
                    $root.protocol.Key.encode(message.keys[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Permission message, length delimited. Does not implicitly {@link protocol.Permission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Permission
         * @static
         * @param {protocol.IPermission} message Permission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Permission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Permission message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Permission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Permission} Permission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Permission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.int32();
                    break;
                case 3:
                    message.permission_name = reader.string();
                    break;
                case 4:
                    message.threshold = reader.int64();
                    break;
                case 5:
                    message.parent_id = reader.int32();
                    break;
                case 6:
                    message.operations = reader.bytes();
                    break;
                case 7:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.protocol.Key.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Permission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Permission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Permission} Permission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Permission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Permission message.
         * @function verify
         * @memberof protocol.Permission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Permission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.permission_name != null && message.hasOwnProperty("permission_name"))
                if (!$util.isString(message.permission_name))
                    return "permission_name: string expected";
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (!$util.isInteger(message.threshold) && !(message.threshold && $util.isInteger(message.threshold.low) && $util.isInteger(message.threshold.high)))
                    return "threshold: integer|Long expected";
            if (message.parent_id != null && message.hasOwnProperty("parent_id"))
                if (!$util.isInteger(message.parent_id))
                    return "parent_id: integer expected";
            if (message.operations != null && message.hasOwnProperty("operations"))
                if (!(message.operations && typeof message.operations.length === "number" || $util.isString(message.operations)))
                    return "operations: buffer expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                if (!Array.isArray(message.keys))
                    return "keys: array expected";
                for (var i = 0; i < message.keys.length; ++i) {
                    var error = $root.protocol.Key.verify(message.keys[i]);
                    if (error)
                        return "keys." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Permission message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Permission
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Permission} Permission
         */
        Permission.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Permission)
                return object;
            var message = new $root.protocol.Permission();
            switch (object.type) {
            case "Owner":
            case 0:
                message.type = 0;
                break;
            case "Witness":
            case 1:
                message.type = 1;
                break;
            case "Active":
            case 2:
                message.type = 2;
                break;
            }
            if (object.id != null)
                message.id = object.id | 0;
            if (object.permission_name != null)
                message.permission_name = String(object.permission_name);
            if (object.threshold != null)
                if ($util.Long)
                    (message.threshold = $util.Long.fromValue(object.threshold)).unsigned = false;
                else if (typeof object.threshold === "string")
                    message.threshold = parseInt(object.threshold, 10);
                else if (typeof object.threshold === "number")
                    message.threshold = object.threshold;
                else if (typeof object.threshold === "object")
                    message.threshold = new $util.LongBits(object.threshold.low >>> 0, object.threshold.high >>> 0).toNumber();
            if (object.parent_id != null)
                message.parent_id = object.parent_id | 0;
            if (object.operations != null)
                if (typeof object.operations === "string")
                    $util.base64.decode(object.operations, message.operations = $util.newBuffer($util.base64.length(object.operations)), 0);
                else if (object.operations.length)
                    message.operations = object.operations;
            if (object.keys) {
                if (!Array.isArray(object.keys))
                    throw TypeError(".protocol.Permission.keys: array expected");
                message.keys = [];
                for (var i = 0; i < object.keys.length; ++i) {
                    if (typeof object.keys[i] !== "object")
                        throw TypeError(".protocol.Permission.keys: object expected");
                    message.keys[i] = $root.protocol.Key.fromObject(object.keys[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Permission message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Permission
         * @static
         * @param {protocol.Permission} message Permission
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Permission.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.keys = [];
            if (options.defaults) {
                object.type = options.enums === String ? "Owner" : 0;
                object.id = 0;
                object.permission_name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.threshold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.threshold = options.longs === String ? "0" : 0;
                object.parent_id = 0;
                if (options.bytes === String)
                    object.operations = "";
                else {
                    object.operations = [];
                    if (options.bytes !== Array)
                        object.operations = $util.newBuffer(object.operations);
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Permission.PermissionType[message.type] : message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.permission_name != null && message.hasOwnProperty("permission_name"))
                object.permission_name = message.permission_name;
            if (message.threshold != null && message.hasOwnProperty("threshold"))
                if (typeof message.threshold === "number")
                    object.threshold = options.longs === String ? String(message.threshold) : message.threshold;
                else
                    object.threshold = options.longs === String ? $util.Long.prototype.toString.call(message.threshold) : options.longs === Number ? new $util.LongBits(message.threshold.low >>> 0, message.threshold.high >>> 0).toNumber() : message.threshold;
            if (message.parent_id != null && message.hasOwnProperty("parent_id"))
                object.parent_id = message.parent_id;
            if (message.operations != null && message.hasOwnProperty("operations"))
                object.operations = options.bytes === String ? $util.base64.encode(message.operations, 0, message.operations.length) : options.bytes === Array ? Array.prototype.slice.call(message.operations) : message.operations;
            if (message.keys && message.keys.length) {
                object.keys = [];
                for (var j = 0; j < message.keys.length; ++j)
                    object.keys[j] = $root.protocol.Key.toObject(message.keys[j], options);
            }
            return object;
        };

        /**
         * Converts this Permission to JSON.
         * @function toJSON
         * @memberof protocol.Permission
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Permission.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PermissionType enum.
         * @name protocol.Permission.PermissionType
         * @enum {string}
         * @property {number} Owner=0 Owner value
         * @property {number} Witness=1 Witness value
         * @property {number} Active=2 Active value
         */
        Permission.PermissionType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Owner"] = 0;
            values[valuesById[1] = "Witness"] = 1;
            values[valuesById[2] = "Active"] = 2;
            return values;
        })();

        return Permission;
    })();

    protocol.Witness = (function() {

        /**
         * Properties of a Witness.
         * @memberof protocol
         * @interface IWitness
         * @property {Uint8Array|null} [address] Witness address
         * @property {number|Long|null} [voteCount] Witness voteCount
         * @property {Uint8Array|null} [pubKey] Witness pubKey
         * @property {string|null} [url] Witness url
         * @property {number|Long|null} [totalProduced] Witness totalProduced
         * @property {number|Long|null} [totalMissed] Witness totalMissed
         * @property {number|Long|null} [latestBlockNum] Witness latestBlockNum
         * @property {number|Long|null} [latestSlotNum] Witness latestSlotNum
         * @property {boolean|null} [isJobs] Witness isJobs
         */

        /**
         * Constructs a new Witness.
         * @memberof protocol
         * @classdesc Represents a Witness.
         * @implements IWitness
         * @constructor
         * @param {protocol.IWitness=} [properties] Properties to set
         */
        function Witness(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Witness address.
         * @member {Uint8Array} address
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.address = $util.newBuffer([]);

        /**
         * Witness voteCount.
         * @member {number|Long} voteCount
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.voteCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness pubKey.
         * @member {Uint8Array} pubKey
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.pubKey = $util.newBuffer([]);

        /**
         * Witness url.
         * @member {string} url
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.url = "";

        /**
         * Witness totalProduced.
         * @member {number|Long} totalProduced
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.totalProduced = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness totalMissed.
         * @member {number|Long} totalMissed
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.totalMissed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness latestBlockNum.
         * @member {number|Long} latestBlockNum
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.latestBlockNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness latestSlotNum.
         * @member {number|Long} latestSlotNum
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.latestSlotNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Witness isJobs.
         * @member {boolean} isJobs
         * @memberof protocol.Witness
         * @instance
         */
        Witness.prototype.isJobs = false;

        /**
         * Creates a new Witness instance using the specified properties.
         * @function create
         * @memberof protocol.Witness
         * @static
         * @param {protocol.IWitness=} [properties] Properties to set
         * @returns {protocol.Witness} Witness instance
         */
        Witness.create = function create(properties) {
            return new Witness(properties);
        };

        /**
         * Encodes the specified Witness message. Does not implicitly {@link protocol.Witness.verify|verify} messages.
         * @function encode
         * @memberof protocol.Witness
         * @static
         * @param {protocol.IWitness} message Witness message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Witness.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.voteCount);
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pubKey);
            if (message.url != null && message.hasOwnProperty("url"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.totalProduced);
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalMissed);
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.latestBlockNum);
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.latestSlotNum);
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isJobs);
            return writer;
        };

        /**
         * Encodes the specified Witness message, length delimited. Does not implicitly {@link protocol.Witness.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Witness
         * @static
         * @param {protocol.IWitness} message Witness message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Witness.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Witness message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Witness
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Witness} Witness
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Witness.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Witness();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    message.voteCount = reader.int64();
                    break;
                case 3:
                    message.pubKey = reader.bytes();
                    break;
                case 4:
                    message.url = reader.string();
                    break;
                case 5:
                    message.totalProduced = reader.int64();
                    break;
                case 6:
                    message.totalMissed = reader.int64();
                    break;
                case 7:
                    message.latestBlockNum = reader.int64();
                    break;
                case 8:
                    message.latestSlotNum = reader.int64();
                    break;
                case 9:
                    message.isJobs = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Witness message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Witness
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Witness} Witness
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Witness.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Witness message.
         * @function verify
         * @memberof protocol.Witness
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Witness.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (!$util.isInteger(message.voteCount) && !(message.voteCount && $util.isInteger(message.voteCount.low) && $util.isInteger(message.voteCount.high)))
                    return "voteCount: integer|Long expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                    return "pubKey: buffer expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                if (!$util.isInteger(message.totalProduced) && !(message.totalProduced && $util.isInteger(message.totalProduced.low) && $util.isInteger(message.totalProduced.high)))
                    return "totalProduced: integer|Long expected";
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                if (!$util.isInteger(message.totalMissed) && !(message.totalMissed && $util.isInteger(message.totalMissed.low) && $util.isInteger(message.totalMissed.high)))
                    return "totalMissed: integer|Long expected";
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                if (!$util.isInteger(message.latestBlockNum) && !(message.latestBlockNum && $util.isInteger(message.latestBlockNum.low) && $util.isInteger(message.latestBlockNum.high)))
                    return "latestBlockNum: integer|Long expected";
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                if (!$util.isInteger(message.latestSlotNum) && !(message.latestSlotNum && $util.isInteger(message.latestSlotNum.low) && $util.isInteger(message.latestSlotNum.high)))
                    return "latestSlotNum: integer|Long expected";
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                if (typeof message.isJobs !== "boolean")
                    return "isJobs: boolean expected";
            return null;
        };

        /**
         * Creates a Witness message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Witness
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Witness} Witness
         */
        Witness.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Witness)
                return object;
            var message = new $root.protocol.Witness();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.voteCount != null)
                if ($util.Long)
                    (message.voteCount = $util.Long.fromValue(object.voteCount)).unsigned = false;
                else if (typeof object.voteCount === "string")
                    message.voteCount = parseInt(object.voteCount, 10);
                else if (typeof object.voteCount === "number")
                    message.voteCount = object.voteCount;
                else if (typeof object.voteCount === "object")
                    message.voteCount = new $util.LongBits(object.voteCount.low >>> 0, object.voteCount.high >>> 0).toNumber();
            if (object.pubKey != null)
                if (typeof object.pubKey === "string")
                    $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                else if (object.pubKey.length)
                    message.pubKey = object.pubKey;
            if (object.url != null)
                message.url = String(object.url);
            if (object.totalProduced != null)
                if ($util.Long)
                    (message.totalProduced = $util.Long.fromValue(object.totalProduced)).unsigned = false;
                else if (typeof object.totalProduced === "string")
                    message.totalProduced = parseInt(object.totalProduced, 10);
                else if (typeof object.totalProduced === "number")
                    message.totalProduced = object.totalProduced;
                else if (typeof object.totalProduced === "object")
                    message.totalProduced = new $util.LongBits(object.totalProduced.low >>> 0, object.totalProduced.high >>> 0).toNumber();
            if (object.totalMissed != null)
                if ($util.Long)
                    (message.totalMissed = $util.Long.fromValue(object.totalMissed)).unsigned = false;
                else if (typeof object.totalMissed === "string")
                    message.totalMissed = parseInt(object.totalMissed, 10);
                else if (typeof object.totalMissed === "number")
                    message.totalMissed = object.totalMissed;
                else if (typeof object.totalMissed === "object")
                    message.totalMissed = new $util.LongBits(object.totalMissed.low >>> 0, object.totalMissed.high >>> 0).toNumber();
            if (object.latestBlockNum != null)
                if ($util.Long)
                    (message.latestBlockNum = $util.Long.fromValue(object.latestBlockNum)).unsigned = false;
                else if (typeof object.latestBlockNum === "string")
                    message.latestBlockNum = parseInt(object.latestBlockNum, 10);
                else if (typeof object.latestBlockNum === "number")
                    message.latestBlockNum = object.latestBlockNum;
                else if (typeof object.latestBlockNum === "object")
                    message.latestBlockNum = new $util.LongBits(object.latestBlockNum.low >>> 0, object.latestBlockNum.high >>> 0).toNumber();
            if (object.latestSlotNum != null)
                if ($util.Long)
                    (message.latestSlotNum = $util.Long.fromValue(object.latestSlotNum)).unsigned = false;
                else if (typeof object.latestSlotNum === "string")
                    message.latestSlotNum = parseInt(object.latestSlotNum, 10);
                else if (typeof object.latestSlotNum === "number")
                    message.latestSlotNum = object.latestSlotNum;
                else if (typeof object.latestSlotNum === "object")
                    message.latestSlotNum = new $util.LongBits(object.latestSlotNum.low >>> 0, object.latestSlotNum.high >>> 0).toNumber();
            if (object.isJobs != null)
                message.isJobs = Boolean(object.isJobs);
            return message;
        };

        /**
         * Creates a plain object from a Witness message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Witness
         * @static
         * @param {protocol.Witness} message Witness
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Witness.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.voteCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.voteCount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.pubKey = "";
                else {
                    object.pubKey = [];
                    if (options.bytes !== Array)
                        object.pubKey = $util.newBuffer(object.pubKey);
                }
                object.url = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalProduced = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalProduced = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalMissed = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalMissed = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestBlockNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestBlockNum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.latestSlotNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.latestSlotNum = options.longs === String ? "0" : 0;
                object.isJobs = false;
            }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                if (typeof message.voteCount === "number")
                    object.voteCount = options.longs === String ? String(message.voteCount) : message.voteCount;
                else
                    object.voteCount = options.longs === String ? $util.Long.prototype.toString.call(message.voteCount) : options.longs === Number ? new $util.LongBits(message.voteCount.low >>> 0, message.voteCount.high >>> 0).toNumber() : message.voteCount;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            if (message.totalProduced != null && message.hasOwnProperty("totalProduced"))
                if (typeof message.totalProduced === "number")
                    object.totalProduced = options.longs === String ? String(message.totalProduced) : message.totalProduced;
                else
                    object.totalProduced = options.longs === String ? $util.Long.prototype.toString.call(message.totalProduced) : options.longs === Number ? new $util.LongBits(message.totalProduced.low >>> 0, message.totalProduced.high >>> 0).toNumber() : message.totalProduced;
            if (message.totalMissed != null && message.hasOwnProperty("totalMissed"))
                if (typeof message.totalMissed === "number")
                    object.totalMissed = options.longs === String ? String(message.totalMissed) : message.totalMissed;
                else
                    object.totalMissed = options.longs === String ? $util.Long.prototype.toString.call(message.totalMissed) : options.longs === Number ? new $util.LongBits(message.totalMissed.low >>> 0, message.totalMissed.high >>> 0).toNumber() : message.totalMissed;
            if (message.latestBlockNum != null && message.hasOwnProperty("latestBlockNum"))
                if (typeof message.latestBlockNum === "number")
                    object.latestBlockNum = options.longs === String ? String(message.latestBlockNum) : message.latestBlockNum;
                else
                    object.latestBlockNum = options.longs === String ? $util.Long.prototype.toString.call(message.latestBlockNum) : options.longs === Number ? new $util.LongBits(message.latestBlockNum.low >>> 0, message.latestBlockNum.high >>> 0).toNumber() : message.latestBlockNum;
            if (message.latestSlotNum != null && message.hasOwnProperty("latestSlotNum"))
                if (typeof message.latestSlotNum === "number")
                    object.latestSlotNum = options.longs === String ? String(message.latestSlotNum) : message.latestSlotNum;
                else
                    object.latestSlotNum = options.longs === String ? $util.Long.prototype.toString.call(message.latestSlotNum) : options.longs === Number ? new $util.LongBits(message.latestSlotNum.low >>> 0, message.latestSlotNum.high >>> 0).toNumber() : message.latestSlotNum;
            if (message.isJobs != null && message.hasOwnProperty("isJobs"))
                object.isJobs = message.isJobs;
            return object;
        };

        /**
         * Converts this Witness to JSON.
         * @function toJSON
         * @memberof protocol.Witness
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Witness.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Witness;
    })();

    protocol.Votes = (function() {

        /**
         * Properties of a Votes.
         * @memberof protocol
         * @interface IVotes
         * @property {Uint8Array|null} [address] Votes address
         * @property {Array.<protocol.IVote>|null} [old_votes] Votes old_votes
         * @property {Array.<protocol.IVote>|null} [new_votes] Votes new_votes
         */

        /**
         * Constructs a new Votes.
         * @memberof protocol
         * @classdesc Represents a Votes.
         * @implements IVotes
         * @constructor
         * @param {protocol.IVotes=} [properties] Properties to set
         */
        function Votes(properties) {
            this.old_votes = [];
            this.new_votes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Votes address.
         * @member {Uint8Array} address
         * @memberof protocol.Votes
         * @instance
         */
        Votes.prototype.address = $util.newBuffer([]);

        /**
         * Votes old_votes.
         * @member {Array.<protocol.IVote>} old_votes
         * @memberof protocol.Votes
         * @instance
         */
        Votes.prototype.old_votes = $util.emptyArray;

        /**
         * Votes new_votes.
         * @member {Array.<protocol.IVote>} new_votes
         * @memberof protocol.Votes
         * @instance
         */
        Votes.prototype.new_votes = $util.emptyArray;

        /**
         * Creates a new Votes instance using the specified properties.
         * @function create
         * @memberof protocol.Votes
         * @static
         * @param {protocol.IVotes=} [properties] Properties to set
         * @returns {protocol.Votes} Votes instance
         */
        Votes.create = function create(properties) {
            return new Votes(properties);
        };

        /**
         * Encodes the specified Votes message. Does not implicitly {@link protocol.Votes.verify|verify} messages.
         * @function encode
         * @memberof protocol.Votes
         * @static
         * @param {protocol.IVotes} message Votes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Votes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
            if (message.old_votes != null && message.old_votes.length)
                for (var i = 0; i < message.old_votes.length; ++i)
                    $root.protocol.Vote.encode(message.old_votes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.new_votes != null && message.new_votes.length)
                for (var i = 0; i < message.new_votes.length; ++i)
                    $root.protocol.Vote.encode(message.new_votes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Votes message, length delimited. Does not implicitly {@link protocol.Votes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Votes
         * @static
         * @param {protocol.IVotes} message Votes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Votes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Votes message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Votes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Votes} Votes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Votes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Votes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.bytes();
                    break;
                case 2:
                    if (!(message.old_votes && message.old_votes.length))
                        message.old_votes = [];
                    message.old_votes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.new_votes && message.new_votes.length))
                        message.new_votes = [];
                    message.new_votes.push($root.protocol.Vote.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Votes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Votes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Votes} Votes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Votes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Votes message.
         * @function verify
         * @memberof protocol.Votes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Votes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                    return "address: buffer expected";
            if (message.old_votes != null && message.hasOwnProperty("old_votes")) {
                if (!Array.isArray(message.old_votes))
                    return "old_votes: array expected";
                for (var i = 0; i < message.old_votes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.old_votes[i]);
                    if (error)
                        return "old_votes." + error;
                }
            }
            if (message.new_votes != null && message.hasOwnProperty("new_votes")) {
                if (!Array.isArray(message.new_votes))
                    return "new_votes: array expected";
                for (var i = 0; i < message.new_votes.length; ++i) {
                    var error = $root.protocol.Vote.verify(message.new_votes[i]);
                    if (error)
                        return "new_votes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Votes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Votes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Votes} Votes
         */
        Votes.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Votes)
                return object;
            var message = new $root.protocol.Votes();
            if (object.address != null)
                if (typeof object.address === "string")
                    $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                else if (object.address.length)
                    message.address = object.address;
            if (object.old_votes) {
                if (!Array.isArray(object.old_votes))
                    throw TypeError(".protocol.Votes.old_votes: array expected");
                message.old_votes = [];
                for (var i = 0; i < object.old_votes.length; ++i) {
                    if (typeof object.old_votes[i] !== "object")
                        throw TypeError(".protocol.Votes.old_votes: object expected");
                    message.old_votes[i] = $root.protocol.Vote.fromObject(object.old_votes[i]);
                }
            }
            if (object.new_votes) {
                if (!Array.isArray(object.new_votes))
                    throw TypeError(".protocol.Votes.new_votes: array expected");
                message.new_votes = [];
                for (var i = 0; i < object.new_votes.length; ++i) {
                    if (typeof object.new_votes[i] !== "object")
                        throw TypeError(".protocol.Votes.new_votes: object expected");
                    message.new_votes[i] = $root.protocol.Vote.fromObject(object.new_votes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Votes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Votes
         * @static
         * @param {protocol.Votes} message Votes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Votes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.old_votes = [];
                object.new_votes = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.address = "";
                else {
                    object.address = [];
                    if (options.bytes !== Array)
                        object.address = $util.newBuffer(object.address);
                }
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
            if (message.old_votes && message.old_votes.length) {
                object.old_votes = [];
                for (var j = 0; j < message.old_votes.length; ++j)
                    object.old_votes[j] = $root.protocol.Vote.toObject(message.old_votes[j], options);
            }
            if (message.new_votes && message.new_votes.length) {
                object.new_votes = [];
                for (var j = 0; j < message.new_votes.length; ++j)
                    object.new_votes[j] = $root.protocol.Vote.toObject(message.new_votes[j], options);
            }
            return object;
        };

        /**
         * Converts this Votes to JSON.
         * @function toJSON
         * @memberof protocol.Votes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Votes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Votes;
    })();

    protocol.TXOutput = (function() {

        /**
         * Properties of a TXOutput.
         * @memberof protocol
         * @interface ITXOutput
         * @property {number|Long|null} [value] TXOutput value
         * @property {Uint8Array|null} [pubKeyHash] TXOutput pubKeyHash
         */

        /**
         * Constructs a new TXOutput.
         * @memberof protocol
         * @classdesc Represents a TXOutput.
         * @implements ITXOutput
         * @constructor
         * @param {protocol.ITXOutput=} [properties] Properties to set
         */
        function TXOutput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TXOutput value.
         * @member {number|Long} value
         * @memberof protocol.TXOutput
         * @instance
         */
        TXOutput.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TXOutput pubKeyHash.
         * @member {Uint8Array} pubKeyHash
         * @memberof protocol.TXOutput
         * @instance
         */
        TXOutput.prototype.pubKeyHash = $util.newBuffer([]);

        /**
         * Creates a new TXOutput instance using the specified properties.
         * @function create
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.ITXOutput=} [properties] Properties to set
         * @returns {protocol.TXOutput} TXOutput instance
         */
        TXOutput.create = function create(properties) {
            return new TXOutput(properties);
        };

        /**
         * Encodes the specified TXOutput message. Does not implicitly {@link protocol.TXOutput.verify|verify} messages.
         * @function encode
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.ITXOutput} message TXOutput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.value);
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.pubKeyHash);
            return writer;
        };

        /**
         * Encodes the specified TXOutput message, length delimited. Does not implicitly {@link protocol.TXOutput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.ITXOutput} message TXOutput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TXOutput message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TXOutput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TXOutput} TXOutput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXOutput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.value = reader.int64();
                    break;
                case 2:
                    message.pubKeyHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TXOutput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TXOutput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TXOutput} TXOutput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TXOutput message.
         * @function verify
         * @memberof protocol.TXOutput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TXOutput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                if (!(message.pubKeyHash && typeof message.pubKeyHash.length === "number" || $util.isString(message.pubKeyHash)))
                    return "pubKeyHash: buffer expected";
            return null;
        };

        /**
         * Creates a TXOutput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TXOutput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TXOutput} TXOutput
         */
        TXOutput.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXOutput)
                return object;
            var message = new $root.protocol.TXOutput();
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.pubKeyHash != null)
                if (typeof object.pubKeyHash === "string")
                    $util.base64.decode(object.pubKeyHash, message.pubKeyHash = $util.newBuffer($util.base64.length(object.pubKeyHash)), 0);
                else if (object.pubKeyHash.length)
                    message.pubKeyHash = object.pubKeyHash;
            return message;
        };

        /**
         * Creates a plain object from a TXOutput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TXOutput
         * @static
         * @param {protocol.TXOutput} message TXOutput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TXOutput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.pubKeyHash = "";
                else {
                    object.pubKeyHash = [];
                    if (options.bytes !== Array)
                        object.pubKeyHash = $util.newBuffer(object.pubKeyHash);
                }
            }
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.pubKeyHash != null && message.hasOwnProperty("pubKeyHash"))
                object.pubKeyHash = options.bytes === String ? $util.base64.encode(message.pubKeyHash, 0, message.pubKeyHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKeyHash) : message.pubKeyHash;
            return object;
        };

        /**
         * Converts this TXOutput to JSON.
         * @function toJSON
         * @memberof protocol.TXOutput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TXOutput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TXOutput;
    })();

    protocol.TXInput = (function() {

        /**
         * Properties of a TXInput.
         * @memberof protocol
         * @interface ITXInput
         * @property {protocol.TXInput.Iraw|null} [raw_data] TXInput raw_data
         * @property {Uint8Array|null} [signature] TXInput signature
         */

        /**
         * Constructs a new TXInput.
         * @memberof protocol
         * @classdesc Represents a TXInput.
         * @implements ITXInput
         * @constructor
         * @param {protocol.ITXInput=} [properties] Properties to set
         */
        function TXInput(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TXInput raw_data.
         * @member {protocol.TXInput.Iraw|null|undefined} raw_data
         * @memberof protocol.TXInput
         * @instance
         */
        TXInput.prototype.raw_data = null;

        /**
         * TXInput signature.
         * @member {Uint8Array} signature
         * @memberof protocol.TXInput
         * @instance
         */
        TXInput.prototype.signature = $util.newBuffer([]);

        /**
         * Creates a new TXInput instance using the specified properties.
         * @function create
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.ITXInput=} [properties] Properties to set
         * @returns {protocol.TXInput} TXInput instance
         */
        TXInput.create = function create(properties) {
            return new TXInput(properties);
        };

        /**
         * Encodes the specified TXInput message. Does not implicitly {@link protocol.TXInput.verify|verify} messages.
         * @function encode
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.ITXInput} message TXInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXInput.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.raw_data != null && message.hasOwnProperty("raw_data"))
                $root.protocol.TXInput.raw.encode(message.raw_data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.signature);
            return writer;
        };

        /**
         * Encodes the specified TXInput message, length delimited. Does not implicitly {@link protocol.TXInput.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.ITXInput} message TXInput message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXInput.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TXInput message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TXInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TXInput} TXInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXInput.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXInput();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.raw_data = $root.protocol.TXInput.raw.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TXInput message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TXInput
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TXInput} TXInput
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXInput.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TXInput message.
         * @function verify
         * @memberof protocol.TXInput
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TXInput.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.raw_data != null && message.hasOwnProperty("raw_data")) {
                var error = $root.protocol.TXInput.raw.verify(message.raw_data);
                if (error)
                    return "raw_data." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                    return "signature: buffer expected";
            return null;
        };

        /**
         * Creates a TXInput message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TXInput
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TXInput} TXInput
         */
        TXInput.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXInput)
                return object;
            var message = new $root.protocol.TXInput();
            if (object.raw_data != null) {
                if (typeof object.raw_data !== "object")
                    throw TypeError(".protocol.TXInput.raw_data: object expected");
                message.raw_data = $root.protocol.TXInput.raw.fromObject(object.raw_data);
            }
            if (object.signature != null)
                if (typeof object.signature === "string")
                    $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                else if (object.signature.length)
                    message.signature = object.signature;
            return message;
        };

        /**
         * Creates a plain object from a TXInput message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TXInput
         * @static
         * @param {protocol.TXInput} message TXInput
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TXInput.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.raw_data = null;
                if (options.bytes === String)
                    object.signature = "";
                else {
                    object.signature = [];
                    if (options.bytes !== Array)
                        object.signature = $util.newBuffer(object.signature);
                }
            }
            if (message.raw_data != null && message.hasOwnProperty("raw_data"))
                object.raw_data = $root.protocol.TXInput.raw.toObject(message.raw_data, options);
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
            return object;
        };

        /**
         * Converts this TXInput to JSON.
         * @function toJSON
         * @memberof protocol.TXInput
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TXInput.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        TXInput.raw = (function() {

            /**
             * Properties of a raw.
             * @memberof protocol.TXInput
             * @interface Iraw
             * @property {Uint8Array|null} [txID] raw txID
             * @property {number|Long|null} [vout] raw vout
             * @property {Uint8Array|null} [pubKey] raw pubKey
             */

            /**
             * Constructs a new raw.
             * @memberof protocol.TXInput
             * @classdesc Represents a raw.
             * @implements Iraw
             * @constructor
             * @param {protocol.TXInput.Iraw=} [properties] Properties to set
             */
            function raw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * raw txID.
             * @member {Uint8Array} txID
             * @memberof protocol.TXInput.raw
             * @instance
             */
            raw.prototype.txID = $util.newBuffer([]);

            /**
             * raw vout.
             * @member {number|Long} vout
             * @memberof protocol.TXInput.raw
             * @instance
             */
            raw.prototype.vout = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw pubKey.
             * @member {Uint8Array} pubKey
             * @memberof protocol.TXInput.raw
             * @instance
             */
            raw.prototype.pubKey = $util.newBuffer([]);

            /**
             * Creates a new raw instance using the specified properties.
             * @function create
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.Iraw=} [properties] Properties to set
             * @returns {protocol.TXInput.raw} raw instance
             */
            raw.create = function create(properties) {
                return new raw(properties);
            };

            /**
             * Encodes the specified raw message. Does not implicitly {@link protocol.TXInput.raw.verify|verify} messages.
             * @function encode
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txID != null && message.hasOwnProperty("txID"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txID);
                if (message.vout != null && message.hasOwnProperty("vout"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.vout);
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.pubKey);
                return writer;
            };

            /**
             * Encodes the specified raw message, length delimited. Does not implicitly {@link protocol.TXInput.raw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a raw message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.TXInput.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.TXInput.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXInput.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txID = reader.bytes();
                        break;
                    case 2:
                        message.vout = reader.int64();
                        break;
                    case 3:
                        message.pubKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a raw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.TXInput.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.TXInput.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a raw message.
             * @function verify
             * @memberof protocol.TXInput.raw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txID != null && message.hasOwnProperty("txID"))
                    if (!(message.txID && typeof message.txID.length === "number" || $util.isString(message.txID)))
                        return "txID: buffer expected";
                if (message.vout != null && message.hasOwnProperty("vout"))
                    if (!$util.isInteger(message.vout) && !(message.vout && $util.isInteger(message.vout.low) && $util.isInteger(message.vout.high)))
                        return "vout: integer|Long expected";
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    if (!(message.pubKey && typeof message.pubKey.length === "number" || $util.isString(message.pubKey)))
                        return "pubKey: buffer expected";
                return null;
            };

            /**
             * Creates a raw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.TXInput.raw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.TXInput.raw} raw
             */
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.TXInput.raw)
                    return object;
                var message = new $root.protocol.TXInput.raw();
                if (object.txID != null)
                    if (typeof object.txID === "string")
                        $util.base64.decode(object.txID, message.txID = $util.newBuffer($util.base64.length(object.txID)), 0);
                    else if (object.txID.length)
                        message.txID = object.txID;
                if (object.vout != null)
                    if ($util.Long)
                        (message.vout = $util.Long.fromValue(object.vout)).unsigned = false;
                    else if (typeof object.vout === "string")
                        message.vout = parseInt(object.vout, 10);
                    else if (typeof object.vout === "number")
                        message.vout = object.vout;
                    else if (typeof object.vout === "object")
                        message.vout = new $util.LongBits(object.vout.low >>> 0, object.vout.high >>> 0).toNumber();
                if (object.pubKey != null)
                    if (typeof object.pubKey === "string")
                        $util.base64.decode(object.pubKey, message.pubKey = $util.newBuffer($util.base64.length(object.pubKey)), 0);
                    else if (object.pubKey.length)
                        message.pubKey = object.pubKey;
                return message;
            };

            /**
             * Creates a plain object from a raw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.TXInput.raw
             * @static
             * @param {protocol.TXInput.raw} message raw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.txID = "";
                    else {
                        object.txID = [];
                        if (options.bytes !== Array)
                            object.txID = $util.newBuffer(object.txID);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.vout = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.vout = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.pubKey = "";
                    else {
                        object.pubKey = [];
                        if (options.bytes !== Array)
                            object.pubKey = $util.newBuffer(object.pubKey);
                    }
                }
                if (message.txID != null && message.hasOwnProperty("txID"))
                    object.txID = options.bytes === String ? $util.base64.encode(message.txID, 0, message.txID.length) : options.bytes === Array ? Array.prototype.slice.call(message.txID) : message.txID;
                if (message.vout != null && message.hasOwnProperty("vout"))
                    if (typeof message.vout === "number")
                        object.vout = options.longs === String ? String(message.vout) : message.vout;
                    else
                        object.vout = options.longs === String ? $util.Long.prototype.toString.call(message.vout) : options.longs === Number ? new $util.LongBits(message.vout.low >>> 0, message.vout.high >>> 0).toNumber() : message.vout;
                if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                    object.pubKey = options.bytes === String ? $util.base64.encode(message.pubKey, 0, message.pubKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.pubKey) : message.pubKey;
                return object;
            };

            /**
             * Converts this raw to JSON.
             * @function toJSON
             * @memberof protocol.TXInput.raw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return raw;
        })();

        return TXInput;
    })();

    protocol.TXOutputs = (function() {

        /**
         * Properties of a TXOutputs.
         * @memberof protocol
         * @interface ITXOutputs
         * @property {Array.<protocol.ITXOutput>|null} [outputs] TXOutputs outputs
         */

        /**
         * Constructs a new TXOutputs.
         * @memberof protocol
         * @classdesc Represents a TXOutputs.
         * @implements ITXOutputs
         * @constructor
         * @param {protocol.ITXOutputs=} [properties] Properties to set
         */
        function TXOutputs(properties) {
            this.outputs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TXOutputs outputs.
         * @member {Array.<protocol.ITXOutput>} outputs
         * @memberof protocol.TXOutputs
         * @instance
         */
        TXOutputs.prototype.outputs = $util.emptyArray;

        /**
         * Creates a new TXOutputs instance using the specified properties.
         * @function create
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.ITXOutputs=} [properties] Properties to set
         * @returns {protocol.TXOutputs} TXOutputs instance
         */
        TXOutputs.create = function create(properties) {
            return new TXOutputs(properties);
        };

        /**
         * Encodes the specified TXOutputs message. Does not implicitly {@link protocol.TXOutputs.verify|verify} messages.
         * @function encode
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.ITXOutputs} message TXOutputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutputs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.outputs != null && message.outputs.length)
                for (var i = 0; i < message.outputs.length; ++i)
                    $root.protocol.TXOutput.encode(message.outputs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TXOutputs message, length delimited. Does not implicitly {@link protocol.TXOutputs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.ITXOutputs} message TXOutputs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TXOutputs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TXOutputs message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TXOutputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TXOutputs} TXOutputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutputs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TXOutputs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.outputs && message.outputs.length))
                        message.outputs = [];
                    message.outputs.push($root.protocol.TXOutput.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TXOutputs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TXOutputs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TXOutputs} TXOutputs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TXOutputs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TXOutputs message.
         * @function verify
         * @memberof protocol.TXOutputs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TXOutputs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.outputs != null && message.hasOwnProperty("outputs")) {
                if (!Array.isArray(message.outputs))
                    return "outputs: array expected";
                for (var i = 0; i < message.outputs.length; ++i) {
                    var error = $root.protocol.TXOutput.verify(message.outputs[i]);
                    if (error)
                        return "outputs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TXOutputs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TXOutputs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TXOutputs} TXOutputs
         */
        TXOutputs.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TXOutputs)
                return object;
            var message = new $root.protocol.TXOutputs();
            if (object.outputs) {
                if (!Array.isArray(object.outputs))
                    throw TypeError(".protocol.TXOutputs.outputs: array expected");
                message.outputs = [];
                for (var i = 0; i < object.outputs.length; ++i) {
                    if (typeof object.outputs[i] !== "object")
                        throw TypeError(".protocol.TXOutputs.outputs: object expected");
                    message.outputs[i] = $root.protocol.TXOutput.fromObject(object.outputs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TXOutputs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TXOutputs
         * @static
         * @param {protocol.TXOutputs} message TXOutputs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TXOutputs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.outputs = [];
            if (message.outputs && message.outputs.length) {
                object.outputs = [];
                for (var j = 0; j < message.outputs.length; ++j)
                    object.outputs[j] = $root.protocol.TXOutput.toObject(message.outputs[j], options);
            }
            return object;
        };

        /**
         * Converts this TXOutputs to JSON.
         * @function toJSON
         * @memberof protocol.TXOutputs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TXOutputs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TXOutputs;
    })();

    protocol.ResourceReceipt = (function() {

        /**
         * Properties of a ResourceReceipt.
         * @memberof protocol
         * @interface IResourceReceipt
         * @property {number|Long|null} [energy_usage] ResourceReceipt energy_usage
         * @property {number|Long|null} [energy_fee] ResourceReceipt energy_fee
         * @property {number|Long|null} [origin_energy_usage] ResourceReceipt origin_energy_usage
         * @property {number|Long|null} [energy_usage_total] ResourceReceipt energy_usage_total
         * @property {number|Long|null} [net_usage] ResourceReceipt net_usage
         * @property {number|Long|null} [net_fee] ResourceReceipt net_fee
         * @property {protocol.Transaction.Result.contractResult|null} [result] ResourceReceipt result
         */

        /**
         * Constructs a new ResourceReceipt.
         * @memberof protocol
         * @classdesc Represents a ResourceReceipt.
         * @implements IResourceReceipt
         * @constructor
         * @param {protocol.IResourceReceipt=} [properties] Properties to set
         */
        function ResourceReceipt(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceReceipt energy_usage.
         * @member {number|Long} energy_usage
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.energy_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt energy_fee.
         * @member {number|Long} energy_fee
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.energy_fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt origin_energy_usage.
         * @member {number|Long} origin_energy_usage
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.origin_energy_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt energy_usage_total.
         * @member {number|Long} energy_usage_total
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.energy_usage_total = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt net_usage.
         * @member {number|Long} net_usage
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.net_usage = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt net_fee.
         * @member {number|Long} net_fee
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.net_fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ResourceReceipt result.
         * @member {protocol.Transaction.Result.contractResult} result
         * @memberof protocol.ResourceReceipt
         * @instance
         */
        ResourceReceipt.prototype.result = 0;

        /**
         * Creates a new ResourceReceipt instance using the specified properties.
         * @function create
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.IResourceReceipt=} [properties] Properties to set
         * @returns {protocol.ResourceReceipt} ResourceReceipt instance
         */
        ResourceReceipt.create = function create(properties) {
            return new ResourceReceipt(properties);
        };

        /**
         * Encodes the specified ResourceReceipt message. Does not implicitly {@link protocol.ResourceReceipt.verify|verify} messages.
         * @function encode
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.IResourceReceipt} message ResourceReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceReceipt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.energy_usage != null && message.hasOwnProperty("energy_usage"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.energy_usage);
            if (message.energy_fee != null && message.hasOwnProperty("energy_fee"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.energy_fee);
            if (message.origin_energy_usage != null && message.hasOwnProperty("origin_energy_usage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.origin_energy_usage);
            if (message.energy_usage_total != null && message.hasOwnProperty("energy_usage_total"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.energy_usage_total);
            if (message.net_usage != null && message.hasOwnProperty("net_usage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.net_usage);
            if (message.net_fee != null && message.hasOwnProperty("net_fee"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.net_fee);
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.result);
            return writer;
        };

        /**
         * Encodes the specified ResourceReceipt message, length delimited. Does not implicitly {@link protocol.ResourceReceipt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.IResourceReceipt} message ResourceReceipt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceReceipt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceReceipt message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ResourceReceipt} ResourceReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceReceipt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ResourceReceipt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.energy_usage = reader.int64();
                    break;
                case 2:
                    message.energy_fee = reader.int64();
                    break;
                case 3:
                    message.origin_energy_usage = reader.int64();
                    break;
                case 4:
                    message.energy_usage_total = reader.int64();
                    break;
                case 5:
                    message.net_usage = reader.int64();
                    break;
                case 6:
                    message.net_fee = reader.int64();
                    break;
                case 7:
                    message.result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceReceipt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ResourceReceipt} ResourceReceipt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceReceipt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceReceipt message.
         * @function verify
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceReceipt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.energy_usage != null && message.hasOwnProperty("energy_usage"))
                if (!$util.isInteger(message.energy_usage) && !(message.energy_usage && $util.isInteger(message.energy_usage.low) && $util.isInteger(message.energy_usage.high)))
                    return "energy_usage: integer|Long expected";
            if (message.energy_fee != null && message.hasOwnProperty("energy_fee"))
                if (!$util.isInteger(message.energy_fee) && !(message.energy_fee && $util.isInteger(message.energy_fee.low) && $util.isInteger(message.energy_fee.high)))
                    return "energy_fee: integer|Long expected";
            if (message.origin_energy_usage != null && message.hasOwnProperty("origin_energy_usage"))
                if (!$util.isInteger(message.origin_energy_usage) && !(message.origin_energy_usage && $util.isInteger(message.origin_energy_usage.low) && $util.isInteger(message.origin_energy_usage.high)))
                    return "origin_energy_usage: integer|Long expected";
            if (message.energy_usage_total != null && message.hasOwnProperty("energy_usage_total"))
                if (!$util.isInteger(message.energy_usage_total) && !(message.energy_usage_total && $util.isInteger(message.energy_usage_total.low) && $util.isInteger(message.energy_usage_total.high)))
                    return "energy_usage_total: integer|Long expected";
            if (message.net_usage != null && message.hasOwnProperty("net_usage"))
                if (!$util.isInteger(message.net_usage) && !(message.net_usage && $util.isInteger(message.net_usage.low) && $util.isInteger(message.net_usage.high)))
                    return "net_usage: integer|Long expected";
            if (message.net_fee != null && message.hasOwnProperty("net_fee"))
                if (!$util.isInteger(message.net_fee) && !(message.net_fee && $util.isInteger(message.net_fee.low) && $util.isInteger(message.net_fee.high)))
                    return "net_fee: integer|Long expected";
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                    break;
                }
            return null;
        };

        /**
         * Creates a ResourceReceipt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ResourceReceipt} ResourceReceipt
         */
        ResourceReceipt.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ResourceReceipt)
                return object;
            var message = new $root.protocol.ResourceReceipt();
            if (object.energy_usage != null)
                if ($util.Long)
                    (message.energy_usage = $util.Long.fromValue(object.energy_usage)).unsigned = false;
                else if (typeof object.energy_usage === "string")
                    message.energy_usage = parseInt(object.energy_usage, 10);
                else if (typeof object.energy_usage === "number")
                    message.energy_usage = object.energy_usage;
                else if (typeof object.energy_usage === "object")
                    message.energy_usage = new $util.LongBits(object.energy_usage.low >>> 0, object.energy_usage.high >>> 0).toNumber();
            if (object.energy_fee != null)
                if ($util.Long)
                    (message.energy_fee = $util.Long.fromValue(object.energy_fee)).unsigned = false;
                else if (typeof object.energy_fee === "string")
                    message.energy_fee = parseInt(object.energy_fee, 10);
                else if (typeof object.energy_fee === "number")
                    message.energy_fee = object.energy_fee;
                else if (typeof object.energy_fee === "object")
                    message.energy_fee = new $util.LongBits(object.energy_fee.low >>> 0, object.energy_fee.high >>> 0).toNumber();
            if (object.origin_energy_usage != null)
                if ($util.Long)
                    (message.origin_energy_usage = $util.Long.fromValue(object.origin_energy_usage)).unsigned = false;
                else if (typeof object.origin_energy_usage === "string")
                    message.origin_energy_usage = parseInt(object.origin_energy_usage, 10);
                else if (typeof object.origin_energy_usage === "number")
                    message.origin_energy_usage = object.origin_energy_usage;
                else if (typeof object.origin_energy_usage === "object")
                    message.origin_energy_usage = new $util.LongBits(object.origin_energy_usage.low >>> 0, object.origin_energy_usage.high >>> 0).toNumber();
            if (object.energy_usage_total != null)
                if ($util.Long)
                    (message.energy_usage_total = $util.Long.fromValue(object.energy_usage_total)).unsigned = false;
                else if (typeof object.energy_usage_total === "string")
                    message.energy_usage_total = parseInt(object.energy_usage_total, 10);
                else if (typeof object.energy_usage_total === "number")
                    message.energy_usage_total = object.energy_usage_total;
                else if (typeof object.energy_usage_total === "object")
                    message.energy_usage_total = new $util.LongBits(object.energy_usage_total.low >>> 0, object.energy_usage_total.high >>> 0).toNumber();
            if (object.net_usage != null)
                if ($util.Long)
                    (message.net_usage = $util.Long.fromValue(object.net_usage)).unsigned = false;
                else if (typeof object.net_usage === "string")
                    message.net_usage = parseInt(object.net_usage, 10);
                else if (typeof object.net_usage === "number")
                    message.net_usage = object.net_usage;
                else if (typeof object.net_usage === "object")
                    message.net_usage = new $util.LongBits(object.net_usage.low >>> 0, object.net_usage.high >>> 0).toNumber();
            if (object.net_fee != null)
                if ($util.Long)
                    (message.net_fee = $util.Long.fromValue(object.net_fee)).unsigned = false;
                else if (typeof object.net_fee === "string")
                    message.net_fee = parseInt(object.net_fee, 10);
                else if (typeof object.net_fee === "number")
                    message.net_fee = object.net_fee;
                else if (typeof object.net_fee === "object")
                    message.net_fee = new $util.LongBits(object.net_fee.low >>> 0, object.net_fee.high >>> 0).toNumber();
            switch (object.result) {
            case "DEFAULT":
            case 0:
                message.result = 0;
                break;
            case "SUCCESS":
            case 1:
                message.result = 1;
                break;
            case "REVERT":
            case 2:
                message.result = 2;
                break;
            case "BAD_JUMP_DESTINATION":
            case 3:
                message.result = 3;
                break;
            case "OUT_OF_MEMORY":
            case 4:
                message.result = 4;
                break;
            case "PRECOMPILED_CONTRACT":
            case 5:
                message.result = 5;
                break;
            case "STACK_TOO_SMALL":
            case 6:
                message.result = 6;
                break;
            case "STACK_TOO_LARGE":
            case 7:
                message.result = 7;
                break;
            case "ILLEGAL_OPERATION":
            case 8:
                message.result = 8;
                break;
            case "STACK_OVERFLOW":
            case 9:
                message.result = 9;
                break;
            case "OUT_OF_ENERGY":
            case 10:
                message.result = 10;
                break;
            case "OUT_OF_TIME":
            case 11:
                message.result = 11;
                break;
            case "JVM_STACK_OVER_FLOW":
            case 12:
                message.result = 12;
                break;
            case "UNKNOWN":
            case 13:
                message.result = 13;
                break;
            case "TRANSFER_FAILED":
            case 14:
                message.result = 14;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ResourceReceipt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ResourceReceipt
         * @static
         * @param {protocol.ResourceReceipt} message ResourceReceipt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ResourceReceipt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energy_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energy_usage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energy_fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energy_fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.origin_energy_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.origin_energy_usage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.energy_usage_total = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.energy_usage_total = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.net_usage = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.net_usage = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.net_fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.net_fee = options.longs === String ? "0" : 0;
                object.result = options.enums === String ? "DEFAULT" : 0;
            }
            if (message.energy_usage != null && message.hasOwnProperty("energy_usage"))
                if (typeof message.energy_usage === "number")
                    object.energy_usage = options.longs === String ? String(message.energy_usage) : message.energy_usage;
                else
                    object.energy_usage = options.longs === String ? $util.Long.prototype.toString.call(message.energy_usage) : options.longs === Number ? new $util.LongBits(message.energy_usage.low >>> 0, message.energy_usage.high >>> 0).toNumber() : message.energy_usage;
            if (message.energy_fee != null && message.hasOwnProperty("energy_fee"))
                if (typeof message.energy_fee === "number")
                    object.energy_fee = options.longs === String ? String(message.energy_fee) : message.energy_fee;
                else
                    object.energy_fee = options.longs === String ? $util.Long.prototype.toString.call(message.energy_fee) : options.longs === Number ? new $util.LongBits(message.energy_fee.low >>> 0, message.energy_fee.high >>> 0).toNumber() : message.energy_fee;
            if (message.origin_energy_usage != null && message.hasOwnProperty("origin_energy_usage"))
                if (typeof message.origin_energy_usage === "number")
                    object.origin_energy_usage = options.longs === String ? String(message.origin_energy_usage) : message.origin_energy_usage;
                else
                    object.origin_energy_usage = options.longs === String ? $util.Long.prototype.toString.call(message.origin_energy_usage) : options.longs === Number ? new $util.LongBits(message.origin_energy_usage.low >>> 0, message.origin_energy_usage.high >>> 0).toNumber() : message.origin_energy_usage;
            if (message.energy_usage_total != null && message.hasOwnProperty("energy_usage_total"))
                if (typeof message.energy_usage_total === "number")
                    object.energy_usage_total = options.longs === String ? String(message.energy_usage_total) : message.energy_usage_total;
                else
                    object.energy_usage_total = options.longs === String ? $util.Long.prototype.toString.call(message.energy_usage_total) : options.longs === Number ? new $util.LongBits(message.energy_usage_total.low >>> 0, message.energy_usage_total.high >>> 0).toNumber() : message.energy_usage_total;
            if (message.net_usage != null && message.hasOwnProperty("net_usage"))
                if (typeof message.net_usage === "number")
                    object.net_usage = options.longs === String ? String(message.net_usage) : message.net_usage;
                else
                    object.net_usage = options.longs === String ? $util.Long.prototype.toString.call(message.net_usage) : options.longs === Number ? new $util.LongBits(message.net_usage.low >>> 0, message.net_usage.high >>> 0).toNumber() : message.net_usage;
            if (message.net_fee != null && message.hasOwnProperty("net_fee"))
                if (typeof message.net_fee === "number")
                    object.net_fee = options.longs === String ? String(message.net_fee) : message.net_fee;
                else
                    object.net_fee = options.longs === String ? $util.Long.prototype.toString.call(message.net_fee) : options.longs === Number ? new $util.LongBits(message.net_fee.low >>> 0, message.net_fee.high >>> 0).toNumber() : message.net_fee;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.protocol.Transaction.Result.contractResult[message.result] : message.result;
            return object;
        };

        /**
         * Converts this ResourceReceipt to JSON.
         * @function toJSON
         * @memberof protocol.ResourceReceipt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ResourceReceipt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ResourceReceipt;
    })();

    protocol.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof protocol
         * @interface ITransaction
         * @property {protocol.Transaction.Iraw|null} [raw_data] Transaction raw_data
         * @property {Array.<Uint8Array>|null} [signature] Transaction signature
         * @property {Array.<protocol.Transaction.IResult>|null} [ret] Transaction ret
         */

        /**
         * Constructs a new Transaction.
         * @memberof protocol
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {protocol.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            this.signature = [];
            this.ret = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transaction raw_data.
         * @member {protocol.Transaction.Iraw|null|undefined} raw_data
         * @memberof protocol.Transaction
         * @instance
         */
        Transaction.prototype.raw_data = null;

        /**
         * Transaction signature.
         * @member {Array.<Uint8Array>} signature
         * @memberof protocol.Transaction
         * @instance
         */
        Transaction.prototype.signature = $util.emptyArray;

        /**
         * Transaction ret.
         * @member {Array.<protocol.Transaction.IResult>} ret
         * @memberof protocol.Transaction
         * @instance
         */
        Transaction.prototype.ret = $util.emptyArray;

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.ITransaction=} [properties] Properties to set
         * @returns {protocol.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link protocol.Transaction.verify|verify} messages.
         * @function encode
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.raw_data != null && message.hasOwnProperty("raw_data"))
                $root.protocol.Transaction.raw.encode(message.raw_data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signature != null && message.signature.length)
                for (var i = 0; i < message.signature.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signature[i]);
            if (message.ret != null && message.ret.length)
                for (var i = 0; i < message.ret.length; ++i)
                    $root.protocol.Transaction.Result.encode(message.ret[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link protocol.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.raw_data = $root.protocol.Transaction.raw.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.signature && message.signature.length))
                        message.signature = [];
                    message.signature.push(reader.bytes());
                    break;
                case 5:
                    if (!(message.ret && message.ret.length))
                        message.ret = [];
                    message.ret.push($root.protocol.Transaction.Result.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof protocol.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.raw_data != null && message.hasOwnProperty("raw_data")) {
                var error = $root.protocol.Transaction.raw.verify(message.raw_data);
                if (error)
                    return "raw_data." + error;
            }
            if (message.signature != null && message.hasOwnProperty("signature")) {
                if (!Array.isArray(message.signature))
                    return "signature: array expected";
                for (var i = 0; i < message.signature.length; ++i)
                    if (!(message.signature[i] && typeof message.signature[i].length === "number" || $util.isString(message.signature[i])))
                        return "signature: buffer[] expected";
            }
            if (message.ret != null && message.hasOwnProperty("ret")) {
                if (!Array.isArray(message.ret))
                    return "ret: array expected";
                for (var i = 0; i < message.ret.length; ++i) {
                    var error = $root.protocol.Transaction.Result.verify(message.ret[i]);
                    if (error)
                        return "ret." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Transaction)
                return object;
            var message = new $root.protocol.Transaction();
            if (object.raw_data != null) {
                if (typeof object.raw_data !== "object")
                    throw TypeError(".protocol.Transaction.raw_data: object expected");
                message.raw_data = $root.protocol.Transaction.raw.fromObject(object.raw_data);
            }
            if (object.signature) {
                if (!Array.isArray(object.signature))
                    throw TypeError(".protocol.Transaction.signature: array expected");
                message.signature = [];
                for (var i = 0; i < object.signature.length; ++i)
                    if (typeof object.signature[i] === "string")
                        $util.base64.decode(object.signature[i], message.signature[i] = $util.newBuffer($util.base64.length(object.signature[i])), 0);
                    else if (object.signature[i].length)
                        message.signature[i] = object.signature[i];
            }
            if (object.ret) {
                if (!Array.isArray(object.ret))
                    throw TypeError(".protocol.Transaction.ret: array expected");
                message.ret = [];
                for (var i = 0; i < object.ret.length; ++i) {
                    if (typeof object.ret[i] !== "object")
                        throw TypeError(".protocol.Transaction.ret: object expected");
                    message.ret[i] = $root.protocol.Transaction.Result.fromObject(object.ret[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Transaction
         * @static
         * @param {protocol.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.signature = [];
                object.ret = [];
            }
            if (options.defaults)
                object.raw_data = null;
            if (message.raw_data != null && message.hasOwnProperty("raw_data"))
                object.raw_data = $root.protocol.Transaction.raw.toObject(message.raw_data, options);
            if (message.signature && message.signature.length) {
                object.signature = [];
                for (var j = 0; j < message.signature.length; ++j)
                    object.signature[j] = options.bytes === String ? $util.base64.encode(message.signature[j], 0, message.signature[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.signature[j]) : message.signature[j];
            }
            if (message.ret && message.ret.length) {
                object.ret = [];
                for (var j = 0; j < message.ret.length; ++j)
                    object.ret[j] = $root.protocol.Transaction.Result.toObject(message.ret[j], options);
            }
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof protocol.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Transaction.Contract = (function() {

            /**
             * Properties of a Contract.
             * @memberof protocol.Transaction
             * @interface IContract
             * @property {protocol.Transaction.Contract.ContractType|null} [type] Contract type
             * @property {google.protobuf.IAny|null} [parameter] Contract parameter
             * @property {Uint8Array|null} [provider] Contract provider
             * @property {Uint8Array|null} [ContractName] Contract ContractName
             * @property {number|null} [Permission_id] Contract Permission_id
             */

            /**
             * Constructs a new Contract.
             * @memberof protocol.Transaction
             * @classdesc Represents a Contract.
             * @implements IContract
             * @constructor
             * @param {protocol.Transaction.IContract=} [properties] Properties to set
             */
            function Contract(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contract type.
             * @member {protocol.Transaction.Contract.ContractType} type
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.type = 0;

            /**
             * Contract parameter.
             * @member {google.protobuf.IAny|null|undefined} parameter
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.parameter = null;

            /**
             * Contract provider.
             * @member {Uint8Array} provider
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.provider = $util.newBuffer([]);

            /**
             * Contract ContractName.
             * @member {Uint8Array} ContractName
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.ContractName = $util.newBuffer([]);

            /**
             * Contract Permission_id.
             * @member {number} Permission_id
             * @memberof protocol.Transaction.Contract
             * @instance
             */
            Contract.prototype.Permission_id = 0;

            /**
             * Creates a new Contract instance using the specified properties.
             * @function create
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.IContract=} [properties] Properties to set
             * @returns {protocol.Transaction.Contract} Contract instance
             */
            Contract.create = function create(properties) {
                return new Contract(properties);
            };

            /**
             * Encodes the specified Contract message. Does not implicitly {@link protocol.Transaction.Contract.verify|verify} messages.
             * @function encode
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.IContract} message Contract message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contract.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.parameter != null && message.hasOwnProperty("parameter"))
                    $root.google.protobuf.Any.encode(message.parameter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.provider != null && message.hasOwnProperty("provider"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.provider);
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ContractName);
                if (message.Permission_id != null && message.hasOwnProperty("Permission_id"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Permission_id);
                return writer;
            };

            /**
             * Encodes the specified Contract message, length delimited. Does not implicitly {@link protocol.Transaction.Contract.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.IContract} message Contract message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contract.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contract message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Transaction.Contract} Contract
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contract.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.Contract();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.parameter = $root.google.protobuf.Any.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.provider = reader.bytes();
                        break;
                    case 4:
                        message.ContractName = reader.bytes();
                        break;
                    case 5:
                        message.Permission_id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contract message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Transaction.Contract} Contract
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contract.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contract message.
             * @function verify
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contract.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 48:
                        break;
                    }
                if (message.parameter != null && message.hasOwnProperty("parameter")) {
                    var error = $root.google.protobuf.Any.verify(message.parameter);
                    if (error)
                        return "parameter." + error;
                }
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!(message.provider && typeof message.provider.length === "number" || $util.isString(message.provider)))
                        return "provider: buffer expected";
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    if (!(message.ContractName && typeof message.ContractName.length === "number" || $util.isString(message.ContractName)))
                        return "ContractName: buffer expected";
                if (message.Permission_id != null && message.hasOwnProperty("Permission_id"))
                    if (!$util.isInteger(message.Permission_id))
                        return "Permission_id: integer expected";
                return null;
            };

            /**
             * Creates a Contract message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Transaction.Contract} Contract
             */
            Contract.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.Contract)
                    return object;
                var message = new $root.protocol.Transaction.Contract();
                switch (object.type) {
                case "AccountCreateContract":
                case 0:
                    message.type = 0;
                    break;
                case "TransferContract":
                case 1:
                    message.type = 1;
                    break;
                case "TransferAssetContract":
                case 2:
                    message.type = 2;
                    break;
                case "VoteAssetContract":
                case 3:
                    message.type = 3;
                    break;
                case "VoteWitnessContract":
                case 4:
                    message.type = 4;
                    break;
                case "WitnessCreateContract":
                case 5:
                    message.type = 5;
                    break;
                case "AssetIssueContract":
                case 6:
                    message.type = 6;
                    break;
                case "WitnessUpdateContract":
                case 8:
                    message.type = 8;
                    break;
                case "ParticipateAssetIssueContract":
                case 9:
                    message.type = 9;
                    break;
                case "AccountUpdateContract":
                case 10:
                    message.type = 10;
                    break;
                case "FreezeBalanceContract":
                case 11:
                    message.type = 11;
                    break;
                case "UnfreezeBalanceContract":
                case 12:
                    message.type = 12;
                    break;
                case "WithdrawBalanceContract":
                case 13:
                    message.type = 13;
                    break;
                case "UnfreezeAssetContract":
                case 14:
                    message.type = 14;
                    break;
                case "UpdateAssetContract":
                case 15:
                    message.type = 15;
                    break;
                case "ProposalCreateContract":
                case 16:
                    message.type = 16;
                    break;
                case "ProposalApproveContract":
                case 17:
                    message.type = 17;
                    break;
                case "ProposalDeleteContract":
                case 18:
                    message.type = 18;
                    break;
                case "SetAccountIdContract":
                case 19:
                    message.type = 19;
                    break;
                case "CustomContract":
                case 20:
                    message.type = 20;
                    break;
                case "CreateSmartContract":
                case 30:
                    message.type = 30;
                    break;
                case "TriggerSmartContract":
                case 31:
                    message.type = 31;
                    break;
                case "GetContract":
                case 32:
                    message.type = 32;
                    break;
                case "UpdateSettingContract":
                case 33:
                    message.type = 33;
                    break;
                case "ExchangeCreateContract":
                case 41:
                    message.type = 41;
                    break;
                case "ExchangeInjectContract":
                case 42:
                    message.type = 42;
                    break;
                case "ExchangeWithdrawContract":
                case 43:
                    message.type = 43;
                    break;
                case "ExchangeTransactionContract":
                case 44:
                    message.type = 44;
                    break;
                case "UpdateEnergyLimitContract":
                case 45:
                    message.type = 45;
                    break;
                case "AccountPermissionUpdateContract":
                case 46:
                    message.type = 46;
                    break;
                case "ClearABIContract":
                case 48:
                    message.type = 48;
                    break;
                }
                if (object.parameter != null) {
                    if (typeof object.parameter !== "object")
                        throw TypeError(".protocol.Transaction.Contract.parameter: object expected");
                    message.parameter = $root.google.protobuf.Any.fromObject(object.parameter);
                }
                if (object.provider != null)
                    if (typeof object.provider === "string")
                        $util.base64.decode(object.provider, message.provider = $util.newBuffer($util.base64.length(object.provider)), 0);
                    else if (object.provider.length)
                        message.provider = object.provider;
                if (object.ContractName != null)
                    if (typeof object.ContractName === "string")
                        $util.base64.decode(object.ContractName, message.ContractName = $util.newBuffer($util.base64.length(object.ContractName)), 0);
                    else if (object.ContractName.length)
                        message.ContractName = object.ContractName;
                if (object.Permission_id != null)
                    message.Permission_id = object.Permission_id | 0;
                return message;
            };

            /**
             * Creates a plain object from a Contract message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Transaction.Contract
             * @static
             * @param {protocol.Transaction.Contract} message Contract
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contract.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "AccountCreateContract" : 0;
                    object.parameter = null;
                    if (options.bytes === String)
                        object.provider = "";
                    else {
                        object.provider = [];
                        if (options.bytes !== Array)
                            object.provider = $util.newBuffer(object.provider);
                    }
                    if (options.bytes === String)
                        object.ContractName = "";
                    else {
                        object.ContractName = [];
                        if (options.bytes !== Array)
                            object.ContractName = $util.newBuffer(object.ContractName);
                    }
                    object.Permission_id = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.protocol.Transaction.Contract.ContractType[message.type] : message.type;
                if (message.parameter != null && message.hasOwnProperty("parameter"))
                    object.parameter = $root.google.protobuf.Any.toObject(message.parameter, options);
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = options.bytes === String ? $util.base64.encode(message.provider, 0, message.provider.length) : options.bytes === Array ? Array.prototype.slice.call(message.provider) : message.provider;
                if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                    object.ContractName = options.bytes === String ? $util.base64.encode(message.ContractName, 0, message.ContractName.length) : options.bytes === Array ? Array.prototype.slice.call(message.ContractName) : message.ContractName;
                if (message.Permission_id != null && message.hasOwnProperty("Permission_id"))
                    object.Permission_id = message.Permission_id;
                return object;
            };

            /**
             * Converts this Contract to JSON.
             * @function toJSON
             * @memberof protocol.Transaction.Contract
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contract.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * ContractType enum.
             * @name protocol.Transaction.Contract.ContractType
             * @enum {string}
             * @property {number} AccountCreateContract=0 AccountCreateContract value
             * @property {number} TransferContract=1 TransferContract value
             * @property {number} TransferAssetContract=2 TransferAssetContract value
             * @property {number} VoteAssetContract=3 VoteAssetContract value
             * @property {number} VoteWitnessContract=4 VoteWitnessContract value
             * @property {number} WitnessCreateContract=5 WitnessCreateContract value
             * @property {number} AssetIssueContract=6 AssetIssueContract value
             * @property {number} WitnessUpdateContract=8 WitnessUpdateContract value
             * @property {number} ParticipateAssetIssueContract=9 ParticipateAssetIssueContract value
             * @property {number} AccountUpdateContract=10 AccountUpdateContract value
             * @property {number} FreezeBalanceContract=11 FreezeBalanceContract value
             * @property {number} UnfreezeBalanceContract=12 UnfreezeBalanceContract value
             * @property {number} WithdrawBalanceContract=13 WithdrawBalanceContract value
             * @property {number} UnfreezeAssetContract=14 UnfreezeAssetContract value
             * @property {number} UpdateAssetContract=15 UpdateAssetContract value
             * @property {number} ProposalCreateContract=16 ProposalCreateContract value
             * @property {number} ProposalApproveContract=17 ProposalApproveContract value
             * @property {number} ProposalDeleteContract=18 ProposalDeleteContract value
             * @property {number} SetAccountIdContract=19 SetAccountIdContract value
             * @property {number} CustomContract=20 CustomContract value
             * @property {number} CreateSmartContract=30 CreateSmartContract value
             * @property {number} TriggerSmartContract=31 TriggerSmartContract value
             * @property {number} GetContract=32 GetContract value
             * @property {number} UpdateSettingContract=33 UpdateSettingContract value
             * @property {number} ExchangeCreateContract=41 ExchangeCreateContract value
             * @property {number} ExchangeInjectContract=42 ExchangeInjectContract value
             * @property {number} ExchangeWithdrawContract=43 ExchangeWithdrawContract value
             * @property {number} ExchangeTransactionContract=44 ExchangeTransactionContract value
             * @property {number} UpdateEnergyLimitContract=45 UpdateEnergyLimitContract value
             * @property {number} AccountPermissionUpdateContract=46 AccountPermissionUpdateContract value
             * @property {number} ClearABIContract=48 ClearABIContract value
             */
            Contract.ContractType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "AccountCreateContract"] = 0;
                values[valuesById[1] = "TransferContract"] = 1;
                values[valuesById[2] = "TransferAssetContract"] = 2;
                values[valuesById[3] = "VoteAssetContract"] = 3;
                values[valuesById[4] = "VoteWitnessContract"] = 4;
                values[valuesById[5] = "WitnessCreateContract"] = 5;
                values[valuesById[6] = "AssetIssueContract"] = 6;
                values[valuesById[8] = "WitnessUpdateContract"] = 8;
                values[valuesById[9] = "ParticipateAssetIssueContract"] = 9;
                values[valuesById[10] = "AccountUpdateContract"] = 10;
                values[valuesById[11] = "FreezeBalanceContract"] = 11;
                values[valuesById[12] = "UnfreezeBalanceContract"] = 12;
                values[valuesById[13] = "WithdrawBalanceContract"] = 13;
                values[valuesById[14] = "UnfreezeAssetContract"] = 14;
                values[valuesById[15] = "UpdateAssetContract"] = 15;
                values[valuesById[16] = "ProposalCreateContract"] = 16;
                values[valuesById[17] = "ProposalApproveContract"] = 17;
                values[valuesById[18] = "ProposalDeleteContract"] = 18;
                values[valuesById[19] = "SetAccountIdContract"] = 19;
                values[valuesById[20] = "CustomContract"] = 20;
                values[valuesById[30] = "CreateSmartContract"] = 30;
                values[valuesById[31] = "TriggerSmartContract"] = 31;
                values[valuesById[32] = "GetContract"] = 32;
                values[valuesById[33] = "UpdateSettingContract"] = 33;
                values[valuesById[41] = "ExchangeCreateContract"] = 41;
                values[valuesById[42] = "ExchangeInjectContract"] = 42;
                values[valuesById[43] = "ExchangeWithdrawContract"] = 43;
                values[valuesById[44] = "ExchangeTransactionContract"] = 44;
                values[valuesById[45] = "UpdateEnergyLimitContract"] = 45;
                values[valuesById[46] = "AccountPermissionUpdateContract"] = 46;
                values[valuesById[48] = "ClearABIContract"] = 48;
                return values;
            })();

            return Contract;
        })();

        Transaction.Result = (function() {

            /**
             * Properties of a Result.
             * @memberof protocol.Transaction
             * @interface IResult
             * @property {number|Long|null} [fee] Result fee
             * @property {protocol.Transaction.Result.code|null} [ret] Result ret
             * @property {protocol.Transaction.Result.contractResult|null} [contractRet] Result contractRet
             * @property {string|null} [assetIssueID] Result assetIssueID
             * @property {number|Long|null} [withdraw_amount] Result withdraw_amount
             * @property {number|Long|null} [unfreeze_amount] Result unfreeze_amount
             * @property {number|Long|null} [exchange_received_amount] Result exchange_received_amount
             * @property {number|Long|null} [exchange_inject_another_amount] Result exchange_inject_another_amount
             * @property {number|Long|null} [exchange_withdraw_another_amount] Result exchange_withdraw_another_amount
             * @property {number|Long|null} [exchange_id] Result exchange_id
             */

            /**
             * Constructs a new Result.
             * @memberof protocol.Transaction
             * @classdesc Represents a Result.
             * @implements IResult
             * @constructor
             * @param {protocol.Transaction.IResult=} [properties] Properties to set
             */
            function Result(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Result fee.
             * @member {number|Long} fee
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result ret.
             * @member {protocol.Transaction.Result.code} ret
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.ret = 0;

            /**
             * Result contractRet.
             * @member {protocol.Transaction.Result.contractResult} contractRet
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.contractRet = 0;

            /**
             * Result assetIssueID.
             * @member {string} assetIssueID
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.assetIssueID = "";

            /**
             * Result withdraw_amount.
             * @member {number|Long} withdraw_amount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.withdraw_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result unfreeze_amount.
             * @member {number|Long} unfreeze_amount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.unfreeze_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchange_received_amount.
             * @member {number|Long} exchange_received_amount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchange_received_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchange_inject_another_amount.
             * @member {number|Long} exchange_inject_another_amount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchange_inject_another_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchange_withdraw_another_amount.
             * @member {number|Long} exchange_withdraw_another_amount
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchange_withdraw_another_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Result exchange_id.
             * @member {number|Long} exchange_id
             * @memberof protocol.Transaction.Result
             * @instance
             */
            Result.prototype.exchange_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new Result instance using the specified properties.
             * @function create
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.IResult=} [properties] Properties to set
             * @returns {protocol.Transaction.Result} Result instance
             */
            Result.create = function create(properties) {
                return new Result(properties);
            };

            /**
             * Encodes the specified Result message. Does not implicitly {@link protocol.Transaction.Result.verify|verify} messages.
             * @function encode
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.IResult} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Result.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fee != null && message.hasOwnProperty("fee"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fee);
                if (message.ret != null && message.hasOwnProperty("ret"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.contractRet);
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.assetIssueID);
                if (message.withdraw_amount != null && message.hasOwnProperty("withdraw_amount"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.withdraw_amount);
                if (message.unfreeze_amount != null && message.hasOwnProperty("unfreeze_amount"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int64(message.unfreeze_amount);
                if (message.exchange_received_amount != null && message.hasOwnProperty("exchange_received_amount"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.exchange_received_amount);
                if (message.exchange_inject_another_amount != null && message.hasOwnProperty("exchange_inject_another_amount"))
                    writer.uint32(/* id 19, wireType 0 =*/152).int64(message.exchange_inject_another_amount);
                if (message.exchange_withdraw_another_amount != null && message.hasOwnProperty("exchange_withdraw_another_amount"))
                    writer.uint32(/* id 20, wireType 0 =*/160).int64(message.exchange_withdraw_another_amount);
                if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                    writer.uint32(/* id 21, wireType 0 =*/168).int64(message.exchange_id);
                return writer;
            };

            /**
             * Encodes the specified Result message, length delimited. Does not implicitly {@link protocol.Transaction.Result.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.IResult} message Result message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Result.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Result message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Transaction.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Transaction.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Result.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.Result();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.fee = reader.int64();
                        break;
                    case 2:
                        message.ret = reader.int32();
                        break;
                    case 3:
                        message.contractRet = reader.int32();
                        break;
                    case 14:
                        message.assetIssueID = reader.string();
                        break;
                    case 15:
                        message.withdraw_amount = reader.int64();
                        break;
                    case 16:
                        message.unfreeze_amount = reader.int64();
                        break;
                    case 18:
                        message.exchange_received_amount = reader.int64();
                        break;
                    case 19:
                        message.exchange_inject_another_amount = reader.int64();
                        break;
                    case 20:
                        message.exchange_withdraw_another_amount = reader.int64();
                        break;
                    case 21:
                        message.exchange_id = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Result message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Transaction.Result
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Transaction.Result} Result
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Result.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Result message.
             * @function verify
             * @memberof protocol.Transaction.Result
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Result.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fee != null && message.hasOwnProperty("fee"))
                    if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                        return "fee: integer|Long expected";
                if (message.ret != null && message.hasOwnProperty("ret"))
                    switch (message.ret) {
                    default:
                        return "ret: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    switch (message.contractRet) {
                    default:
                        return "contractRet: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                    }
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    if (!$util.isString(message.assetIssueID))
                        return "assetIssueID: string expected";
                if (message.withdraw_amount != null && message.hasOwnProperty("withdraw_amount"))
                    if (!$util.isInteger(message.withdraw_amount) && !(message.withdraw_amount && $util.isInteger(message.withdraw_amount.low) && $util.isInteger(message.withdraw_amount.high)))
                        return "withdraw_amount: integer|Long expected";
                if (message.unfreeze_amount != null && message.hasOwnProperty("unfreeze_amount"))
                    if (!$util.isInteger(message.unfreeze_amount) && !(message.unfreeze_amount && $util.isInteger(message.unfreeze_amount.low) && $util.isInteger(message.unfreeze_amount.high)))
                        return "unfreeze_amount: integer|Long expected";
                if (message.exchange_received_amount != null && message.hasOwnProperty("exchange_received_amount"))
                    if (!$util.isInteger(message.exchange_received_amount) && !(message.exchange_received_amount && $util.isInteger(message.exchange_received_amount.low) && $util.isInteger(message.exchange_received_amount.high)))
                        return "exchange_received_amount: integer|Long expected";
                if (message.exchange_inject_another_amount != null && message.hasOwnProperty("exchange_inject_another_amount"))
                    if (!$util.isInteger(message.exchange_inject_another_amount) && !(message.exchange_inject_another_amount && $util.isInteger(message.exchange_inject_another_amount.low) && $util.isInteger(message.exchange_inject_another_amount.high)))
                        return "exchange_inject_another_amount: integer|Long expected";
                if (message.exchange_withdraw_another_amount != null && message.hasOwnProperty("exchange_withdraw_another_amount"))
                    if (!$util.isInteger(message.exchange_withdraw_another_amount) && !(message.exchange_withdraw_another_amount && $util.isInteger(message.exchange_withdraw_another_amount.low) && $util.isInteger(message.exchange_withdraw_another_amount.high)))
                        return "exchange_withdraw_another_amount: integer|Long expected";
                if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                    if (!$util.isInteger(message.exchange_id) && !(message.exchange_id && $util.isInteger(message.exchange_id.low) && $util.isInteger(message.exchange_id.high)))
                        return "exchange_id: integer|Long expected";
                return null;
            };

            /**
             * Creates a Result message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Transaction.Result
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Transaction.Result} Result
             */
            Result.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.Result)
                    return object;
                var message = new $root.protocol.Transaction.Result();
                if (object.fee != null)
                    if ($util.Long)
                        (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                    else if (typeof object.fee === "string")
                        message.fee = parseInt(object.fee, 10);
                    else if (typeof object.fee === "number")
                        message.fee = object.fee;
                    else if (typeof object.fee === "object")
                        message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
                switch (object.ret) {
                case "SUCESS":
                case 0:
                    message.ret = 0;
                    break;
                case "FAILED":
                case 1:
                    message.ret = 1;
                    break;
                }
                switch (object.contractRet) {
                case "DEFAULT":
                case 0:
                    message.contractRet = 0;
                    break;
                case "SUCCESS":
                case 1:
                    message.contractRet = 1;
                    break;
                case "REVERT":
                case 2:
                    message.contractRet = 2;
                    break;
                case "BAD_JUMP_DESTINATION":
                case 3:
                    message.contractRet = 3;
                    break;
                case "OUT_OF_MEMORY":
                case 4:
                    message.contractRet = 4;
                    break;
                case "PRECOMPILED_CONTRACT":
                case 5:
                    message.contractRet = 5;
                    break;
                case "STACK_TOO_SMALL":
                case 6:
                    message.contractRet = 6;
                    break;
                case "STACK_TOO_LARGE":
                case 7:
                    message.contractRet = 7;
                    break;
                case "ILLEGAL_OPERATION":
                case 8:
                    message.contractRet = 8;
                    break;
                case "STACK_OVERFLOW":
                case 9:
                    message.contractRet = 9;
                    break;
                case "OUT_OF_ENERGY":
                case 10:
                    message.contractRet = 10;
                    break;
                case "OUT_OF_TIME":
                case 11:
                    message.contractRet = 11;
                    break;
                case "JVM_STACK_OVER_FLOW":
                case 12:
                    message.contractRet = 12;
                    break;
                case "UNKNOWN":
                case 13:
                    message.contractRet = 13;
                    break;
                case "TRANSFER_FAILED":
                case 14:
                    message.contractRet = 14;
                    break;
                }
                if (object.assetIssueID != null)
                    message.assetIssueID = String(object.assetIssueID);
                if (object.withdraw_amount != null)
                    if ($util.Long)
                        (message.withdraw_amount = $util.Long.fromValue(object.withdraw_amount)).unsigned = false;
                    else if (typeof object.withdraw_amount === "string")
                        message.withdraw_amount = parseInt(object.withdraw_amount, 10);
                    else if (typeof object.withdraw_amount === "number")
                        message.withdraw_amount = object.withdraw_amount;
                    else if (typeof object.withdraw_amount === "object")
                        message.withdraw_amount = new $util.LongBits(object.withdraw_amount.low >>> 0, object.withdraw_amount.high >>> 0).toNumber();
                if (object.unfreeze_amount != null)
                    if ($util.Long)
                        (message.unfreeze_amount = $util.Long.fromValue(object.unfreeze_amount)).unsigned = false;
                    else if (typeof object.unfreeze_amount === "string")
                        message.unfreeze_amount = parseInt(object.unfreeze_amount, 10);
                    else if (typeof object.unfreeze_amount === "number")
                        message.unfreeze_amount = object.unfreeze_amount;
                    else if (typeof object.unfreeze_amount === "object")
                        message.unfreeze_amount = new $util.LongBits(object.unfreeze_amount.low >>> 0, object.unfreeze_amount.high >>> 0).toNumber();
                if (object.exchange_received_amount != null)
                    if ($util.Long)
                        (message.exchange_received_amount = $util.Long.fromValue(object.exchange_received_amount)).unsigned = false;
                    else if (typeof object.exchange_received_amount === "string")
                        message.exchange_received_amount = parseInt(object.exchange_received_amount, 10);
                    else if (typeof object.exchange_received_amount === "number")
                        message.exchange_received_amount = object.exchange_received_amount;
                    else if (typeof object.exchange_received_amount === "object")
                        message.exchange_received_amount = new $util.LongBits(object.exchange_received_amount.low >>> 0, object.exchange_received_amount.high >>> 0).toNumber();
                if (object.exchange_inject_another_amount != null)
                    if ($util.Long)
                        (message.exchange_inject_another_amount = $util.Long.fromValue(object.exchange_inject_another_amount)).unsigned = false;
                    else if (typeof object.exchange_inject_another_amount === "string")
                        message.exchange_inject_another_amount = parseInt(object.exchange_inject_another_amount, 10);
                    else if (typeof object.exchange_inject_another_amount === "number")
                        message.exchange_inject_another_amount = object.exchange_inject_another_amount;
                    else if (typeof object.exchange_inject_another_amount === "object")
                        message.exchange_inject_another_amount = new $util.LongBits(object.exchange_inject_another_amount.low >>> 0, object.exchange_inject_another_amount.high >>> 0).toNumber();
                if (object.exchange_withdraw_another_amount != null)
                    if ($util.Long)
                        (message.exchange_withdraw_another_amount = $util.Long.fromValue(object.exchange_withdraw_another_amount)).unsigned = false;
                    else if (typeof object.exchange_withdraw_another_amount === "string")
                        message.exchange_withdraw_another_amount = parseInt(object.exchange_withdraw_another_amount, 10);
                    else if (typeof object.exchange_withdraw_another_amount === "number")
                        message.exchange_withdraw_another_amount = object.exchange_withdraw_another_amount;
                    else if (typeof object.exchange_withdraw_another_amount === "object")
                        message.exchange_withdraw_another_amount = new $util.LongBits(object.exchange_withdraw_another_amount.low >>> 0, object.exchange_withdraw_another_amount.high >>> 0).toNumber();
                if (object.exchange_id != null)
                    if ($util.Long)
                        (message.exchange_id = $util.Long.fromValue(object.exchange_id)).unsigned = false;
                    else if (typeof object.exchange_id === "string")
                        message.exchange_id = parseInt(object.exchange_id, 10);
                    else if (typeof object.exchange_id === "number")
                        message.exchange_id = object.exchange_id;
                    else if (typeof object.exchange_id === "object")
                        message.exchange_id = new $util.LongBits(object.exchange_id.low >>> 0, object.exchange_id.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a Result message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Transaction.Result
             * @static
             * @param {protocol.Transaction.Result} message Result
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Result.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fee = options.longs === String ? "0" : 0;
                    object.ret = options.enums === String ? "SUCESS" : 0;
                    object.contractRet = options.enums === String ? "DEFAULT" : 0;
                    object.assetIssueID = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.withdraw_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.withdraw_amount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unfreeze_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unfreeze_amount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchange_received_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchange_received_amount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchange_inject_another_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchange_inject_another_amount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchange_withdraw_another_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchange_withdraw_another_amount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.exchange_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.exchange_id = options.longs === String ? "0" : 0;
                }
                if (message.fee != null && message.hasOwnProperty("fee"))
                    if (typeof message.fee === "number")
                        object.fee = options.longs === String ? String(message.fee) : message.fee;
                    else
                        object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
                if (message.ret != null && message.hasOwnProperty("ret"))
                    object.ret = options.enums === String ? $root.protocol.Transaction.Result.code[message.ret] : message.ret;
                if (message.contractRet != null && message.hasOwnProperty("contractRet"))
                    object.contractRet = options.enums === String ? $root.protocol.Transaction.Result.contractResult[message.contractRet] : message.contractRet;
                if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                    object.assetIssueID = message.assetIssueID;
                if (message.withdraw_amount != null && message.hasOwnProperty("withdraw_amount"))
                    if (typeof message.withdraw_amount === "number")
                        object.withdraw_amount = options.longs === String ? String(message.withdraw_amount) : message.withdraw_amount;
                    else
                        object.withdraw_amount = options.longs === String ? $util.Long.prototype.toString.call(message.withdraw_amount) : options.longs === Number ? new $util.LongBits(message.withdraw_amount.low >>> 0, message.withdraw_amount.high >>> 0).toNumber() : message.withdraw_amount;
                if (message.unfreeze_amount != null && message.hasOwnProperty("unfreeze_amount"))
                    if (typeof message.unfreeze_amount === "number")
                        object.unfreeze_amount = options.longs === String ? String(message.unfreeze_amount) : message.unfreeze_amount;
                    else
                        object.unfreeze_amount = options.longs === String ? $util.Long.prototype.toString.call(message.unfreeze_amount) : options.longs === Number ? new $util.LongBits(message.unfreeze_amount.low >>> 0, message.unfreeze_amount.high >>> 0).toNumber() : message.unfreeze_amount;
                if (message.exchange_received_amount != null && message.hasOwnProperty("exchange_received_amount"))
                    if (typeof message.exchange_received_amount === "number")
                        object.exchange_received_amount = options.longs === String ? String(message.exchange_received_amount) : message.exchange_received_amount;
                    else
                        object.exchange_received_amount = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_received_amount) : options.longs === Number ? new $util.LongBits(message.exchange_received_amount.low >>> 0, message.exchange_received_amount.high >>> 0).toNumber() : message.exchange_received_amount;
                if (message.exchange_inject_another_amount != null && message.hasOwnProperty("exchange_inject_another_amount"))
                    if (typeof message.exchange_inject_another_amount === "number")
                        object.exchange_inject_another_amount = options.longs === String ? String(message.exchange_inject_another_amount) : message.exchange_inject_another_amount;
                    else
                        object.exchange_inject_another_amount = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_inject_another_amount) : options.longs === Number ? new $util.LongBits(message.exchange_inject_another_amount.low >>> 0, message.exchange_inject_another_amount.high >>> 0).toNumber() : message.exchange_inject_another_amount;
                if (message.exchange_withdraw_another_amount != null && message.hasOwnProperty("exchange_withdraw_another_amount"))
                    if (typeof message.exchange_withdraw_another_amount === "number")
                        object.exchange_withdraw_another_amount = options.longs === String ? String(message.exchange_withdraw_another_amount) : message.exchange_withdraw_another_amount;
                    else
                        object.exchange_withdraw_another_amount = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_withdraw_another_amount) : options.longs === Number ? new $util.LongBits(message.exchange_withdraw_another_amount.low >>> 0, message.exchange_withdraw_another_amount.high >>> 0).toNumber() : message.exchange_withdraw_another_amount;
                if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                    if (typeof message.exchange_id === "number")
                        object.exchange_id = options.longs === String ? String(message.exchange_id) : message.exchange_id;
                    else
                        object.exchange_id = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_id) : options.longs === Number ? new $util.LongBits(message.exchange_id.low >>> 0, message.exchange_id.high >>> 0).toNumber() : message.exchange_id;
                return object;
            };

            /**
             * Converts this Result to JSON.
             * @function toJSON
             * @memberof protocol.Transaction.Result
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Result.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * code enum.
             * @name protocol.Transaction.Result.code
             * @enum {string}
             * @property {number} SUCESS=0 SUCESS value
             * @property {number} FAILED=1 FAILED value
             */
            Result.code = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SUCESS"] = 0;
                values[valuesById[1] = "FAILED"] = 1;
                return values;
            })();

            /**
             * contractResult enum.
             * @name protocol.Transaction.Result.contractResult
             * @enum {string}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} SUCCESS=1 SUCCESS value
             * @property {number} REVERT=2 REVERT value
             * @property {number} BAD_JUMP_DESTINATION=3 BAD_JUMP_DESTINATION value
             * @property {number} OUT_OF_MEMORY=4 OUT_OF_MEMORY value
             * @property {number} PRECOMPILED_CONTRACT=5 PRECOMPILED_CONTRACT value
             * @property {number} STACK_TOO_SMALL=6 STACK_TOO_SMALL value
             * @property {number} STACK_TOO_LARGE=7 STACK_TOO_LARGE value
             * @property {number} ILLEGAL_OPERATION=8 ILLEGAL_OPERATION value
             * @property {number} STACK_OVERFLOW=9 STACK_OVERFLOW value
             * @property {number} OUT_OF_ENERGY=10 OUT_OF_ENERGY value
             * @property {number} OUT_OF_TIME=11 OUT_OF_TIME value
             * @property {number} JVM_STACK_OVER_FLOW=12 JVM_STACK_OVER_FLOW value
             * @property {number} UNKNOWN=13 UNKNOWN value
             * @property {number} TRANSFER_FAILED=14 TRANSFER_FAILED value
             */
            Result.contractResult = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "SUCCESS"] = 1;
                values[valuesById[2] = "REVERT"] = 2;
                values[valuesById[3] = "BAD_JUMP_DESTINATION"] = 3;
                values[valuesById[4] = "OUT_OF_MEMORY"] = 4;
                values[valuesById[5] = "PRECOMPILED_CONTRACT"] = 5;
                values[valuesById[6] = "STACK_TOO_SMALL"] = 6;
                values[valuesById[7] = "STACK_TOO_LARGE"] = 7;
                values[valuesById[8] = "ILLEGAL_OPERATION"] = 8;
                values[valuesById[9] = "STACK_OVERFLOW"] = 9;
                values[valuesById[10] = "OUT_OF_ENERGY"] = 10;
                values[valuesById[11] = "OUT_OF_TIME"] = 11;
                values[valuesById[12] = "JVM_STACK_OVER_FLOW"] = 12;
                values[valuesById[13] = "UNKNOWN"] = 13;
                values[valuesById[14] = "TRANSFER_FAILED"] = 14;
                return values;
            })();

            return Result;
        })();

        Transaction.raw = (function() {

            /**
             * Properties of a raw.
             * @memberof protocol.Transaction
             * @interface Iraw
             * @property {Uint8Array|null} [ref_block_bytes] raw ref_block_bytes
             * @property {number|Long|null} [ref_block_num] raw ref_block_num
             * @property {Uint8Array|null} [ref_block_hash] raw ref_block_hash
             * @property {number|Long|null} [expiration] raw expiration
             * @property {Array.<protocol.Iauthority>|null} [auths] raw auths
             * @property {Uint8Array|null} [data] raw data
             * @property {Array.<protocol.Transaction.IContract>|null} [contract] raw contract
             * @property {Uint8Array|null} [scripts] raw scripts
             * @property {number|Long|null} [timestamp] raw timestamp
             * @property {number|Long|null} [fee_limit] raw fee_limit
             */

            /**
             * Constructs a new raw.
             * @memberof protocol.Transaction
             * @classdesc Represents a raw.
             * @implements Iraw
             * @constructor
             * @param {protocol.Transaction.Iraw=} [properties] Properties to set
             */
            function raw(properties) {
                this.auths = [];
                this.contract = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * raw ref_block_bytes.
             * @member {Uint8Array} ref_block_bytes
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.ref_block_bytes = $util.newBuffer([]);

            /**
             * raw ref_block_num.
             * @member {number|Long} ref_block_num
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.ref_block_num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw ref_block_hash.
             * @member {Uint8Array} ref_block_hash
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.ref_block_hash = $util.newBuffer([]);

            /**
             * raw expiration.
             * @member {number|Long} expiration
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.expiration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw auths.
             * @member {Array.<protocol.Iauthority>} auths
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.auths = $util.emptyArray;

            /**
             * raw data.
             * @member {Uint8Array} data
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.data = $util.newBuffer([]);

            /**
             * raw contract.
             * @member {Array.<protocol.Transaction.IContract>} contract
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.contract = $util.emptyArray;

            /**
             * raw scripts.
             * @member {Uint8Array} scripts
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.scripts = $util.newBuffer([]);

            /**
             * raw timestamp.
             * @member {number|Long} timestamp
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw fee_limit.
             * @member {number|Long} fee_limit
             * @memberof protocol.Transaction.raw
             * @instance
             */
            raw.prototype.fee_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new raw instance using the specified properties.
             * @function create
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.Iraw=} [properties] Properties to set
             * @returns {protocol.Transaction.raw} raw instance
             */
            raw.create = function create(properties) {
                return new raw(properties);
            };

            /**
             * Encodes the specified raw message. Does not implicitly {@link protocol.Transaction.raw.verify|verify} messages.
             * @function encode
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ref_block_bytes != null && message.hasOwnProperty("ref_block_bytes"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.ref_block_bytes);
                if (message.ref_block_num != null && message.hasOwnProperty("ref_block_num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.ref_block_num);
                if (message.ref_block_hash != null && message.hasOwnProperty("ref_block_hash"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.ref_block_hash);
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.expiration);
                if (message.auths != null && message.auths.length)
                    for (var i = 0; i < message.auths.length; ++i)
                        $root.protocol.authority.encode(message.auths[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.data);
                if (message.contract != null && message.contract.length)
                    for (var i = 0; i < message.contract.length; ++i)
                        $root.protocol.Transaction.Contract.encode(message.contract[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.scripts);
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.timestamp);
                if (message.fee_limit != null && message.hasOwnProperty("fee_limit"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.fee_limit);
                return writer;
            };

            /**
             * Encodes the specified raw message, length delimited. Does not implicitly {@link protocol.Transaction.raw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a raw message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.Transaction.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.Transaction.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transaction.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ref_block_bytes = reader.bytes();
                        break;
                    case 3:
                        message.ref_block_num = reader.int64();
                        break;
                    case 4:
                        message.ref_block_hash = reader.bytes();
                        break;
                    case 8:
                        message.expiration = reader.int64();
                        break;
                    case 9:
                        if (!(message.auths && message.auths.length))
                            message.auths = [];
                        message.auths.push($root.protocol.authority.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.data = reader.bytes();
                        break;
                    case 11:
                        if (!(message.contract && message.contract.length))
                            message.contract = [];
                        message.contract.push($root.protocol.Transaction.Contract.decode(reader, reader.uint32()));
                        break;
                    case 12:
                        message.scripts = reader.bytes();
                        break;
                    case 14:
                        message.timestamp = reader.int64();
                        break;
                    case 18:
                        message.fee_limit = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a raw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.Transaction.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.Transaction.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a raw message.
             * @function verify
             * @memberof protocol.Transaction.raw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ref_block_bytes != null && message.hasOwnProperty("ref_block_bytes"))
                    if (!(message.ref_block_bytes && typeof message.ref_block_bytes.length === "number" || $util.isString(message.ref_block_bytes)))
                        return "ref_block_bytes: buffer expected";
                if (message.ref_block_num != null && message.hasOwnProperty("ref_block_num"))
                    if (!$util.isInteger(message.ref_block_num) && !(message.ref_block_num && $util.isInteger(message.ref_block_num.low) && $util.isInteger(message.ref_block_num.high)))
                        return "ref_block_num: integer|Long expected";
                if (message.ref_block_hash != null && message.hasOwnProperty("ref_block_hash"))
                    if (!(message.ref_block_hash && typeof message.ref_block_hash.length === "number" || $util.isString(message.ref_block_hash)))
                        return "ref_block_hash: buffer expected";
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (!$util.isInteger(message.expiration) && !(message.expiration && $util.isInteger(message.expiration.low) && $util.isInteger(message.expiration.high)))
                        return "expiration: integer|Long expected";
                if (message.auths != null && message.hasOwnProperty("auths")) {
                    if (!Array.isArray(message.auths))
                        return "auths: array expected";
                    for (var i = 0; i < message.auths.length; ++i) {
                        var error = $root.protocol.authority.verify(message.auths[i]);
                        if (error)
                            return "auths." + error;
                    }
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                if (message.contract != null && message.hasOwnProperty("contract")) {
                    if (!Array.isArray(message.contract))
                        return "contract: array expected";
                    for (var i = 0; i < message.contract.length; ++i) {
                        var error = $root.protocol.Transaction.Contract.verify(message.contract[i]);
                        if (error)
                            return "contract." + error;
                    }
                }
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    if (!(message.scripts && typeof message.scripts.length === "number" || $util.isString(message.scripts)))
                        return "scripts: buffer expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.fee_limit != null && message.hasOwnProperty("fee_limit"))
                    if (!$util.isInteger(message.fee_limit) && !(message.fee_limit && $util.isInteger(message.fee_limit.low) && $util.isInteger(message.fee_limit.high)))
                        return "fee_limit: integer|Long expected";
                return null;
            };

            /**
             * Creates a raw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.Transaction.raw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.Transaction.raw} raw
             */
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.Transaction.raw)
                    return object;
                var message = new $root.protocol.Transaction.raw();
                if (object.ref_block_bytes != null)
                    if (typeof object.ref_block_bytes === "string")
                        $util.base64.decode(object.ref_block_bytes, message.ref_block_bytes = $util.newBuffer($util.base64.length(object.ref_block_bytes)), 0);
                    else if (object.ref_block_bytes.length)
                        message.ref_block_bytes = object.ref_block_bytes;
                if (object.ref_block_num != null)
                    if ($util.Long)
                        (message.ref_block_num = $util.Long.fromValue(object.ref_block_num)).unsigned = false;
                    else if (typeof object.ref_block_num === "string")
                        message.ref_block_num = parseInt(object.ref_block_num, 10);
                    else if (typeof object.ref_block_num === "number")
                        message.ref_block_num = object.ref_block_num;
                    else if (typeof object.ref_block_num === "object")
                        message.ref_block_num = new $util.LongBits(object.ref_block_num.low >>> 0, object.ref_block_num.high >>> 0).toNumber();
                if (object.ref_block_hash != null)
                    if (typeof object.ref_block_hash === "string")
                        $util.base64.decode(object.ref_block_hash, message.ref_block_hash = $util.newBuffer($util.base64.length(object.ref_block_hash)), 0);
                    else if (object.ref_block_hash.length)
                        message.ref_block_hash = object.ref_block_hash;
                if (object.expiration != null)
                    if ($util.Long)
                        (message.expiration = $util.Long.fromValue(object.expiration)).unsigned = false;
                    else if (typeof object.expiration === "string")
                        message.expiration = parseInt(object.expiration, 10);
                    else if (typeof object.expiration === "number")
                        message.expiration = object.expiration;
                    else if (typeof object.expiration === "object")
                        message.expiration = new $util.LongBits(object.expiration.low >>> 0, object.expiration.high >>> 0).toNumber();
                if (object.auths) {
                    if (!Array.isArray(object.auths))
                        throw TypeError(".protocol.Transaction.raw.auths: array expected");
                    message.auths = [];
                    for (var i = 0; i < object.auths.length; ++i) {
                        if (typeof object.auths[i] !== "object")
                            throw TypeError(".protocol.Transaction.raw.auths: object expected");
                        message.auths[i] = $root.protocol.authority.fromObject(object.auths[i]);
                    }
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                if (object.contract) {
                    if (!Array.isArray(object.contract))
                        throw TypeError(".protocol.Transaction.raw.contract: array expected");
                    message.contract = [];
                    for (var i = 0; i < object.contract.length; ++i) {
                        if (typeof object.contract[i] !== "object")
                            throw TypeError(".protocol.Transaction.raw.contract: object expected");
                        message.contract[i] = $root.protocol.Transaction.Contract.fromObject(object.contract[i]);
                    }
                }
                if (object.scripts != null)
                    if (typeof object.scripts === "string")
                        $util.base64.decode(object.scripts, message.scripts = $util.newBuffer($util.base64.length(object.scripts)), 0);
                    else if (object.scripts.length)
                        message.scripts = object.scripts;
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.fee_limit != null)
                    if ($util.Long)
                        (message.fee_limit = $util.Long.fromValue(object.fee_limit)).unsigned = false;
                    else if (typeof object.fee_limit === "string")
                        message.fee_limit = parseInt(object.fee_limit, 10);
                    else if (typeof object.fee_limit === "number")
                        message.fee_limit = object.fee_limit;
                    else if (typeof object.fee_limit === "object")
                        message.fee_limit = new $util.LongBits(object.fee_limit.low >>> 0, object.fee_limit.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a raw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.Transaction.raw
             * @static
             * @param {protocol.Transaction.raw} message raw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.auths = [];
                    object.contract = [];
                }
                if (options.defaults) {
                    if (options.bytes === String)
                        object.ref_block_bytes = "";
                    else {
                        object.ref_block_bytes = [];
                        if (options.bytes !== Array)
                            object.ref_block_bytes = $util.newBuffer(object.ref_block_bytes);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.ref_block_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ref_block_num = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.ref_block_hash = "";
                    else {
                        object.ref_block_hash = [];
                        if (options.bytes !== Array)
                            object.ref_block_hash = $util.newBuffer(object.ref_block_hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.expiration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.expiration = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                    if (options.bytes === String)
                        object.scripts = "";
                    else {
                        object.scripts = [];
                        if (options.bytes !== Array)
                            object.scripts = $util.newBuffer(object.scripts);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.fee_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fee_limit = options.longs === String ? "0" : 0;
                }
                if (message.ref_block_bytes != null && message.hasOwnProperty("ref_block_bytes"))
                    object.ref_block_bytes = options.bytes === String ? $util.base64.encode(message.ref_block_bytes, 0, message.ref_block_bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.ref_block_bytes) : message.ref_block_bytes;
                if (message.ref_block_num != null && message.hasOwnProperty("ref_block_num"))
                    if (typeof message.ref_block_num === "number")
                        object.ref_block_num = options.longs === String ? String(message.ref_block_num) : message.ref_block_num;
                    else
                        object.ref_block_num = options.longs === String ? $util.Long.prototype.toString.call(message.ref_block_num) : options.longs === Number ? new $util.LongBits(message.ref_block_num.low >>> 0, message.ref_block_num.high >>> 0).toNumber() : message.ref_block_num;
                if (message.ref_block_hash != null && message.hasOwnProperty("ref_block_hash"))
                    object.ref_block_hash = options.bytes === String ? $util.base64.encode(message.ref_block_hash, 0, message.ref_block_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.ref_block_hash) : message.ref_block_hash;
                if (message.expiration != null && message.hasOwnProperty("expiration"))
                    if (typeof message.expiration === "number")
                        object.expiration = options.longs === String ? String(message.expiration) : message.expiration;
                    else
                        object.expiration = options.longs === String ? $util.Long.prototype.toString.call(message.expiration) : options.longs === Number ? new $util.LongBits(message.expiration.low >>> 0, message.expiration.high >>> 0).toNumber() : message.expiration;
                if (message.auths && message.auths.length) {
                    object.auths = [];
                    for (var j = 0; j < message.auths.length; ++j)
                        object.auths[j] = $root.protocol.authority.toObject(message.auths[j], options);
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                if (message.contract && message.contract.length) {
                    object.contract = [];
                    for (var j = 0; j < message.contract.length; ++j)
                        object.contract[j] = $root.protocol.Transaction.Contract.toObject(message.contract[j], options);
                }
                if (message.scripts != null && message.hasOwnProperty("scripts"))
                    object.scripts = options.bytes === String ? $util.base64.encode(message.scripts, 0, message.scripts.length) : options.bytes === Array ? Array.prototype.slice.call(message.scripts) : message.scripts;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.fee_limit != null && message.hasOwnProperty("fee_limit"))
                    if (typeof message.fee_limit === "number")
                        object.fee_limit = options.longs === String ? String(message.fee_limit) : message.fee_limit;
                    else
                        object.fee_limit = options.longs === String ? $util.Long.prototype.toString.call(message.fee_limit) : options.longs === Number ? new $util.LongBits(message.fee_limit.low >>> 0, message.fee_limit.high >>> 0).toNumber() : message.fee_limit;
                return object;
            };

            /**
             * Converts this raw to JSON.
             * @function toJSON
             * @memberof protocol.Transaction.raw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return raw;
        })();

        return Transaction;
    })();

    protocol.TransactionInfo = (function() {

        /**
         * Properties of a TransactionInfo.
         * @memberof protocol
         * @interface ITransactionInfo
         * @property {Uint8Array|null} [id] TransactionInfo id
         * @property {number|Long|null} [fee] TransactionInfo fee
         * @property {number|Long|null} [blockNumber] TransactionInfo blockNumber
         * @property {number|Long|null} [blockTimeStamp] TransactionInfo blockTimeStamp
         * @property {Array.<Uint8Array>|null} [contractResult] TransactionInfo contractResult
         * @property {Uint8Array|null} [contract_address] TransactionInfo contract_address
         * @property {protocol.IResourceReceipt|null} [receipt] TransactionInfo receipt
         * @property {Array.<protocol.TransactionInfo.ILog>|null} [log] TransactionInfo log
         * @property {protocol.TransactionInfo.code|null} [result] TransactionInfo result
         * @property {Uint8Array|null} [resMessage] TransactionInfo resMessage
         * @property {string|null} [assetIssueID] TransactionInfo assetIssueID
         * @property {number|Long|null} [withdraw_amount] TransactionInfo withdraw_amount
         * @property {number|Long|null} [unfreeze_amount] TransactionInfo unfreeze_amount
         * @property {Array.<protocol.IInternalTransaction>|null} [internal_transactions] TransactionInfo internal_transactions
         * @property {number|Long|null} [exchange_received_amount] TransactionInfo exchange_received_amount
         * @property {number|Long|null} [exchange_inject_another_amount] TransactionInfo exchange_inject_another_amount
         * @property {number|Long|null} [exchange_withdraw_another_amount] TransactionInfo exchange_withdraw_another_amount
         * @property {number|Long|null} [exchange_id] TransactionInfo exchange_id
         */

        /**
         * Constructs a new TransactionInfo.
         * @memberof protocol
         * @classdesc Represents a TransactionInfo.
         * @implements ITransactionInfo
         * @constructor
         * @param {protocol.ITransactionInfo=} [properties] Properties to set
         */
        function TransactionInfo(properties) {
            this.contractResult = [];
            this.log = [];
            this.internal_transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionInfo id.
         * @member {Uint8Array} id
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.id = $util.newBuffer([]);

        /**
         * TransactionInfo fee.
         * @member {number|Long} fee
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo blockNumber.
         * @member {number|Long} blockNumber
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo blockTimeStamp.
         * @member {number|Long} blockTimeStamp
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.blockTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo contractResult.
         * @member {Array.<Uint8Array>} contractResult
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.contractResult = $util.emptyArray;

        /**
         * TransactionInfo contract_address.
         * @member {Uint8Array} contract_address
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.contract_address = $util.newBuffer([]);

        /**
         * TransactionInfo receipt.
         * @member {protocol.IResourceReceipt|null|undefined} receipt
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.receipt = null;

        /**
         * TransactionInfo log.
         * @member {Array.<protocol.TransactionInfo.ILog>} log
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.log = $util.emptyArray;

        /**
         * TransactionInfo result.
         * @member {protocol.TransactionInfo.code} result
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.result = 0;

        /**
         * TransactionInfo resMessage.
         * @member {Uint8Array} resMessage
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.resMessage = $util.newBuffer([]);

        /**
         * TransactionInfo assetIssueID.
         * @member {string} assetIssueID
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.assetIssueID = "";

        /**
         * TransactionInfo withdraw_amount.
         * @member {number|Long} withdraw_amount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.withdraw_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo unfreeze_amount.
         * @member {number|Long} unfreeze_amount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.unfreeze_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo internal_transactions.
         * @member {Array.<protocol.IInternalTransaction>} internal_transactions
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.internal_transactions = $util.emptyArray;

        /**
         * TransactionInfo exchange_received_amount.
         * @member {number|Long} exchange_received_amount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchange_received_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo exchange_inject_another_amount.
         * @member {number|Long} exchange_inject_another_amount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchange_inject_another_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo exchange_withdraw_another_amount.
         * @member {number|Long} exchange_withdraw_another_amount
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchange_withdraw_another_amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionInfo exchange_id.
         * @member {number|Long} exchange_id
         * @memberof protocol.TransactionInfo
         * @instance
         */
        TransactionInfo.prototype.exchange_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TransactionInfo instance using the specified properties.
         * @function create
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.ITransactionInfo=} [properties] Properties to set
         * @returns {protocol.TransactionInfo} TransactionInfo instance
         */
        TransactionInfo.create = function create(properties) {
            return new TransactionInfo(properties);
        };

        /**
         * Encodes the specified TransactionInfo message. Does not implicitly {@link protocol.TransactionInfo.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.ITransactionInfo} message TransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.fee);
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.blockNumber);
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.blockTimeStamp);
            if (message.contractResult != null && message.contractResult.length)
                for (var i = 0; i < message.contractResult.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.contractResult[i]);
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.contract_address);
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                $root.protocol.ResourceReceipt.encode(message.receipt, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.log != null && message.log.length)
                for (var i = 0; i < message.log.length; ++i)
                    $root.protocol.TransactionInfo.Log.encode(message.log[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.result);
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.resMessage);
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.assetIssueID);
            if (message.withdraw_amount != null && message.hasOwnProperty("withdraw_amount"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.withdraw_amount);
            if (message.unfreeze_amount != null && message.hasOwnProperty("unfreeze_amount"))
                writer.uint32(/* id 16, wireType 0 =*/128).int64(message.unfreeze_amount);
            if (message.internal_transactions != null && message.internal_transactions.length)
                for (var i = 0; i < message.internal_transactions.length; ++i)
                    $root.protocol.InternalTransaction.encode(message.internal_transactions[i], writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.exchange_received_amount != null && message.hasOwnProperty("exchange_received_amount"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.exchange_received_amount);
            if (message.exchange_inject_another_amount != null && message.hasOwnProperty("exchange_inject_another_amount"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.exchange_inject_another_amount);
            if (message.exchange_withdraw_another_amount != null && message.hasOwnProperty("exchange_withdraw_another_amount"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.exchange_withdraw_another_amount);
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.exchange_id);
            return writer;
        };

        /**
         * Encodes the specified TransactionInfo message, length delimited. Does not implicitly {@link protocol.TransactionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.ITransactionInfo} message TransactionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransactionInfo} TransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.bytes();
                    break;
                case 2:
                    message.fee = reader.int64();
                    break;
                case 3:
                    message.blockNumber = reader.int64();
                    break;
                case 4:
                    message.blockTimeStamp = reader.int64();
                    break;
                case 5:
                    if (!(message.contractResult && message.contractResult.length))
                        message.contractResult = [];
                    message.contractResult.push(reader.bytes());
                    break;
                case 6:
                    message.contract_address = reader.bytes();
                    break;
                case 7:
                    message.receipt = $root.protocol.ResourceReceipt.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.log && message.log.length))
                        message.log = [];
                    message.log.push($root.protocol.TransactionInfo.Log.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.result = reader.int32();
                    break;
                case 10:
                    message.resMessage = reader.bytes();
                    break;
                case 14:
                    message.assetIssueID = reader.string();
                    break;
                case 15:
                    message.withdraw_amount = reader.int64();
                    break;
                case 16:
                    message.unfreeze_amount = reader.int64();
                    break;
                case 17:
                    if (!(message.internal_transactions && message.internal_transactions.length))
                        message.internal_transactions = [];
                    message.internal_transactions.push($root.protocol.InternalTransaction.decode(reader, reader.uint32()));
                    break;
                case 18:
                    message.exchange_received_amount = reader.int64();
                    break;
                case 19:
                    message.exchange_inject_another_amount = reader.int64();
                    break;
                case 20:
                    message.exchange_withdraw_another_amount = reader.int64();
                    break;
                case 21:
                    message.exchange_id = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransactionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransactionInfo} TransactionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionInfo message.
         * @function verify
         * @memberof protocol.TransactionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                    return "id: buffer expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (!$util.isInteger(message.blockTimeStamp) && !(message.blockTimeStamp && $util.isInteger(message.blockTimeStamp.low) && $util.isInteger(message.blockTimeStamp.high)))
                    return "blockTimeStamp: integer|Long expected";
            if (message.contractResult != null && message.hasOwnProperty("contractResult")) {
                if (!Array.isArray(message.contractResult))
                    return "contractResult: array expected";
                for (var i = 0; i < message.contractResult.length; ++i)
                    if (!(message.contractResult[i] && typeof message.contractResult[i].length === "number" || $util.isString(message.contractResult[i])))
                        return "contractResult: buffer[] expected";
            }
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                if (!(message.contract_address && typeof message.contract_address.length === "number" || $util.isString(message.contract_address)))
                    return "contract_address: buffer expected";
            if (message.receipt != null && message.hasOwnProperty("receipt")) {
                var error = $root.protocol.ResourceReceipt.verify(message.receipt);
                if (error)
                    return "receipt." + error;
            }
            if (message.log != null && message.hasOwnProperty("log")) {
                if (!Array.isArray(message.log))
                    return "log: array expected";
                for (var i = 0; i < message.log.length; ++i) {
                    var error = $root.protocol.TransactionInfo.Log.verify(message.log[i]);
                    if (error)
                        return "log." + error;
                }
            }
            if (message.result != null && message.hasOwnProperty("result"))
                switch (message.result) {
                default:
                    return "result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                if (!(message.resMessage && typeof message.resMessage.length === "number" || $util.isString(message.resMessage)))
                    return "resMessage: buffer expected";
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                if (!$util.isString(message.assetIssueID))
                    return "assetIssueID: string expected";
            if (message.withdraw_amount != null && message.hasOwnProperty("withdraw_amount"))
                if (!$util.isInteger(message.withdraw_amount) && !(message.withdraw_amount && $util.isInteger(message.withdraw_amount.low) && $util.isInteger(message.withdraw_amount.high)))
                    return "withdraw_amount: integer|Long expected";
            if (message.unfreeze_amount != null && message.hasOwnProperty("unfreeze_amount"))
                if (!$util.isInteger(message.unfreeze_amount) && !(message.unfreeze_amount && $util.isInteger(message.unfreeze_amount.low) && $util.isInteger(message.unfreeze_amount.high)))
                    return "unfreeze_amount: integer|Long expected";
            if (message.internal_transactions != null && message.hasOwnProperty("internal_transactions")) {
                if (!Array.isArray(message.internal_transactions))
                    return "internal_transactions: array expected";
                for (var i = 0; i < message.internal_transactions.length; ++i) {
                    var error = $root.protocol.InternalTransaction.verify(message.internal_transactions[i]);
                    if (error)
                        return "internal_transactions." + error;
                }
            }
            if (message.exchange_received_amount != null && message.hasOwnProperty("exchange_received_amount"))
                if (!$util.isInteger(message.exchange_received_amount) && !(message.exchange_received_amount && $util.isInteger(message.exchange_received_amount.low) && $util.isInteger(message.exchange_received_amount.high)))
                    return "exchange_received_amount: integer|Long expected";
            if (message.exchange_inject_another_amount != null && message.hasOwnProperty("exchange_inject_another_amount"))
                if (!$util.isInteger(message.exchange_inject_another_amount) && !(message.exchange_inject_another_amount && $util.isInteger(message.exchange_inject_another_amount.low) && $util.isInteger(message.exchange_inject_another_amount.high)))
                    return "exchange_inject_another_amount: integer|Long expected";
            if (message.exchange_withdraw_another_amount != null && message.hasOwnProperty("exchange_withdraw_another_amount"))
                if (!$util.isInteger(message.exchange_withdraw_another_amount) && !(message.exchange_withdraw_another_amount && $util.isInteger(message.exchange_withdraw_another_amount.low) && $util.isInteger(message.exchange_withdraw_another_amount.high)))
                    return "exchange_withdraw_another_amount: integer|Long expected";
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (!$util.isInteger(message.exchange_id) && !(message.exchange_id && $util.isInteger(message.exchange_id.low) && $util.isInteger(message.exchange_id.high)))
                    return "exchange_id: integer|Long expected";
            return null;
        };

        /**
         * Creates a TransactionInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransactionInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransactionInfo} TransactionInfo
         */
        TransactionInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionInfo)
                return object;
            var message = new $root.protocol.TransactionInfo();
            if (object.id != null)
                if (typeof object.id === "string")
                    $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                else if (object.id.length)
                    message.id = object.id;
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.blockTimeStamp != null)
                if ($util.Long)
                    (message.blockTimeStamp = $util.Long.fromValue(object.blockTimeStamp)).unsigned = false;
                else if (typeof object.blockTimeStamp === "string")
                    message.blockTimeStamp = parseInt(object.blockTimeStamp, 10);
                else if (typeof object.blockTimeStamp === "number")
                    message.blockTimeStamp = object.blockTimeStamp;
                else if (typeof object.blockTimeStamp === "object")
                    message.blockTimeStamp = new $util.LongBits(object.blockTimeStamp.low >>> 0, object.blockTimeStamp.high >>> 0).toNumber();
            if (object.contractResult) {
                if (!Array.isArray(object.contractResult))
                    throw TypeError(".protocol.TransactionInfo.contractResult: array expected");
                message.contractResult = [];
                for (var i = 0; i < object.contractResult.length; ++i)
                    if (typeof object.contractResult[i] === "string")
                        $util.base64.decode(object.contractResult[i], message.contractResult[i] = $util.newBuffer($util.base64.length(object.contractResult[i])), 0);
                    else if (object.contractResult[i].length)
                        message.contractResult[i] = object.contractResult[i];
            }
            if (object.contract_address != null)
                if (typeof object.contract_address === "string")
                    $util.base64.decode(object.contract_address, message.contract_address = $util.newBuffer($util.base64.length(object.contract_address)), 0);
                else if (object.contract_address.length)
                    message.contract_address = object.contract_address;
            if (object.receipt != null) {
                if (typeof object.receipt !== "object")
                    throw TypeError(".protocol.TransactionInfo.receipt: object expected");
                message.receipt = $root.protocol.ResourceReceipt.fromObject(object.receipt);
            }
            if (object.log) {
                if (!Array.isArray(object.log))
                    throw TypeError(".protocol.TransactionInfo.log: array expected");
                message.log = [];
                for (var i = 0; i < object.log.length; ++i) {
                    if (typeof object.log[i] !== "object")
                        throw TypeError(".protocol.TransactionInfo.log: object expected");
                    message.log[i] = $root.protocol.TransactionInfo.Log.fromObject(object.log[i]);
                }
            }
            switch (object.result) {
            case "SUCESS":
            case 0:
                message.result = 0;
                break;
            case "FAILED":
            case 1:
                message.result = 1;
                break;
            }
            if (object.resMessage != null)
                if (typeof object.resMessage === "string")
                    $util.base64.decode(object.resMessage, message.resMessage = $util.newBuffer($util.base64.length(object.resMessage)), 0);
                else if (object.resMessage.length)
                    message.resMessage = object.resMessage;
            if (object.assetIssueID != null)
                message.assetIssueID = String(object.assetIssueID);
            if (object.withdraw_amount != null)
                if ($util.Long)
                    (message.withdraw_amount = $util.Long.fromValue(object.withdraw_amount)).unsigned = false;
                else if (typeof object.withdraw_amount === "string")
                    message.withdraw_amount = parseInt(object.withdraw_amount, 10);
                else if (typeof object.withdraw_amount === "number")
                    message.withdraw_amount = object.withdraw_amount;
                else if (typeof object.withdraw_amount === "object")
                    message.withdraw_amount = new $util.LongBits(object.withdraw_amount.low >>> 0, object.withdraw_amount.high >>> 0).toNumber();
            if (object.unfreeze_amount != null)
                if ($util.Long)
                    (message.unfreeze_amount = $util.Long.fromValue(object.unfreeze_amount)).unsigned = false;
                else if (typeof object.unfreeze_amount === "string")
                    message.unfreeze_amount = parseInt(object.unfreeze_amount, 10);
                else if (typeof object.unfreeze_amount === "number")
                    message.unfreeze_amount = object.unfreeze_amount;
                else if (typeof object.unfreeze_amount === "object")
                    message.unfreeze_amount = new $util.LongBits(object.unfreeze_amount.low >>> 0, object.unfreeze_amount.high >>> 0).toNumber();
            if (object.internal_transactions) {
                if (!Array.isArray(object.internal_transactions))
                    throw TypeError(".protocol.TransactionInfo.internal_transactions: array expected");
                message.internal_transactions = [];
                for (var i = 0; i < object.internal_transactions.length; ++i) {
                    if (typeof object.internal_transactions[i] !== "object")
                        throw TypeError(".protocol.TransactionInfo.internal_transactions: object expected");
                    message.internal_transactions[i] = $root.protocol.InternalTransaction.fromObject(object.internal_transactions[i]);
                }
            }
            if (object.exchange_received_amount != null)
                if ($util.Long)
                    (message.exchange_received_amount = $util.Long.fromValue(object.exchange_received_amount)).unsigned = false;
                else if (typeof object.exchange_received_amount === "string")
                    message.exchange_received_amount = parseInt(object.exchange_received_amount, 10);
                else if (typeof object.exchange_received_amount === "number")
                    message.exchange_received_amount = object.exchange_received_amount;
                else if (typeof object.exchange_received_amount === "object")
                    message.exchange_received_amount = new $util.LongBits(object.exchange_received_amount.low >>> 0, object.exchange_received_amount.high >>> 0).toNumber();
            if (object.exchange_inject_another_amount != null)
                if ($util.Long)
                    (message.exchange_inject_another_amount = $util.Long.fromValue(object.exchange_inject_another_amount)).unsigned = false;
                else if (typeof object.exchange_inject_another_amount === "string")
                    message.exchange_inject_another_amount = parseInt(object.exchange_inject_another_amount, 10);
                else if (typeof object.exchange_inject_another_amount === "number")
                    message.exchange_inject_another_amount = object.exchange_inject_another_amount;
                else if (typeof object.exchange_inject_another_amount === "object")
                    message.exchange_inject_another_amount = new $util.LongBits(object.exchange_inject_another_amount.low >>> 0, object.exchange_inject_another_amount.high >>> 0).toNumber();
            if (object.exchange_withdraw_another_amount != null)
                if ($util.Long)
                    (message.exchange_withdraw_another_amount = $util.Long.fromValue(object.exchange_withdraw_another_amount)).unsigned = false;
                else if (typeof object.exchange_withdraw_another_amount === "string")
                    message.exchange_withdraw_another_amount = parseInt(object.exchange_withdraw_another_amount, 10);
                else if (typeof object.exchange_withdraw_another_amount === "number")
                    message.exchange_withdraw_another_amount = object.exchange_withdraw_another_amount;
                else if (typeof object.exchange_withdraw_another_amount === "object")
                    message.exchange_withdraw_another_amount = new $util.LongBits(object.exchange_withdraw_another_amount.low >>> 0, object.exchange_withdraw_another_amount.high >>> 0).toNumber();
            if (object.exchange_id != null)
                if ($util.Long)
                    (message.exchange_id = $util.Long.fromValue(object.exchange_id)).unsigned = false;
                else if (typeof object.exchange_id === "string")
                    message.exchange_id = parseInt(object.exchange_id, 10);
                else if (typeof object.exchange_id === "number")
                    message.exchange_id = object.exchange_id;
                else if (typeof object.exchange_id === "object")
                    message.exchange_id = new $util.LongBits(object.exchange_id.low >>> 0, object.exchange_id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TransactionInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransactionInfo
         * @static
         * @param {protocol.TransactionInfo} message TransactionInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.contractResult = [];
                object.log = [];
                object.internal_transactions = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object.id = "";
                else {
                    object.id = [];
                    if (options.bytes !== Array)
                        object.id = $util.newBuffer(object.id);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockTimeStamp = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.contract_address = "";
                else {
                    object.contract_address = [];
                    if (options.bytes !== Array)
                        object.contract_address = $util.newBuffer(object.contract_address);
                }
                object.receipt = null;
                object.result = options.enums === String ? "SUCESS" : 0;
                if (options.bytes === String)
                    object.resMessage = "";
                else {
                    object.resMessage = [];
                    if (options.bytes !== Array)
                        object.resMessage = $util.newBuffer(object.resMessage);
                }
                object.assetIssueID = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.withdraw_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.withdraw_amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.unfreeze_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unfreeze_amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_received_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_received_amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_inject_another_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_inject_another_amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_withdraw_another_amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_withdraw_another_amount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exchange_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exchange_id = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (typeof message.blockTimeStamp === "number")
                    object.blockTimeStamp = options.longs === String ? String(message.blockTimeStamp) : message.blockTimeStamp;
                else
                    object.blockTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.blockTimeStamp) : options.longs === Number ? new $util.LongBits(message.blockTimeStamp.low >>> 0, message.blockTimeStamp.high >>> 0).toNumber() : message.blockTimeStamp;
            if (message.contractResult && message.contractResult.length) {
                object.contractResult = [];
                for (var j = 0; j < message.contractResult.length; ++j)
                    object.contractResult[j] = options.bytes === String ? $util.base64.encode(message.contractResult[j], 0, message.contractResult[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.contractResult[j]) : message.contractResult[j];
            }
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                object.contract_address = options.bytes === String ? $util.base64.encode(message.contract_address, 0, message.contract_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_address) : message.contract_address;
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                object.receipt = $root.protocol.ResourceReceipt.toObject(message.receipt, options);
            if (message.log && message.log.length) {
                object.log = [];
                for (var j = 0; j < message.log.length; ++j)
                    object.log[j] = $root.protocol.TransactionInfo.Log.toObject(message.log[j], options);
            }
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = options.enums === String ? $root.protocol.TransactionInfo.code[message.result] : message.result;
            if (message.resMessage != null && message.hasOwnProperty("resMessage"))
                object.resMessage = options.bytes === String ? $util.base64.encode(message.resMessage, 0, message.resMessage.length) : options.bytes === Array ? Array.prototype.slice.call(message.resMessage) : message.resMessage;
            if (message.assetIssueID != null && message.hasOwnProperty("assetIssueID"))
                object.assetIssueID = message.assetIssueID;
            if (message.withdraw_amount != null && message.hasOwnProperty("withdraw_amount"))
                if (typeof message.withdraw_amount === "number")
                    object.withdraw_amount = options.longs === String ? String(message.withdraw_amount) : message.withdraw_amount;
                else
                    object.withdraw_amount = options.longs === String ? $util.Long.prototype.toString.call(message.withdraw_amount) : options.longs === Number ? new $util.LongBits(message.withdraw_amount.low >>> 0, message.withdraw_amount.high >>> 0).toNumber() : message.withdraw_amount;
            if (message.unfreeze_amount != null && message.hasOwnProperty("unfreeze_amount"))
                if (typeof message.unfreeze_amount === "number")
                    object.unfreeze_amount = options.longs === String ? String(message.unfreeze_amount) : message.unfreeze_amount;
                else
                    object.unfreeze_amount = options.longs === String ? $util.Long.prototype.toString.call(message.unfreeze_amount) : options.longs === Number ? new $util.LongBits(message.unfreeze_amount.low >>> 0, message.unfreeze_amount.high >>> 0).toNumber() : message.unfreeze_amount;
            if (message.internal_transactions && message.internal_transactions.length) {
                object.internal_transactions = [];
                for (var j = 0; j < message.internal_transactions.length; ++j)
                    object.internal_transactions[j] = $root.protocol.InternalTransaction.toObject(message.internal_transactions[j], options);
            }
            if (message.exchange_received_amount != null && message.hasOwnProperty("exchange_received_amount"))
                if (typeof message.exchange_received_amount === "number")
                    object.exchange_received_amount = options.longs === String ? String(message.exchange_received_amount) : message.exchange_received_amount;
                else
                    object.exchange_received_amount = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_received_amount) : options.longs === Number ? new $util.LongBits(message.exchange_received_amount.low >>> 0, message.exchange_received_amount.high >>> 0).toNumber() : message.exchange_received_amount;
            if (message.exchange_inject_another_amount != null && message.hasOwnProperty("exchange_inject_another_amount"))
                if (typeof message.exchange_inject_another_amount === "number")
                    object.exchange_inject_another_amount = options.longs === String ? String(message.exchange_inject_another_amount) : message.exchange_inject_another_amount;
                else
                    object.exchange_inject_another_amount = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_inject_another_amount) : options.longs === Number ? new $util.LongBits(message.exchange_inject_another_amount.low >>> 0, message.exchange_inject_another_amount.high >>> 0).toNumber() : message.exchange_inject_another_amount;
            if (message.exchange_withdraw_another_amount != null && message.hasOwnProperty("exchange_withdraw_another_amount"))
                if (typeof message.exchange_withdraw_another_amount === "number")
                    object.exchange_withdraw_another_amount = options.longs === String ? String(message.exchange_withdraw_another_amount) : message.exchange_withdraw_another_amount;
                else
                    object.exchange_withdraw_another_amount = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_withdraw_another_amount) : options.longs === Number ? new $util.LongBits(message.exchange_withdraw_another_amount.low >>> 0, message.exchange_withdraw_another_amount.high >>> 0).toNumber() : message.exchange_withdraw_another_amount;
            if (message.exchange_id != null && message.hasOwnProperty("exchange_id"))
                if (typeof message.exchange_id === "number")
                    object.exchange_id = options.longs === String ? String(message.exchange_id) : message.exchange_id;
                else
                    object.exchange_id = options.longs === String ? $util.Long.prototype.toString.call(message.exchange_id) : options.longs === Number ? new $util.LongBits(message.exchange_id.low >>> 0, message.exchange_id.high >>> 0).toNumber() : message.exchange_id;
            return object;
        };

        /**
         * Converts this TransactionInfo to JSON.
         * @function toJSON
         * @memberof protocol.TransactionInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * code enum.
         * @name protocol.TransactionInfo.code
         * @enum {string}
         * @property {number} SUCESS=0 SUCESS value
         * @property {number} FAILED=1 FAILED value
         */
        TransactionInfo.code = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCESS"] = 0;
            values[valuesById[1] = "FAILED"] = 1;
            return values;
        })();

        TransactionInfo.Log = (function() {

            /**
             * Properties of a Log.
             * @memberof protocol.TransactionInfo
             * @interface ILog
             * @property {Uint8Array|null} [address] Log address
             * @property {Array.<Uint8Array>|null} [topics] Log topics
             * @property {Uint8Array|null} [data] Log data
             */

            /**
             * Constructs a new Log.
             * @memberof protocol.TransactionInfo
             * @classdesc Represents a Log.
             * @implements ILog
             * @constructor
             * @param {protocol.TransactionInfo.ILog=} [properties] Properties to set
             */
            function Log(properties) {
                this.topics = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Log address.
             * @member {Uint8Array} address
             * @memberof protocol.TransactionInfo.Log
             * @instance
             */
            Log.prototype.address = $util.newBuffer([]);

            /**
             * Log topics.
             * @member {Array.<Uint8Array>} topics
             * @memberof protocol.TransactionInfo.Log
             * @instance
             */
            Log.prototype.topics = $util.emptyArray;

            /**
             * Log data.
             * @member {Uint8Array} data
             * @memberof protocol.TransactionInfo.Log
             * @instance
             */
            Log.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new Log instance using the specified properties.
             * @function create
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.ILog=} [properties] Properties to set
             * @returns {protocol.TransactionInfo.Log} Log instance
             */
            Log.create = function create(properties) {
                return new Log(properties);
            };

            /**
             * Encodes the specified Log message. Does not implicitly {@link protocol.TransactionInfo.Log.verify|verify} messages.
             * @function encode
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.ILog} message Log message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Log.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.address != null && message.hasOwnProperty("address"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);
                if (message.topics != null && message.topics.length)
                    for (var i = 0; i < message.topics.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.topics[i]);
                if (message.data != null && message.hasOwnProperty("data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified Log message, length delimited. Does not implicitly {@link protocol.TransactionInfo.Log.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.ILog} message Log message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Log.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Log message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.TransactionInfo.Log} Log
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Log.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionInfo.Log();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.address = reader.bytes();
                        break;
                    case 2:
                        if (!(message.topics && message.topics.length))
                            message.topics = [];
                        message.topics.push(reader.bytes());
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Log message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.TransactionInfo.Log} Log
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Log.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Log message.
             * @function verify
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Log.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!(message.address && typeof message.address.length === "number" || $util.isString(message.address)))
                        return "address: buffer expected";
                if (message.topics != null && message.hasOwnProperty("topics")) {
                    if (!Array.isArray(message.topics))
                        return "topics: array expected";
                    for (var i = 0; i < message.topics.length; ++i)
                        if (!(message.topics[i] && typeof message.topics[i].length === "number" || $util.isString(message.topics[i])))
                            return "topics: buffer[] expected";
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a Log message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.TransactionInfo.Log} Log
             */
            Log.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.TransactionInfo.Log)
                    return object;
                var message = new $root.protocol.TransactionInfo.Log();
                if (object.address != null)
                    if (typeof object.address === "string")
                        $util.base64.decode(object.address, message.address = $util.newBuffer($util.base64.length(object.address)), 0);
                    else if (object.address.length)
                        message.address = object.address;
                if (object.topics) {
                    if (!Array.isArray(object.topics))
                        throw TypeError(".protocol.TransactionInfo.Log.topics: array expected");
                    message.topics = [];
                    for (var i = 0; i < object.topics.length; ++i)
                        if (typeof object.topics[i] === "string")
                            $util.base64.decode(object.topics[i], message.topics[i] = $util.newBuffer($util.base64.length(object.topics[i])), 0);
                        else if (object.topics[i].length)
                            message.topics[i] = object.topics[i];
                }
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a Log message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.TransactionInfo.Log
             * @static
             * @param {protocol.TransactionInfo.Log} message Log
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Log.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.topics = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.address = "";
                    else {
                        object.address = [];
                        if (options.bytes !== Array)
                            object.address = $util.newBuffer(object.address);
                    }
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                }
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = options.bytes === String ? $util.base64.encode(message.address, 0, message.address.length) : options.bytes === Array ? Array.prototype.slice.call(message.address) : message.address;
                if (message.topics && message.topics.length) {
                    object.topics = [];
                    for (var j = 0; j < message.topics.length; ++j)
                        object.topics[j] = options.bytes === String ? $util.base64.encode(message.topics[j], 0, message.topics[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.topics[j]) : message.topics[j];
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this Log to JSON.
             * @function toJSON
             * @memberof protocol.TransactionInfo.Log
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Log.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Log;
        })();

        return TransactionInfo;
    })();

    protocol.TransactionRet = (function() {

        /**
         * Properties of a TransactionRet.
         * @memberof protocol
         * @interface ITransactionRet
         * @property {number|Long|null} [blockNumber] TransactionRet blockNumber
         * @property {number|Long|null} [blockTimeStamp] TransactionRet blockTimeStamp
         * @property {Array.<protocol.ITransactionInfo>|null} [transactioninfo] TransactionRet transactioninfo
         */

        /**
         * Constructs a new TransactionRet.
         * @memberof protocol
         * @classdesc Represents a TransactionRet.
         * @implements ITransactionRet
         * @constructor
         * @param {protocol.ITransactionRet=} [properties] Properties to set
         */
        function TransactionRet(properties) {
            this.transactioninfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionRet blockNumber.
         * @member {number|Long} blockNumber
         * @memberof protocol.TransactionRet
         * @instance
         */
        TransactionRet.prototype.blockNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionRet blockTimeStamp.
         * @member {number|Long} blockTimeStamp
         * @memberof protocol.TransactionRet
         * @instance
         */
        TransactionRet.prototype.blockTimeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TransactionRet transactioninfo.
         * @member {Array.<protocol.ITransactionInfo>} transactioninfo
         * @memberof protocol.TransactionRet
         * @instance
         */
        TransactionRet.prototype.transactioninfo = $util.emptyArray;

        /**
         * Creates a new TransactionRet instance using the specified properties.
         * @function create
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.ITransactionRet=} [properties] Properties to set
         * @returns {protocol.TransactionRet} TransactionRet instance
         */
        TransactionRet.create = function create(properties) {
            return new TransactionRet(properties);
        };

        /**
         * Encodes the specified TransactionRet message. Does not implicitly {@link protocol.TransactionRet.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.ITransactionRet} message TransactionRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.blockNumber);
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.blockTimeStamp);
            if (message.transactioninfo != null && message.transactioninfo.length)
                for (var i = 0; i < message.transactioninfo.length; ++i)
                    $root.protocol.TransactionInfo.encode(message.transactioninfo[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionRet message, length delimited. Does not implicitly {@link protocol.TransactionRet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.ITransactionRet} message TransactionRet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionRet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionRet message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransactionRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransactionRet} TransactionRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionRet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockNumber = reader.int64();
                    break;
                case 2:
                    message.blockTimeStamp = reader.int64();
                    break;
                case 3:
                    if (!(message.transactioninfo && message.transactioninfo.length))
                        message.transactioninfo = [];
                    message.transactioninfo.push($root.protocol.TransactionInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionRet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransactionRet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransactionRet} TransactionRet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionRet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionRet message.
         * @function verify
         * @memberof protocol.TransactionRet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionRet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (!$util.isInteger(message.blockNumber) && !(message.blockNumber && $util.isInteger(message.blockNumber.low) && $util.isInteger(message.blockNumber.high)))
                    return "blockNumber: integer|Long expected";
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (!$util.isInteger(message.blockTimeStamp) && !(message.blockTimeStamp && $util.isInteger(message.blockTimeStamp.low) && $util.isInteger(message.blockTimeStamp.high)))
                    return "blockTimeStamp: integer|Long expected";
            if (message.transactioninfo != null && message.hasOwnProperty("transactioninfo")) {
                if (!Array.isArray(message.transactioninfo))
                    return "transactioninfo: array expected";
                for (var i = 0; i < message.transactioninfo.length; ++i) {
                    var error = $root.protocol.TransactionInfo.verify(message.transactioninfo[i]);
                    if (error)
                        return "transactioninfo." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionRet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransactionRet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransactionRet} TransactionRet
         */
        TransactionRet.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionRet)
                return object;
            var message = new $root.protocol.TransactionRet();
            if (object.blockNumber != null)
                if ($util.Long)
                    (message.blockNumber = $util.Long.fromValue(object.blockNumber)).unsigned = false;
                else if (typeof object.blockNumber === "string")
                    message.blockNumber = parseInt(object.blockNumber, 10);
                else if (typeof object.blockNumber === "number")
                    message.blockNumber = object.blockNumber;
                else if (typeof object.blockNumber === "object")
                    message.blockNumber = new $util.LongBits(object.blockNumber.low >>> 0, object.blockNumber.high >>> 0).toNumber();
            if (object.blockTimeStamp != null)
                if ($util.Long)
                    (message.blockTimeStamp = $util.Long.fromValue(object.blockTimeStamp)).unsigned = false;
                else if (typeof object.blockTimeStamp === "string")
                    message.blockTimeStamp = parseInt(object.blockTimeStamp, 10);
                else if (typeof object.blockTimeStamp === "number")
                    message.blockTimeStamp = object.blockTimeStamp;
                else if (typeof object.blockTimeStamp === "object")
                    message.blockTimeStamp = new $util.LongBits(object.blockTimeStamp.low >>> 0, object.blockTimeStamp.high >>> 0).toNumber();
            if (object.transactioninfo) {
                if (!Array.isArray(object.transactioninfo))
                    throw TypeError(".protocol.TransactionRet.transactioninfo: array expected");
                message.transactioninfo = [];
                for (var i = 0; i < object.transactioninfo.length; ++i) {
                    if (typeof object.transactioninfo[i] !== "object")
                        throw TypeError(".protocol.TransactionRet.transactioninfo: object expected");
                    message.transactioninfo[i] = $root.protocol.TransactionInfo.fromObject(object.transactioninfo[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionRet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransactionRet
         * @static
         * @param {protocol.TransactionRet} message TransactionRet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionRet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactioninfo = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.blockTimeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.blockTimeStamp = options.longs === String ? "0" : 0;
            }
            if (message.blockNumber != null && message.hasOwnProperty("blockNumber"))
                if (typeof message.blockNumber === "number")
                    object.blockNumber = options.longs === String ? String(message.blockNumber) : message.blockNumber;
                else
                    object.blockNumber = options.longs === String ? $util.Long.prototype.toString.call(message.blockNumber) : options.longs === Number ? new $util.LongBits(message.blockNumber.low >>> 0, message.blockNumber.high >>> 0).toNumber() : message.blockNumber;
            if (message.blockTimeStamp != null && message.hasOwnProperty("blockTimeStamp"))
                if (typeof message.blockTimeStamp === "number")
                    object.blockTimeStamp = options.longs === String ? String(message.blockTimeStamp) : message.blockTimeStamp;
                else
                    object.blockTimeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.blockTimeStamp) : options.longs === Number ? new $util.LongBits(message.blockTimeStamp.low >>> 0, message.blockTimeStamp.high >>> 0).toNumber() : message.blockTimeStamp;
            if (message.transactioninfo && message.transactioninfo.length) {
                object.transactioninfo = [];
                for (var j = 0; j < message.transactioninfo.length; ++j)
                    object.transactioninfo[j] = $root.protocol.TransactionInfo.toObject(message.transactioninfo[j], options);
            }
            return object;
        };

        /**
         * Converts this TransactionRet to JSON.
         * @function toJSON
         * @memberof protocol.TransactionRet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionRet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionRet;
    })();

    protocol.Transactions = (function() {

        /**
         * Properties of a Transactions.
         * @memberof protocol
         * @interface ITransactions
         * @property {Array.<protocol.ITransaction>|null} [transactions] Transactions transactions
         */

        /**
         * Constructs a new Transactions.
         * @memberof protocol
         * @classdesc Represents a Transactions.
         * @implements ITransactions
         * @constructor
         * @param {protocol.ITransactions=} [properties] Properties to set
         */
        function Transactions(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Transactions transactions.
         * @member {Array.<protocol.ITransaction>} transactions
         * @memberof protocol.Transactions
         * @instance
         */
        Transactions.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new Transactions instance using the specified properties.
         * @function create
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.ITransactions=} [properties] Properties to set
         * @returns {protocol.Transactions} Transactions instance
         */
        Transactions.create = function create(properties) {
            return new Transactions(properties);
        };

        /**
         * Encodes the specified Transactions message. Does not implicitly {@link protocol.Transactions.verify|verify} messages.
         * @function encode
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.ITransactions} message Transactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transactions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Transactions message, length delimited. Does not implicitly {@link protocol.Transactions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.ITransactions} message Transactions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transactions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transactions message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Transactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Transactions} Transactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transactions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Transactions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transactions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Transactions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Transactions} Transactions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transactions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transactions message.
         * @function verify
         * @memberof protocol.Transactions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transactions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Transactions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Transactions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Transactions} Transactions
         */
        Transactions.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Transactions)
                return object;
            var message = new $root.protocol.Transactions();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Transactions.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Transactions.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Transactions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Transactions
         * @static
         * @param {protocol.Transactions} message Transactions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transactions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this Transactions to JSON.
         * @function toJSON
         * @memberof protocol.Transactions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transactions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transactions;
    })();

    protocol.TransactionSign = (function() {

        /**
         * Properties of a TransactionSign.
         * @memberof protocol
         * @interface ITransactionSign
         * @property {protocol.ITransaction|null} [transaction] TransactionSign transaction
         * @property {Uint8Array|null} [privateKey] TransactionSign privateKey
         */

        /**
         * Constructs a new TransactionSign.
         * @memberof protocol
         * @classdesc Represents a TransactionSign.
         * @implements ITransactionSign
         * @constructor
         * @param {protocol.ITransactionSign=} [properties] Properties to set
         */
        function TransactionSign(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransactionSign transaction.
         * @member {protocol.ITransaction|null|undefined} transaction
         * @memberof protocol.TransactionSign
         * @instance
         */
        TransactionSign.prototype.transaction = null;

        /**
         * TransactionSign privateKey.
         * @member {Uint8Array} privateKey
         * @memberof protocol.TransactionSign
         * @instance
         */
        TransactionSign.prototype.privateKey = $util.newBuffer([]);

        /**
         * Creates a new TransactionSign instance using the specified properties.
         * @function create
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.ITransactionSign=} [properties] Properties to set
         * @returns {protocol.TransactionSign} TransactionSign instance
         */
        TransactionSign.create = function create(properties) {
            return new TransactionSign(properties);
        };

        /**
         * Encodes the specified TransactionSign message. Does not implicitly {@link protocol.TransactionSign.verify|verify} messages.
         * @function encode
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.ITransactionSign} message TransactionSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionSign.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                $root.protocol.Transaction.encode(message.transaction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.privateKey);
            return writer;
        };

        /**
         * Encodes the specified TransactionSign message, length delimited. Does not implicitly {@link protocol.TransactionSign.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.ITransactionSign} message TransactionSign message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionSign.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionSign message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.TransactionSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.TransactionSign} TransactionSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionSign.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.TransactionSign();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.transaction = $root.protocol.Transaction.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.privateKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionSign message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.TransactionSign
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.TransactionSign} TransactionSign
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionSign.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionSign message.
         * @function verify
         * @memberof protocol.TransactionSign
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionSign.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transaction != null && message.hasOwnProperty("transaction")) {
                var error = $root.protocol.Transaction.verify(message.transaction);
                if (error)
                    return "transaction." + error;
            }
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                    return "privateKey: buffer expected";
            return null;
        };

        /**
         * Creates a TransactionSign message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.TransactionSign
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.TransactionSign} TransactionSign
         */
        TransactionSign.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.TransactionSign)
                return object;
            var message = new $root.protocol.TransactionSign();
            if (object.transaction != null) {
                if (typeof object.transaction !== "object")
                    throw TypeError(".protocol.TransactionSign.transaction: object expected");
                message.transaction = $root.protocol.Transaction.fromObject(object.transaction);
            }
            if (object.privateKey != null)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            return message;
        };

        /**
         * Creates a plain object from a TransactionSign message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.TransactionSign
         * @static
         * @param {protocol.TransactionSign} message TransactionSign
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionSign.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.transaction = null;
                if (options.bytes === String)
                    object.privateKey = "";
                else {
                    object.privateKey = [];
                    if (options.bytes !== Array)
                        object.privateKey = $util.newBuffer(object.privateKey);
                }
            }
            if (message.transaction != null && message.hasOwnProperty("transaction"))
                object.transaction = $root.protocol.Transaction.toObject(message.transaction, options);
            if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            return object;
        };

        /**
         * Converts this TransactionSign to JSON.
         * @function toJSON
         * @memberof protocol.TransactionSign
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionSign.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionSign;
    })();

    protocol.BlockHeader = (function() {

        /**
         * Properties of a BlockHeader.
         * @memberof protocol
         * @interface IBlockHeader
         * @property {protocol.BlockHeader.Iraw|null} [raw_data] BlockHeader raw_data
         * @property {Uint8Array|null} [witness_signature] BlockHeader witness_signature
         */

        /**
         * Constructs a new BlockHeader.
         * @memberof protocol
         * @classdesc Represents a BlockHeader.
         * @implements IBlockHeader
         * @constructor
         * @param {protocol.IBlockHeader=} [properties] Properties to set
         */
        function BlockHeader(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockHeader raw_data.
         * @member {protocol.BlockHeader.Iraw|null|undefined} raw_data
         * @memberof protocol.BlockHeader
         * @instance
         */
        BlockHeader.prototype.raw_data = null;

        /**
         * BlockHeader witness_signature.
         * @member {Uint8Array} witness_signature
         * @memberof protocol.BlockHeader
         * @instance
         */
        BlockHeader.prototype.witness_signature = $util.newBuffer([]);

        /**
         * Creates a new BlockHeader instance using the specified properties.
         * @function create
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.IBlockHeader=} [properties] Properties to set
         * @returns {protocol.BlockHeader} BlockHeader instance
         */
        BlockHeader.create = function create(properties) {
            return new BlockHeader(properties);
        };

        /**
         * Encodes the specified BlockHeader message. Does not implicitly {@link protocol.BlockHeader.verify|verify} messages.
         * @function encode
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.IBlockHeader} message BlockHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockHeader.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.raw_data != null && message.hasOwnProperty("raw_data"))
                $root.protocol.BlockHeader.raw.encode(message.raw_data, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.witness_signature != null && message.hasOwnProperty("witness_signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.witness_signature);
            return writer;
        };

        /**
         * Encodes the specified BlockHeader message, length delimited. Does not implicitly {@link protocol.BlockHeader.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.IBlockHeader} message BlockHeader message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockHeader.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockHeader message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BlockHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BlockHeader} BlockHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockHeader();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.raw_data = $root.protocol.BlockHeader.raw.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.witness_signature = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockHeader message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BlockHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BlockHeader} BlockHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockHeader.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockHeader message.
         * @function verify
         * @memberof protocol.BlockHeader
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockHeader.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.raw_data != null && message.hasOwnProperty("raw_data")) {
                var error = $root.protocol.BlockHeader.raw.verify(message.raw_data);
                if (error)
                    return "raw_data." + error;
            }
            if (message.witness_signature != null && message.hasOwnProperty("witness_signature"))
                if (!(message.witness_signature && typeof message.witness_signature.length === "number" || $util.isString(message.witness_signature)))
                    return "witness_signature: buffer expected";
            return null;
        };

        /**
         * Creates a BlockHeader message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BlockHeader
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BlockHeader} BlockHeader
         */
        BlockHeader.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BlockHeader)
                return object;
            var message = new $root.protocol.BlockHeader();
            if (object.raw_data != null) {
                if (typeof object.raw_data !== "object")
                    throw TypeError(".protocol.BlockHeader.raw_data: object expected");
                message.raw_data = $root.protocol.BlockHeader.raw.fromObject(object.raw_data);
            }
            if (object.witness_signature != null)
                if (typeof object.witness_signature === "string")
                    $util.base64.decode(object.witness_signature, message.witness_signature = $util.newBuffer($util.base64.length(object.witness_signature)), 0);
                else if (object.witness_signature.length)
                    message.witness_signature = object.witness_signature;
            return message;
        };

        /**
         * Creates a plain object from a BlockHeader message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BlockHeader
         * @static
         * @param {protocol.BlockHeader} message BlockHeader
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockHeader.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.raw_data = null;
                if (options.bytes === String)
                    object.witness_signature = "";
                else {
                    object.witness_signature = [];
                    if (options.bytes !== Array)
                        object.witness_signature = $util.newBuffer(object.witness_signature);
                }
            }
            if (message.raw_data != null && message.hasOwnProperty("raw_data"))
                object.raw_data = $root.protocol.BlockHeader.raw.toObject(message.raw_data, options);
            if (message.witness_signature != null && message.hasOwnProperty("witness_signature"))
                object.witness_signature = options.bytes === String ? $util.base64.encode(message.witness_signature, 0, message.witness_signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.witness_signature) : message.witness_signature;
            return object;
        };

        /**
         * Converts this BlockHeader to JSON.
         * @function toJSON
         * @memberof protocol.BlockHeader
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockHeader.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        BlockHeader.raw = (function() {

            /**
             * Properties of a raw.
             * @memberof protocol.BlockHeader
             * @interface Iraw
             * @property {number|Long|null} [timestamp] raw timestamp
             * @property {Uint8Array|null} [txTrieRoot] raw txTrieRoot
             * @property {Uint8Array|null} [parentHash] raw parentHash
             * @property {number|Long|null} [number] raw number
             * @property {number|Long|null} [witness_id] raw witness_id
             * @property {Uint8Array|null} [witness_address] raw witness_address
             * @property {number|null} [version] raw version
             * @property {Uint8Array|null} [accountStateRoot] raw accountStateRoot
             */

            /**
             * Constructs a new raw.
             * @memberof protocol.BlockHeader
             * @classdesc Represents a raw.
             * @implements Iraw
             * @constructor
             * @param {protocol.BlockHeader.Iraw=} [properties] Properties to set
             */
            function raw(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * raw timestamp.
             * @member {number|Long} timestamp
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw txTrieRoot.
             * @member {Uint8Array} txTrieRoot
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.txTrieRoot = $util.newBuffer([]);

            /**
             * raw parentHash.
             * @member {Uint8Array} parentHash
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.parentHash = $util.newBuffer([]);

            /**
             * raw number.
             * @member {number|Long} number
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw witness_id.
             * @member {number|Long} witness_id
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.witness_id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * raw witness_address.
             * @member {Uint8Array} witness_address
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.witness_address = $util.newBuffer([]);

            /**
             * raw version.
             * @member {number} version
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.version = 0;

            /**
             * raw accountStateRoot.
             * @member {Uint8Array} accountStateRoot
             * @memberof protocol.BlockHeader.raw
             * @instance
             */
            raw.prototype.accountStateRoot = $util.newBuffer([]);

            /**
             * Creates a new raw instance using the specified properties.
             * @function create
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.Iraw=} [properties] Properties to set
             * @returns {protocol.BlockHeader.raw} raw instance
             */
            raw.create = function create(properties) {
                return new raw(properties);
            };

            /**
             * Encodes the specified raw message. Does not implicitly {@link protocol.BlockHeader.raw.verify|verify} messages.
             * @function encode
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.txTrieRoot);
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.parentHash);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.number);
                if (message.witness_id != null && message.hasOwnProperty("witness_id"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int64(message.witness_id);
                if (message.witness_address != null && message.hasOwnProperty("witness_address"))
                    writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.witness_address);
                if (message.version != null && message.hasOwnProperty("version"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.version);
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.accountStateRoot);
                return writer;
            };

            /**
             * Encodes the specified raw message, length delimited. Does not implicitly {@link protocol.BlockHeader.raw.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.Iraw} message raw message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            raw.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a raw message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.BlockHeader.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockHeader.raw();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int64();
                        break;
                    case 2:
                        message.txTrieRoot = reader.bytes();
                        break;
                    case 3:
                        message.parentHash = reader.bytes();
                        break;
                    case 7:
                        message.number = reader.int64();
                        break;
                    case 8:
                        message.witness_id = reader.int64();
                        break;
                    case 9:
                        message.witness_address = reader.bytes();
                        break;
                    case 10:
                        message.version = reader.int32();
                        break;
                    case 11:
                        message.accountStateRoot = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a raw message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.BlockHeader.raw} raw
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            raw.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a raw message.
             * @function verify
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            raw.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                        return "timestamp: integer|Long expected";
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    if (!(message.txTrieRoot && typeof message.txTrieRoot.length === "number" || $util.isString(message.txTrieRoot)))
                        return "txTrieRoot: buffer expected";
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    if (!(message.parentHash && typeof message.parentHash.length === "number" || $util.isString(message.parentHash)))
                        return "parentHash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                if (message.witness_id != null && message.hasOwnProperty("witness_id"))
                    if (!$util.isInteger(message.witness_id) && !(message.witness_id && $util.isInteger(message.witness_id.low) && $util.isInteger(message.witness_id.high)))
                        return "witness_id: integer|Long expected";
                if (message.witness_address != null && message.hasOwnProperty("witness_address"))
                    if (!(message.witness_address && typeof message.witness_address.length === "number" || $util.isString(message.witness_address)))
                        return "witness_address: buffer expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isInteger(message.version))
                        return "version: integer expected";
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    if (!(message.accountStateRoot && typeof message.accountStateRoot.length === "number" || $util.isString(message.accountStateRoot)))
                        return "accountStateRoot: buffer expected";
                return null;
            };

            /**
             * Creates a raw message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.BlockHeader.raw} raw
             */
            raw.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.BlockHeader.raw)
                    return object;
                var message = new $root.protocol.BlockHeader.raw();
                if (object.timestamp != null)
                    if ($util.Long)
                        (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                    else if (typeof object.timestamp === "string")
                        message.timestamp = parseInt(object.timestamp, 10);
                    else if (typeof object.timestamp === "number")
                        message.timestamp = object.timestamp;
                    else if (typeof object.timestamp === "object")
                        message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                if (object.txTrieRoot != null)
                    if (typeof object.txTrieRoot === "string")
                        $util.base64.decode(object.txTrieRoot, message.txTrieRoot = $util.newBuffer($util.base64.length(object.txTrieRoot)), 0);
                    else if (object.txTrieRoot.length)
                        message.txTrieRoot = object.txTrieRoot;
                if (object.parentHash != null)
                    if (typeof object.parentHash === "string")
                        $util.base64.decode(object.parentHash, message.parentHash = $util.newBuffer($util.base64.length(object.parentHash)), 0);
                    else if (object.parentHash.length)
                        message.parentHash = object.parentHash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                if (object.witness_id != null)
                    if ($util.Long)
                        (message.witness_id = $util.Long.fromValue(object.witness_id)).unsigned = false;
                    else if (typeof object.witness_id === "string")
                        message.witness_id = parseInt(object.witness_id, 10);
                    else if (typeof object.witness_id === "number")
                        message.witness_id = object.witness_id;
                    else if (typeof object.witness_id === "object")
                        message.witness_id = new $util.LongBits(object.witness_id.low >>> 0, object.witness_id.high >>> 0).toNumber();
                if (object.witness_address != null)
                    if (typeof object.witness_address === "string")
                        $util.base64.decode(object.witness_address, message.witness_address = $util.newBuffer($util.base64.length(object.witness_address)), 0);
                    else if (object.witness_address.length)
                        message.witness_address = object.witness_address;
                if (object.version != null)
                    message.version = object.version | 0;
                if (object.accountStateRoot != null)
                    if (typeof object.accountStateRoot === "string")
                        $util.base64.decode(object.accountStateRoot, message.accountStateRoot = $util.newBuffer($util.base64.length(object.accountStateRoot)), 0);
                    else if (object.accountStateRoot.length)
                        message.accountStateRoot = object.accountStateRoot;
                return message;
            };

            /**
             * Creates a plain object from a raw message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.BlockHeader.raw
             * @static
             * @param {protocol.BlockHeader.raw} message raw
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            raw.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.timestamp = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.txTrieRoot = "";
                    else {
                        object.txTrieRoot = [];
                        if (options.bytes !== Array)
                            object.txTrieRoot = $util.newBuffer(object.txTrieRoot);
                    }
                    if (options.bytes === String)
                        object.parentHash = "";
                    else {
                        object.parentHash = [];
                        if (options.bytes !== Array)
                            object.parentHash = $util.newBuffer(object.parentHash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.witness_id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.witness_id = options.longs === String ? "0" : 0;
                    if (options.bytes === String)
                        object.witness_address = "";
                    else {
                        object.witness_address = [];
                        if (options.bytes !== Array)
                            object.witness_address = $util.newBuffer(object.witness_address);
                    }
                    object.version = 0;
                    if (options.bytes === String)
                        object.accountStateRoot = "";
                    else {
                        object.accountStateRoot = [];
                        if (options.bytes !== Array)
                            object.accountStateRoot = $util.newBuffer(object.accountStateRoot);
                    }
                }
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (typeof message.timestamp === "number")
                        object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                    else
                        object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                if (message.txTrieRoot != null && message.hasOwnProperty("txTrieRoot"))
                    object.txTrieRoot = options.bytes === String ? $util.base64.encode(message.txTrieRoot, 0, message.txTrieRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.txTrieRoot) : message.txTrieRoot;
                if (message.parentHash != null && message.hasOwnProperty("parentHash"))
                    object.parentHash = options.bytes === String ? $util.base64.encode(message.parentHash, 0, message.parentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentHash) : message.parentHash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                if (message.witness_id != null && message.hasOwnProperty("witness_id"))
                    if (typeof message.witness_id === "number")
                        object.witness_id = options.longs === String ? String(message.witness_id) : message.witness_id;
                    else
                        object.witness_id = options.longs === String ? $util.Long.prototype.toString.call(message.witness_id) : options.longs === Number ? new $util.LongBits(message.witness_id.low >>> 0, message.witness_id.high >>> 0).toNumber() : message.witness_id;
                if (message.witness_address != null && message.hasOwnProperty("witness_address"))
                    object.witness_address = options.bytes === String ? $util.base64.encode(message.witness_address, 0, message.witness_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.witness_address) : message.witness_address;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.accountStateRoot != null && message.hasOwnProperty("accountStateRoot"))
                    object.accountStateRoot = options.bytes === String ? $util.base64.encode(message.accountStateRoot, 0, message.accountStateRoot.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountStateRoot) : message.accountStateRoot;
                return object;
            };

            /**
             * Converts this raw to JSON.
             * @function toJSON
             * @memberof protocol.BlockHeader.raw
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            raw.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return raw;
        })();

        return BlockHeader;
    })();

    protocol.Block = (function() {

        /**
         * Properties of a Block.
         * @memberof protocol
         * @interface IBlock
         * @property {Array.<protocol.ITransaction>|null} [transactions] Block transactions
         * @property {protocol.IBlockHeader|null} [block_header] Block block_header
         */

        /**
         * Constructs a new Block.
         * @memberof protocol
         * @classdesc Represents a Block.
         * @implements IBlock
         * @constructor
         * @param {protocol.IBlock=} [properties] Properties to set
         */
        function Block(properties) {
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Block transactions.
         * @member {Array.<protocol.ITransaction>} transactions
         * @memberof protocol.Block
         * @instance
         */
        Block.prototype.transactions = $util.emptyArray;

        /**
         * Block block_header.
         * @member {protocol.IBlockHeader|null|undefined} block_header
         * @memberof protocol.Block
         * @instance
         */
        Block.prototype.block_header = null;

        /**
         * Creates a new Block instance using the specified properties.
         * @function create
         * @memberof protocol.Block
         * @static
         * @param {protocol.IBlock=} [properties] Properties to set
         * @returns {protocol.Block} Block instance
         */
        Block.create = function create(properties) {
            return new Block(properties);
        };

        /**
         * Encodes the specified Block message. Does not implicitly {@link protocol.Block.verify|verify} messages.
         * @function encode
         * @memberof protocol.Block
         * @static
         * @param {protocol.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.block_header != null && message.hasOwnProperty("block_header"))
                $root.protocol.BlockHeader.encode(message.block_header, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Block message, length delimited. Does not implicitly {@link protocol.Block.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Block
         * @static
         * @param {protocol.IBlock} message Block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Block.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Block message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Block();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.block_header = $root.protocol.BlockHeader.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Block message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Block} Block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Block.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Block message.
         * @function verify
         * @memberof protocol.Block
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Block.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            if (message.block_header != null && message.hasOwnProperty("block_header")) {
                var error = $root.protocol.BlockHeader.verify(message.block_header);
                if (error)
                    return "block_header." + error;
            }
            return null;
        };

        /**
         * Creates a Block message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Block
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Block} Block
         */
        Block.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Block)
                return object;
            var message = new $root.protocol.Block();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Block.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Block.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            if (object.block_header != null) {
                if (typeof object.block_header !== "object")
                    throw TypeError(".protocol.Block.block_header: object expected");
                message.block_header = $root.protocol.BlockHeader.fromObject(object.block_header);
            }
            return message;
        };

        /**
         * Creates a plain object from a Block message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Block
         * @static
         * @param {protocol.Block} message Block
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Block.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (options.defaults)
                object.block_header = null;
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            if (message.block_header != null && message.hasOwnProperty("block_header"))
                object.block_header = $root.protocol.BlockHeader.toObject(message.block_header, options);
            return object;
        };

        /**
         * Converts this Block to JSON.
         * @function toJSON
         * @memberof protocol.Block
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Block.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Block;
    })();

    protocol.ChainInventory = (function() {

        /**
         * Properties of a ChainInventory.
         * @memberof protocol
         * @interface IChainInventory
         * @property {Array.<protocol.ChainInventory.IBlockId>|null} [ids] ChainInventory ids
         * @property {number|Long|null} [remain_num] ChainInventory remain_num
         */

        /**
         * Constructs a new ChainInventory.
         * @memberof protocol
         * @classdesc Represents a ChainInventory.
         * @implements IChainInventory
         * @constructor
         * @param {protocol.IChainInventory=} [properties] Properties to set
         */
        function ChainInventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChainInventory ids.
         * @member {Array.<protocol.ChainInventory.IBlockId>} ids
         * @memberof protocol.ChainInventory
         * @instance
         */
        ChainInventory.prototype.ids = $util.emptyArray;

        /**
         * ChainInventory remain_num.
         * @member {number|Long} remain_num
         * @memberof protocol.ChainInventory
         * @instance
         */
        ChainInventory.prototype.remain_num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChainInventory instance using the specified properties.
         * @function create
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.IChainInventory=} [properties] Properties to set
         * @returns {protocol.ChainInventory} ChainInventory instance
         */
        ChainInventory.create = function create(properties) {
            return new ChainInventory(properties);
        };

        /**
         * Encodes the specified ChainInventory message. Does not implicitly {@link protocol.ChainInventory.verify|verify} messages.
         * @function encode
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.IChainInventory} message ChainInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.protocol.ChainInventory.BlockId.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.remain_num != null && message.hasOwnProperty("remain_num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.remain_num);
            return writer;
        };

        /**
         * Encodes the specified ChainInventory message, length delimited. Does not implicitly {@link protocol.ChainInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.IChainInventory} message ChainInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChainInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChainInventory message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.ChainInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.ChainInventory} ChainInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.protocol.ChainInventory.BlockId.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.remain_num = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChainInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.ChainInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.ChainInventory} ChainInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChainInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChainInventory message.
         * @function verify
         * @memberof protocol.ChainInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChainInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.protocol.ChainInventory.BlockId.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.remain_num != null && message.hasOwnProperty("remain_num"))
                if (!$util.isInteger(message.remain_num) && !(message.remain_num && $util.isInteger(message.remain_num.low) && $util.isInteger(message.remain_num.high)))
                    return "remain_num: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChainInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.ChainInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.ChainInventory} ChainInventory
         */
        ChainInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.ChainInventory)
                return object;
            var message = new $root.protocol.ChainInventory();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.ChainInventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".protocol.ChainInventory.ids: object expected");
                    message.ids[i] = $root.protocol.ChainInventory.BlockId.fromObject(object.ids[i]);
                }
            }
            if (object.remain_num != null)
                if ($util.Long)
                    (message.remain_num = $util.Long.fromValue(object.remain_num)).unsigned = false;
                else if (typeof object.remain_num === "string")
                    message.remain_num = parseInt(object.remain_num, 10);
                else if (typeof object.remain_num === "number")
                    message.remain_num = object.remain_num;
                else if (typeof object.remain_num === "object")
                    message.remain_num = new $util.LongBits(object.remain_num.low >>> 0, object.remain_num.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChainInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.ChainInventory
         * @static
         * @param {protocol.ChainInventory} message ChainInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChainInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.remain_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remain_num = options.longs === String ? "0" : 0;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.protocol.ChainInventory.BlockId.toObject(message.ids[j], options);
            }
            if (message.remain_num != null && message.hasOwnProperty("remain_num"))
                if (typeof message.remain_num === "number")
                    object.remain_num = options.longs === String ? String(message.remain_num) : message.remain_num;
                else
                    object.remain_num = options.longs === String ? $util.Long.prototype.toString.call(message.remain_num) : options.longs === Number ? new $util.LongBits(message.remain_num.low >>> 0, message.remain_num.high >>> 0).toNumber() : message.remain_num;
            return object;
        };

        /**
         * Converts this ChainInventory to JSON.
         * @function toJSON
         * @memberof protocol.ChainInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChainInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        ChainInventory.BlockId = (function() {

            /**
             * Properties of a BlockId.
             * @memberof protocol.ChainInventory
             * @interface IBlockId
             * @property {Uint8Array|null} [hash] BlockId hash
             * @property {number|Long|null} [number] BlockId number
             */

            /**
             * Constructs a new BlockId.
             * @memberof protocol.ChainInventory
             * @classdesc Represents a BlockId.
             * @implements IBlockId
             * @constructor
             * @param {protocol.ChainInventory.IBlockId=} [properties] Properties to set
             */
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockId hash.
             * @member {Uint8Array} hash
             * @memberof protocol.ChainInventory.BlockId
             * @instance
             */
            BlockId.prototype.hash = $util.newBuffer([]);

            /**
             * BlockId number.
             * @member {number|Long} number
             * @memberof protocol.ChainInventory.BlockId
             * @instance
             */
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BlockId instance using the specified properties.
             * @function create
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.IBlockId=} [properties] Properties to set
             * @returns {protocol.ChainInventory.BlockId} BlockId instance
             */
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };

            /**
             * Encodes the specified BlockId message. Does not implicitly {@link protocol.ChainInventory.BlockId.verify|verify} messages.
             * @function encode
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && message.hasOwnProperty("hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.number);
                return writer;
            };

            /**
             * Encodes the specified BlockId message, length delimited. Does not implicitly {@link protocol.ChainInventory.BlockId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.ChainInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.ChainInventory.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.number = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.ChainInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockId message.
             * @function verify
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };

            /**
             * Creates a BlockId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.ChainInventory.BlockId} BlockId
             */
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.ChainInventory.BlockId)
                    return object;
                var message = new $root.protocol.ChainInventory.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BlockId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.ChainInventory.BlockId
             * @static
             * @param {protocol.ChainInventory.BlockId} message BlockId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };

            /**
             * Converts this BlockId to JSON.
             * @function toJSON
             * @memberof protocol.ChainInventory.BlockId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockId;
        })();

        return ChainInventory;
    })();

    protocol.BlockInventory = (function() {

        /**
         * Properties of a BlockInventory.
         * @memberof protocol
         * @interface IBlockInventory
         * @property {Array.<protocol.BlockInventory.IBlockId>|null} [ids] BlockInventory ids
         * @property {protocol.BlockInventory.Type|null} [type] BlockInventory type
         */

        /**
         * Constructs a new BlockInventory.
         * @memberof protocol
         * @classdesc Represents a BlockInventory.
         * @implements IBlockInventory
         * @constructor
         * @param {protocol.IBlockInventory=} [properties] Properties to set
         */
        function BlockInventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BlockInventory ids.
         * @member {Array.<protocol.BlockInventory.IBlockId>} ids
         * @memberof protocol.BlockInventory
         * @instance
         */
        BlockInventory.prototype.ids = $util.emptyArray;

        /**
         * BlockInventory type.
         * @member {protocol.BlockInventory.Type} type
         * @memberof protocol.BlockInventory
         * @instance
         */
        BlockInventory.prototype.type = 0;

        /**
         * Creates a new BlockInventory instance using the specified properties.
         * @function create
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.IBlockInventory=} [properties] Properties to set
         * @returns {protocol.BlockInventory} BlockInventory instance
         */
        BlockInventory.create = function create(properties) {
            return new BlockInventory(properties);
        };

        /**
         * Encodes the specified BlockInventory message. Does not implicitly {@link protocol.BlockInventory.verify|verify} messages.
         * @function encode
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.IBlockInventory} message BlockInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.protocol.BlockInventory.BlockId.encode(message.ids[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified BlockInventory message, length delimited. Does not implicitly {@link protocol.BlockInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.IBlockInventory} message BlockInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BlockInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BlockInventory message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.BlockInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.BlockInventory} BlockInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockInventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push($root.protocol.BlockInventory.BlockId.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BlockInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.BlockInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.BlockInventory} BlockInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BlockInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BlockInventory message.
         * @function verify
         * @memberof protocol.BlockInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BlockInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.protocol.BlockInventory.BlockId.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a BlockInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.BlockInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.BlockInventory} BlockInventory
         */
        BlockInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.BlockInventory)
                return object;
            var message = new $root.protocol.BlockInventory();
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.BlockInventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".protocol.BlockInventory.ids: object expected");
                    message.ids[i] = $root.protocol.BlockInventory.BlockId.fromObject(object.ids[i]);
                }
            }
            switch (object.type) {
            case "SYNC":
            case 0:
                message.type = 0;
                break;
            case "ADVTISE":
            case 1:
                message.type = 1;
                break;
            case "FETCH":
            case 2:
                message.type = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BlockInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.BlockInventory
         * @static
         * @param {protocol.BlockInventory} message BlockInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BlockInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                object.type = options.enums === String ? "SYNC" : 0;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.protocol.BlockInventory.BlockId.toObject(message.ids[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.BlockInventory.Type[message.type] : message.type;
            return object;
        };

        /**
         * Converts this BlockInventory to JSON.
         * @function toJSON
         * @memberof protocol.BlockInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BlockInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Type enum.
         * @name protocol.BlockInventory.Type
         * @enum {string}
         * @property {number} SYNC=0 SYNC value
         * @property {number} ADVTISE=1 ADVTISE value
         * @property {number} FETCH=2 FETCH value
         */
        BlockInventory.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SYNC"] = 0;
            values[valuesById[1] = "ADVTISE"] = 1;
            values[valuesById[2] = "FETCH"] = 2;
            return values;
        })();

        BlockInventory.BlockId = (function() {

            /**
             * Properties of a BlockId.
             * @memberof protocol.BlockInventory
             * @interface IBlockId
             * @property {Uint8Array|null} [hash] BlockId hash
             * @property {number|Long|null} [number] BlockId number
             */

            /**
             * Constructs a new BlockId.
             * @memberof protocol.BlockInventory
             * @classdesc Represents a BlockId.
             * @implements IBlockId
             * @constructor
             * @param {protocol.BlockInventory.IBlockId=} [properties] Properties to set
             */
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockId hash.
             * @member {Uint8Array} hash
             * @memberof protocol.BlockInventory.BlockId
             * @instance
             */
            BlockId.prototype.hash = $util.newBuffer([]);

            /**
             * BlockId number.
             * @member {number|Long} number
             * @memberof protocol.BlockInventory.BlockId
             * @instance
             */
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BlockId instance using the specified properties.
             * @function create
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.IBlockId=} [properties] Properties to set
             * @returns {protocol.BlockInventory.BlockId} BlockId instance
             */
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };

            /**
             * Encodes the specified BlockId message. Does not implicitly {@link protocol.BlockInventory.BlockId.verify|verify} messages.
             * @function encode
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && message.hasOwnProperty("hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.number);
                return writer;
            };

            /**
             * Encodes the specified BlockId message, length delimited. Does not implicitly {@link protocol.BlockInventory.BlockId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.BlockInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.BlockInventory.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.number = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.BlockInventory.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockId message.
             * @function verify
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };

            /**
             * Creates a BlockId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.BlockInventory.BlockId} BlockId
             */
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.BlockInventory.BlockId)
                    return object;
                var message = new $root.protocol.BlockInventory.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BlockId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.BlockInventory.BlockId
             * @static
             * @param {protocol.BlockInventory.BlockId} message BlockId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };

            /**
             * Converts this BlockId to JSON.
             * @function toJSON
             * @memberof protocol.BlockInventory.BlockId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockId;
        })();

        return BlockInventory;
    })();

    protocol.Inventory = (function() {

        /**
         * Properties of an Inventory.
         * @memberof protocol
         * @interface IInventory
         * @property {protocol.Inventory.InventoryType|null} [type] Inventory type
         * @property {Array.<Uint8Array>|null} [ids] Inventory ids
         */

        /**
         * Constructs a new Inventory.
         * @memberof protocol
         * @classdesc Represents an Inventory.
         * @implements IInventory
         * @constructor
         * @param {protocol.IInventory=} [properties] Properties to set
         */
        function Inventory(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Inventory type.
         * @member {protocol.Inventory.InventoryType} type
         * @memberof protocol.Inventory
         * @instance
         */
        Inventory.prototype.type = 0;

        /**
         * Inventory ids.
         * @member {Array.<Uint8Array>} ids
         * @memberof protocol.Inventory
         * @instance
         */
        Inventory.prototype.ids = $util.emptyArray;

        /**
         * Creates a new Inventory instance using the specified properties.
         * @function create
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.IInventory=} [properties] Properties to set
         * @returns {protocol.Inventory} Inventory instance
         */
        Inventory.create = function create(properties) {
            return new Inventory(properties);
        };

        /**
         * Encodes the specified Inventory message. Does not implicitly {@link protocol.Inventory.verify|verify} messages.
         * @function encode
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.IInventory} message Inventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.ids[i]);
            return writer;
        };

        /**
         * Encodes the specified Inventory message, length delimited. Does not implicitly {@link protocol.Inventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.IInventory} message Inventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Inventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Inventory message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Inventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Inventory} Inventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Inventory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    message.ids.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Inventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Inventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Inventory} Inventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Inventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Inventory message.
         * @function verify
         * @memberof protocol.Inventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Inventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i)
                    if (!(message.ids[i] && typeof message.ids[i].length === "number" || $util.isString(message.ids[i])))
                        return "ids: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates an Inventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Inventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Inventory} Inventory
         */
        Inventory.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Inventory)
                return object;
            var message = new $root.protocol.Inventory();
            switch (object.type) {
            case "TRX":
            case 0:
                message.type = 0;
                break;
            case "BLOCK":
            case 1:
                message.type = 1;
                break;
            }
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".protocol.Inventory.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i)
                    if (typeof object.ids[i] === "string")
                        $util.base64.decode(object.ids[i], message.ids[i] = $util.newBuffer($util.base64.length(object.ids[i])), 0);
                    else if (object.ids[i].length)
                        message.ids[i] = object.ids[i];
            }
            return message;
        };

        /**
         * Creates a plain object from an Inventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Inventory
         * @static
         * @param {protocol.Inventory} message Inventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Inventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults)
                object.type = options.enums === String ? "TRX" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Inventory.InventoryType[message.type] : message.type;
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = options.bytes === String ? $util.base64.encode(message.ids[j], 0, message.ids[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ids[j]) : message.ids[j];
            }
            return object;
        };

        /**
         * Converts this Inventory to JSON.
         * @function toJSON
         * @memberof protocol.Inventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Inventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * InventoryType enum.
         * @name protocol.Inventory.InventoryType
         * @enum {string}
         * @property {number} TRX=0 TRX value
         * @property {number} BLOCK=1 BLOCK value
         */
        Inventory.InventoryType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "TRX"] = 0;
            values[valuesById[1] = "BLOCK"] = 1;
            return values;
        })();

        return Inventory;
    })();

    protocol.Items = (function() {

        /**
         * Properties of an Items.
         * @memberof protocol
         * @interface IItems
         * @property {protocol.Items.ItemType|null} [type] Items type
         * @property {Array.<protocol.IBlock>|null} [blocks] Items blocks
         * @property {Array.<protocol.IBlockHeader>|null} [block_headers] Items block_headers
         * @property {Array.<protocol.ITransaction>|null} [transactions] Items transactions
         */

        /**
         * Constructs a new Items.
         * @memberof protocol
         * @classdesc Represents an Items.
         * @implements IItems
         * @constructor
         * @param {protocol.IItems=} [properties] Properties to set
         */
        function Items(properties) {
            this.blocks = [];
            this.block_headers = [];
            this.transactions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Items type.
         * @member {protocol.Items.ItemType} type
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.type = 0;

        /**
         * Items blocks.
         * @member {Array.<protocol.IBlock>} blocks
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.blocks = $util.emptyArray;

        /**
         * Items block_headers.
         * @member {Array.<protocol.IBlockHeader>} block_headers
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.block_headers = $util.emptyArray;

        /**
         * Items transactions.
         * @member {Array.<protocol.ITransaction>} transactions
         * @memberof protocol.Items
         * @instance
         */
        Items.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new Items instance using the specified properties.
         * @function create
         * @memberof protocol.Items
         * @static
         * @param {protocol.IItems=} [properties] Properties to set
         * @returns {protocol.Items} Items instance
         */
        Items.create = function create(properties) {
            return new Items(properties);
        };

        /**
         * Encodes the specified Items message. Does not implicitly {@link protocol.Items.verify|verify} messages.
         * @function encode
         * @memberof protocol.Items
         * @static
         * @param {protocol.IItems} message Items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Items.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.blocks != null && message.blocks.length)
                for (var i = 0; i < message.blocks.length; ++i)
                    $root.protocol.Block.encode(message.blocks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.block_headers != null && message.block_headers.length)
                for (var i = 0; i < message.block_headers.length; ++i)
                    $root.protocol.BlockHeader.encode(message.block_headers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.transactions != null && message.transactions.length)
                for (var i = 0; i < message.transactions.length; ++i)
                    $root.protocol.Transaction.encode(message.transactions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Items message, length delimited. Does not implicitly {@link protocol.Items.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.Items
         * @static
         * @param {protocol.IItems} message Items message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Items.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Items message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.Items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.Items} Items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Items.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.Items();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.blocks && message.blocks.length))
                        message.blocks = [];
                    message.blocks.push($root.protocol.Block.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.block_headers && message.block_headers.length))
                        message.block_headers = [];
                    message.block_headers.push($root.protocol.BlockHeader.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.protocol.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Items message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.Items
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.Items} Items
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Items.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Items message.
         * @function verify
         * @memberof protocol.Items
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Items.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.blocks != null && message.hasOwnProperty("blocks")) {
                if (!Array.isArray(message.blocks))
                    return "blocks: array expected";
                for (var i = 0; i < message.blocks.length; ++i) {
                    var error = $root.protocol.Block.verify(message.blocks[i]);
                    if (error)
                        return "blocks." + error;
                }
            }
            if (message.block_headers != null && message.hasOwnProperty("block_headers")) {
                if (!Array.isArray(message.block_headers))
                    return "block_headers: array expected";
                for (var i = 0; i < message.block_headers.length; ++i) {
                    var error = $root.protocol.BlockHeader.verify(message.block_headers[i]);
                    if (error)
                        return "block_headers." + error;
                }
            }
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (var i = 0; i < message.transactions.length; ++i) {
                    var error = $root.protocol.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Items message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.Items
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.Items} Items
         */
        Items.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.Items)
                return object;
            var message = new $root.protocol.Items();
            switch (object.type) {
            case "ERR":
            case 0:
                message.type = 0;
                break;
            case "TRX":
            case 1:
                message.type = 1;
                break;
            case "BLOCK":
            case 2:
                message.type = 2;
                break;
            case "BLOCKHEADER":
            case 3:
                message.type = 3;
                break;
            }
            if (object.blocks) {
                if (!Array.isArray(object.blocks))
                    throw TypeError(".protocol.Items.blocks: array expected");
                message.blocks = [];
                for (var i = 0; i < object.blocks.length; ++i) {
                    if (typeof object.blocks[i] !== "object")
                        throw TypeError(".protocol.Items.blocks: object expected");
                    message.blocks[i] = $root.protocol.Block.fromObject(object.blocks[i]);
                }
            }
            if (object.block_headers) {
                if (!Array.isArray(object.block_headers))
                    throw TypeError(".protocol.Items.block_headers: array expected");
                message.block_headers = [];
                for (var i = 0; i < object.block_headers.length; ++i) {
                    if (typeof object.block_headers[i] !== "object")
                        throw TypeError(".protocol.Items.block_headers: object expected");
                    message.block_headers[i] = $root.protocol.BlockHeader.fromObject(object.block_headers[i]);
                }
            }
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".protocol.Items.transactions: array expected");
                message.transactions = [];
                for (var i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".protocol.Items.transactions: object expected");
                    message.transactions[i] = $root.protocol.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an Items message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.Items
         * @static
         * @param {protocol.Items} message Items
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Items.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.blocks = [];
                object.block_headers = [];
                object.transactions = [];
            }
            if (options.defaults)
                object.type = options.enums === String ? "ERR" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.protocol.Items.ItemType[message.type] : message.type;
            if (message.blocks && message.blocks.length) {
                object.blocks = [];
                for (var j = 0; j < message.blocks.length; ++j)
                    object.blocks[j] = $root.protocol.Block.toObject(message.blocks[j], options);
            }
            if (message.block_headers && message.block_headers.length) {
                object.block_headers = [];
                for (var j = 0; j < message.block_headers.length; ++j)
                    object.block_headers[j] = $root.protocol.BlockHeader.toObject(message.block_headers[j], options);
            }
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (var j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.protocol.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this Items to JSON.
         * @function toJSON
         * @memberof protocol.Items
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Items.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ItemType enum.
         * @name protocol.Items.ItemType
         * @enum {string}
         * @property {number} ERR=0 ERR value
         * @property {number} TRX=1 TRX value
         * @property {number} BLOCK=2 BLOCK value
         * @property {number} BLOCKHEADER=3 BLOCKHEADER value
         */
        Items.ItemType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ERR"] = 0;
            values[valuesById[1] = "TRX"] = 1;
            values[valuesById[2] = "BLOCK"] = 2;
            values[valuesById[3] = "BLOCKHEADER"] = 3;
            return values;
        })();

        return Items;
    })();

    protocol.DynamicProperties = (function() {

        /**
         * Properties of a DynamicProperties.
         * @memberof protocol
         * @interface IDynamicProperties
         * @property {number|Long|null} [last_solidity_block_num] DynamicProperties last_solidity_block_num
         */

        /**
         * Constructs a new DynamicProperties.
         * @memberof protocol
         * @classdesc Represents a DynamicProperties.
         * @implements IDynamicProperties
         * @constructor
         * @param {protocol.IDynamicProperties=} [properties] Properties to set
         */
        function DynamicProperties(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DynamicProperties last_solidity_block_num.
         * @member {number|Long} last_solidity_block_num
         * @memberof protocol.DynamicProperties
         * @instance
         */
        DynamicProperties.prototype.last_solidity_block_num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DynamicProperties instance using the specified properties.
         * @function create
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.IDynamicProperties=} [properties] Properties to set
         * @returns {protocol.DynamicProperties} DynamicProperties instance
         */
        DynamicProperties.create = function create(properties) {
            return new DynamicProperties(properties);
        };

        /**
         * Encodes the specified DynamicProperties message. Does not implicitly {@link protocol.DynamicProperties.verify|verify} messages.
         * @function encode
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.IDynamicProperties} message DynamicProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynamicProperties.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.last_solidity_block_num != null && message.hasOwnProperty("last_solidity_block_num"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.last_solidity_block_num);
            return writer;
        };

        /**
         * Encodes the specified DynamicProperties message, length delimited. Does not implicitly {@link protocol.DynamicProperties.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.IDynamicProperties} message DynamicProperties message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DynamicProperties.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DynamicProperties message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DynamicProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DynamicProperties} DynamicProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynamicProperties.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DynamicProperties();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.last_solidity_block_num = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DynamicProperties message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DynamicProperties
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DynamicProperties} DynamicProperties
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DynamicProperties.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DynamicProperties message.
         * @function verify
         * @memberof protocol.DynamicProperties
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DynamicProperties.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.last_solidity_block_num != null && message.hasOwnProperty("last_solidity_block_num"))
                if (!$util.isInteger(message.last_solidity_block_num) && !(message.last_solidity_block_num && $util.isInteger(message.last_solidity_block_num.low) && $util.isInteger(message.last_solidity_block_num.high)))
                    return "last_solidity_block_num: integer|Long expected";
            return null;
        };

        /**
         * Creates a DynamicProperties message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DynamicProperties
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DynamicProperties} DynamicProperties
         */
        DynamicProperties.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DynamicProperties)
                return object;
            var message = new $root.protocol.DynamicProperties();
            if (object.last_solidity_block_num != null)
                if ($util.Long)
                    (message.last_solidity_block_num = $util.Long.fromValue(object.last_solidity_block_num)).unsigned = false;
                else if (typeof object.last_solidity_block_num === "string")
                    message.last_solidity_block_num = parseInt(object.last_solidity_block_num, 10);
                else if (typeof object.last_solidity_block_num === "number")
                    message.last_solidity_block_num = object.last_solidity_block_num;
                else if (typeof object.last_solidity_block_num === "object")
                    message.last_solidity_block_num = new $util.LongBits(object.last_solidity_block_num.low >>> 0, object.last_solidity_block_num.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DynamicProperties message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DynamicProperties
         * @static
         * @param {protocol.DynamicProperties} message DynamicProperties
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DynamicProperties.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.last_solidity_block_num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.last_solidity_block_num = options.longs === String ? "0" : 0;
            if (message.last_solidity_block_num != null && message.hasOwnProperty("last_solidity_block_num"))
                if (typeof message.last_solidity_block_num === "number")
                    object.last_solidity_block_num = options.longs === String ? String(message.last_solidity_block_num) : message.last_solidity_block_num;
                else
                    object.last_solidity_block_num = options.longs === String ? $util.Long.prototype.toString.call(message.last_solidity_block_num) : options.longs === Number ? new $util.LongBits(message.last_solidity_block_num.low >>> 0, message.last_solidity_block_num.high >>> 0).toNumber() : message.last_solidity_block_num;
            return object;
        };

        /**
         * Converts this DynamicProperties to JSON.
         * @function toJSON
         * @memberof protocol.DynamicProperties
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DynamicProperties.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DynamicProperties;
    })();

    /**
     * ReasonCode enum.
     * @name protocol.ReasonCode
     * @enum {string}
     * @property {number} REQUESTED=0 REQUESTED value
     * @property {number} BAD_PROTOCOL=2 BAD_PROTOCOL value
     * @property {number} TOO_MANY_PEERS=4 TOO_MANY_PEERS value
     * @property {number} DUPLICATE_PEER=5 DUPLICATE_PEER value
     * @property {number} INCOMPATIBLE_PROTOCOL=6 INCOMPATIBLE_PROTOCOL value
     * @property {number} NULL_IDENTITY=7 NULL_IDENTITY value
     * @property {number} PEER_QUITING=8 PEER_QUITING value
     * @property {number} UNEXPECTED_IDENTITY=9 UNEXPECTED_IDENTITY value
     * @property {number} LOCAL_IDENTITY=10 LOCAL_IDENTITY value
     * @property {number} PING_TIMEOUT=11 PING_TIMEOUT value
     * @property {number} USER_REASON=16 USER_REASON value
     * @property {number} RESET=17 RESET value
     * @property {number} SYNC_FAIL=18 SYNC_FAIL value
     * @property {number} FETCH_FAIL=19 FETCH_FAIL value
     * @property {number} BAD_TX=20 BAD_TX value
     * @property {number} BAD_BLOCK=21 BAD_BLOCK value
     * @property {number} FORKED=22 FORKED value
     * @property {number} UNLINKABLE=23 UNLINKABLE value
     * @property {number} INCOMPATIBLE_VERSION=24 INCOMPATIBLE_VERSION value
     * @property {number} INCOMPATIBLE_CHAIN=25 INCOMPATIBLE_CHAIN value
     * @property {number} TIME_OUT=32 TIME_OUT value
     * @property {number} CONNECT_FAIL=33 CONNECT_FAIL value
     * @property {number} TOO_MANY_PEERS_WITH_SAME_IP=34 TOO_MANY_PEERS_WITH_SAME_IP value
     * @property {number} UNKNOWN=255 UNKNOWN value
     */
    protocol.ReasonCode = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "REQUESTED"] = 0;
        values[valuesById[2] = "BAD_PROTOCOL"] = 2;
        values[valuesById[4] = "TOO_MANY_PEERS"] = 4;
        values[valuesById[5] = "DUPLICATE_PEER"] = 5;
        values[valuesById[6] = "INCOMPATIBLE_PROTOCOL"] = 6;
        values[valuesById[7] = "NULL_IDENTITY"] = 7;
        values[valuesById[8] = "PEER_QUITING"] = 8;
        values[valuesById[9] = "UNEXPECTED_IDENTITY"] = 9;
        values[valuesById[10] = "LOCAL_IDENTITY"] = 10;
        values[valuesById[11] = "PING_TIMEOUT"] = 11;
        values[valuesById[16] = "USER_REASON"] = 16;
        values[valuesById[17] = "RESET"] = 17;
        values[valuesById[18] = "SYNC_FAIL"] = 18;
        values[valuesById[19] = "FETCH_FAIL"] = 19;
        values[valuesById[20] = "BAD_TX"] = 20;
        values[valuesById[21] = "BAD_BLOCK"] = 21;
        values[valuesById[22] = "FORKED"] = 22;
        values[valuesById[23] = "UNLINKABLE"] = 23;
        values[valuesById[24] = "INCOMPATIBLE_VERSION"] = 24;
        values[valuesById[25] = "INCOMPATIBLE_CHAIN"] = 25;
        values[valuesById[32] = "TIME_OUT"] = 32;
        values[valuesById[33] = "CONNECT_FAIL"] = 33;
        values[valuesById[34] = "TOO_MANY_PEERS_WITH_SAME_IP"] = 34;
        values[valuesById[255] = "UNKNOWN"] = 255;
        return values;
    })();

    protocol.DisconnectMessage = (function() {

        /**
         * Properties of a DisconnectMessage.
         * @memberof protocol
         * @interface IDisconnectMessage
         * @property {protocol.ReasonCode|null} [reason] DisconnectMessage reason
         */

        /**
         * Constructs a new DisconnectMessage.
         * @memberof protocol
         * @classdesc Represents a DisconnectMessage.
         * @implements IDisconnectMessage
         * @constructor
         * @param {protocol.IDisconnectMessage=} [properties] Properties to set
         */
        function DisconnectMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DisconnectMessage reason.
         * @member {protocol.ReasonCode} reason
         * @memberof protocol.DisconnectMessage
         * @instance
         */
        DisconnectMessage.prototype.reason = 0;

        /**
         * Creates a new DisconnectMessage instance using the specified properties.
         * @function create
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.IDisconnectMessage=} [properties] Properties to set
         * @returns {protocol.DisconnectMessage} DisconnectMessage instance
         */
        DisconnectMessage.create = function create(properties) {
            return new DisconnectMessage(properties);
        };

        /**
         * Encodes the specified DisconnectMessage message. Does not implicitly {@link protocol.DisconnectMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.IDisconnectMessage} message DisconnectMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && message.hasOwnProperty("reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.reason);
            return writer;
        };

        /**
         * Encodes the specified DisconnectMessage message, length delimited. Does not implicitly {@link protocol.DisconnectMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.IDisconnectMessage} message DisconnectMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DisconnectMessage} DisconnectMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DisconnectMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DisconnectMessage} DisconnectMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectMessage message.
         * @function verify
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                switch (message.reason) {
                default:
                    return "reason: enum value expected";
                case 0:
                case 2:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 32:
                case 33:
                case 34:
                case 255:
                    break;
                }
            return null;
        };

        /**
         * Creates a DisconnectMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DisconnectMessage} DisconnectMessage
         */
        DisconnectMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DisconnectMessage)
                return object;
            var message = new $root.protocol.DisconnectMessage();
            switch (object.reason) {
            case "REQUESTED":
            case 0:
                message.reason = 0;
                break;
            case "BAD_PROTOCOL":
            case 2:
                message.reason = 2;
                break;
            case "TOO_MANY_PEERS":
            case 4:
                message.reason = 4;
                break;
            case "DUPLICATE_PEER":
            case 5:
                message.reason = 5;
                break;
            case "INCOMPATIBLE_PROTOCOL":
            case 6:
                message.reason = 6;
                break;
            case "NULL_IDENTITY":
            case 7:
                message.reason = 7;
                break;
            case "PEER_QUITING":
            case 8:
                message.reason = 8;
                break;
            case "UNEXPECTED_IDENTITY":
            case 9:
                message.reason = 9;
                break;
            case "LOCAL_IDENTITY":
            case 10:
                message.reason = 10;
                break;
            case "PING_TIMEOUT":
            case 11:
                message.reason = 11;
                break;
            case "USER_REASON":
            case 16:
                message.reason = 16;
                break;
            case "RESET":
            case 17:
                message.reason = 17;
                break;
            case "SYNC_FAIL":
            case 18:
                message.reason = 18;
                break;
            case "FETCH_FAIL":
            case 19:
                message.reason = 19;
                break;
            case "BAD_TX":
            case 20:
                message.reason = 20;
                break;
            case "BAD_BLOCK":
            case 21:
                message.reason = 21;
                break;
            case "FORKED":
            case 22:
                message.reason = 22;
                break;
            case "UNLINKABLE":
            case 23:
                message.reason = 23;
                break;
            case "INCOMPATIBLE_VERSION":
            case 24:
                message.reason = 24;
                break;
            case "INCOMPATIBLE_CHAIN":
            case 25:
                message.reason = 25;
                break;
            case "TIME_OUT":
            case 32:
                message.reason = 32;
                break;
            case "CONNECT_FAIL":
            case 33:
                message.reason = 33;
                break;
            case "TOO_MANY_PEERS_WITH_SAME_IP":
            case 34:
                message.reason = 34;
                break;
            case "UNKNOWN":
            case 255:
                message.reason = 255;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a DisconnectMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DisconnectMessage
         * @static
         * @param {protocol.DisconnectMessage} message DisconnectMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.reason = options.enums === String ? "REQUESTED" : 0;
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = options.enums === String ? $root.protocol.ReasonCode[message.reason] : message.reason;
            return object;
        };

        /**
         * Converts this DisconnectMessage to JSON.
         * @function toJSON
         * @memberof protocol.DisconnectMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectMessage;
    })();

    protocol.HelloMessage = (function() {

        /**
         * Properties of a HelloMessage.
         * @memberof protocol
         * @interface IHelloMessage
         * @property {protocol.IEndpoint|null} [from] HelloMessage from
         * @property {number|null} [version] HelloMessage version
         * @property {number|Long|null} [timestamp] HelloMessage timestamp
         * @property {protocol.HelloMessage.IBlockId|null} [genesisBlockId] HelloMessage genesisBlockId
         * @property {protocol.HelloMessage.IBlockId|null} [solidBlockId] HelloMessage solidBlockId
         * @property {protocol.HelloMessage.IBlockId|null} [headBlockId] HelloMessage headBlockId
         */

        /**
         * Constructs a new HelloMessage.
         * @memberof protocol
         * @classdesc Represents a HelloMessage.
         * @implements IHelloMessage
         * @constructor
         * @param {protocol.IHelloMessage=} [properties] Properties to set
         */
        function HelloMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HelloMessage from.
         * @member {protocol.IEndpoint|null|undefined} from
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.from = null;

        /**
         * HelloMessage version.
         * @member {number} version
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.version = 0;

        /**
         * HelloMessage timestamp.
         * @member {number|Long} timestamp
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HelloMessage genesisBlockId.
         * @member {protocol.HelloMessage.IBlockId|null|undefined} genesisBlockId
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.genesisBlockId = null;

        /**
         * HelloMessage solidBlockId.
         * @member {protocol.HelloMessage.IBlockId|null|undefined} solidBlockId
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.solidBlockId = null;

        /**
         * HelloMessage headBlockId.
         * @member {protocol.HelloMessage.IBlockId|null|undefined} headBlockId
         * @memberof protocol.HelloMessage
         * @instance
         */
        HelloMessage.prototype.headBlockId = null;

        /**
         * Creates a new HelloMessage instance using the specified properties.
         * @function create
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.IHelloMessage=} [properties] Properties to set
         * @returns {protocol.HelloMessage} HelloMessage instance
         */
        HelloMessage.create = function create(properties) {
            return new HelloMessage(properties);
        };

        /**
         * Encodes the specified HelloMessage message. Does not implicitly {@link protocol.HelloMessage.verify|verify} messages.
         * @function encode
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.IHelloMessage} message HelloMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelloMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.protocol.Endpoint.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.version);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.genesisBlockId, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.solidBlockId, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId"))
                $root.protocol.HelloMessage.BlockId.encode(message.headBlockId, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HelloMessage message, length delimited. Does not implicitly {@link protocol.HelloMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.IHelloMessage} message HelloMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelloMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HelloMessage message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.HelloMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.HelloMessage} HelloMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelloMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.HelloMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.protocol.Endpoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.version = reader.int32();
                    break;
                case 3:
                    message.timestamp = reader.int64();
                    break;
                case 4:
                    message.genesisBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.solidBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.headBlockId = $root.protocol.HelloMessage.BlockId.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HelloMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.HelloMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.HelloMessage} HelloMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelloMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HelloMessage message.
         * @function verify
         * @memberof protocol.HelloMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelloMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.protocol.Endpoint.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isInteger(message.version))
                    return "version: integer expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.genesisBlockId);
                if (error)
                    return "genesisBlockId." + error;
            }
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.solidBlockId);
                if (error)
                    return "solidBlockId." + error;
            }
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId")) {
                var error = $root.protocol.HelloMessage.BlockId.verify(message.headBlockId);
                if (error)
                    return "headBlockId." + error;
            }
            return null;
        };

        /**
         * Creates a HelloMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.HelloMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.HelloMessage} HelloMessage
         */
        HelloMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.HelloMessage)
                return object;
            var message = new $root.protocol.HelloMessage();
            if (object.from != null) {
                if (typeof object.from !== "object")
                    throw TypeError(".protocol.HelloMessage.from: object expected");
                message.from = $root.protocol.Endpoint.fromObject(object.from);
            }
            if (object.version != null)
                message.version = object.version | 0;
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.genesisBlockId != null) {
                if (typeof object.genesisBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.genesisBlockId: object expected");
                message.genesisBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.genesisBlockId);
            }
            if (object.solidBlockId != null) {
                if (typeof object.solidBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.solidBlockId: object expected");
                message.solidBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.solidBlockId);
            }
            if (object.headBlockId != null) {
                if (typeof object.headBlockId !== "object")
                    throw TypeError(".protocol.HelloMessage.headBlockId: object expected");
                message.headBlockId = $root.protocol.HelloMessage.BlockId.fromObject(object.headBlockId);
            }
            return message;
        };

        /**
         * Creates a plain object from a HelloMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.HelloMessage
         * @static
         * @param {protocol.HelloMessage} message HelloMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HelloMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.from = null;
                object.version = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                object.genesisBlockId = null;
                object.solidBlockId = null;
                object.headBlockId = null;
            }
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = $root.protocol.Endpoint.toObject(message.from, options);
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.genesisBlockId != null && message.hasOwnProperty("genesisBlockId"))
                object.genesisBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.genesisBlockId, options);
            if (message.solidBlockId != null && message.hasOwnProperty("solidBlockId"))
                object.solidBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.solidBlockId, options);
            if (message.headBlockId != null && message.hasOwnProperty("headBlockId"))
                object.headBlockId = $root.protocol.HelloMessage.BlockId.toObject(message.headBlockId, options);
            return object;
        };

        /**
         * Converts this HelloMessage to JSON.
         * @function toJSON
         * @memberof protocol.HelloMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HelloMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        HelloMessage.BlockId = (function() {

            /**
             * Properties of a BlockId.
             * @memberof protocol.HelloMessage
             * @interface IBlockId
             * @property {Uint8Array|null} [hash] BlockId hash
             * @property {number|Long|null} [number] BlockId number
             */

            /**
             * Constructs a new BlockId.
             * @memberof protocol.HelloMessage
             * @classdesc Represents a BlockId.
             * @implements IBlockId
             * @constructor
             * @param {protocol.HelloMessage.IBlockId=} [properties] Properties to set
             */
            function BlockId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BlockId hash.
             * @member {Uint8Array} hash
             * @memberof protocol.HelloMessage.BlockId
             * @instance
             */
            BlockId.prototype.hash = $util.newBuffer([]);

            /**
             * BlockId number.
             * @member {number|Long} number
             * @memberof protocol.HelloMessage.BlockId
             * @instance
             */
            BlockId.prototype.number = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new BlockId instance using the specified properties.
             * @function create
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.IBlockId=} [properties] Properties to set
             * @returns {protocol.HelloMessage.BlockId} BlockId instance
             */
            BlockId.create = function create(properties) {
                return new BlockId(properties);
            };

            /**
             * Encodes the specified BlockId message. Does not implicitly {@link protocol.HelloMessage.BlockId.verify|verify} messages.
             * @function encode
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hash != null && message.hasOwnProperty("hash"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.number);
                return writer;
            };

            /**
             * Encodes the specified BlockId message, length delimited. Does not implicitly {@link protocol.HelloMessage.BlockId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.IBlockId} message BlockId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.HelloMessage.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.HelloMessage.BlockId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.hash = reader.bytes();
                        break;
                    case 2:
                        message.number = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.HelloMessage.BlockId} BlockId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockId message.
             * @function verify
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hash != null && message.hasOwnProperty("hash"))
                    if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                        return "hash: buffer expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number) && !(message.number && $util.isInteger(message.number.low) && $util.isInteger(message.number.high)))
                        return "number: integer|Long expected";
                return null;
            };

            /**
             * Creates a BlockId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.HelloMessage.BlockId} BlockId
             */
            BlockId.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.HelloMessage.BlockId)
                    return object;
                var message = new $root.protocol.HelloMessage.BlockId();
                if (object.hash != null)
                    if (typeof object.hash === "string")
                        $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                    else if (object.hash.length)
                        message.hash = object.hash;
                if (object.number != null)
                    if ($util.Long)
                        (message.number = $util.Long.fromValue(object.number)).unsigned = false;
                    else if (typeof object.number === "string")
                        message.number = parseInt(object.number, 10);
                    else if (typeof object.number === "number")
                        message.number = object.number;
                    else if (typeof object.number === "object")
                        message.number = new $util.LongBits(object.number.low >>> 0, object.number.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BlockId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.HelloMessage.BlockId
             * @static
             * @param {protocol.HelloMessage.BlockId} message BlockId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.hash = "";
                    else {
                        object.hash = [];
                        if (options.bytes !== Array)
                            object.hash = $util.newBuffer(object.hash);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.number = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.number = options.longs === String ? "0" : 0;
                }
                if (message.hash != null && message.hasOwnProperty("hash"))
                    object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
                if (message.number != null && message.hasOwnProperty("number"))
                    if (typeof message.number === "number")
                        object.number = options.longs === String ? String(message.number) : message.number;
                    else
                        object.number = options.longs === String ? $util.Long.prototype.toString.call(message.number) : options.longs === Number ? new $util.LongBits(message.number.low >>> 0, message.number.high >>> 0).toNumber() : message.number;
                return object;
            };

            /**
             * Converts this BlockId to JSON.
             * @function toJSON
             * @memberof protocol.HelloMessage.BlockId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BlockId;
        })();

        return HelloMessage;
    })();

    protocol.SmartContract = (function() {

        /**
         * Properties of a SmartContract.
         * @memberof protocol
         * @interface ISmartContract
         * @property {Uint8Array|null} [origin_address] SmartContract origin_address
         * @property {Uint8Array|null} [contract_address] SmartContract contract_address
         * @property {protocol.SmartContract.IABI|null} [abi] SmartContract abi
         * @property {Uint8Array|null} [bytecode] SmartContract bytecode
         * @property {number|Long|null} [call_value] SmartContract call_value
         * @property {number|Long|null} [consume_user_resource_percent] SmartContract consume_user_resource_percent
         * @property {string|null} [name] SmartContract name
         * @property {number|Long|null} [origin_energy_limit] SmartContract origin_energy_limit
         * @property {Uint8Array|null} [code_hash] SmartContract code_hash
         * @property {Uint8Array|null} [trx_hash] SmartContract trx_hash
         */

        /**
         * Constructs a new SmartContract.
         * @memberof protocol
         * @classdesc Represents a SmartContract.
         * @implements ISmartContract
         * @constructor
         * @param {protocol.ISmartContract=} [properties] Properties to set
         */
        function SmartContract(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SmartContract origin_address.
         * @member {Uint8Array} origin_address
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.origin_address = $util.newBuffer([]);

        /**
         * SmartContract contract_address.
         * @member {Uint8Array} contract_address
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.contract_address = $util.newBuffer([]);

        /**
         * SmartContract abi.
         * @member {protocol.SmartContract.IABI|null|undefined} abi
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.abi = null;

        /**
         * SmartContract bytecode.
         * @member {Uint8Array} bytecode
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.bytecode = $util.newBuffer([]);

        /**
         * SmartContract call_value.
         * @member {number|Long} call_value
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.call_value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SmartContract consume_user_resource_percent.
         * @member {number|Long} consume_user_resource_percent
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.consume_user_resource_percent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SmartContract name.
         * @member {string} name
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.name = "";

        /**
         * SmartContract origin_energy_limit.
         * @member {number|Long} origin_energy_limit
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.origin_energy_limit = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SmartContract code_hash.
         * @member {Uint8Array} code_hash
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.code_hash = $util.newBuffer([]);

        /**
         * SmartContract trx_hash.
         * @member {Uint8Array} trx_hash
         * @memberof protocol.SmartContract
         * @instance
         */
        SmartContract.prototype.trx_hash = $util.newBuffer([]);

        /**
         * Creates a new SmartContract instance using the specified properties.
         * @function create
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.ISmartContract=} [properties] Properties to set
         * @returns {protocol.SmartContract} SmartContract instance
         */
        SmartContract.create = function create(properties) {
            return new SmartContract(properties);
        };

        /**
         * Encodes the specified SmartContract message. Does not implicitly {@link protocol.SmartContract.verify|verify} messages.
         * @function encode
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.ISmartContract} message SmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmartContract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.origin_address != null && message.hasOwnProperty("origin_address"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.origin_address);
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contract_address);
            if (message.abi != null && message.hasOwnProperty("abi"))
                $root.protocol.SmartContract.ABI.encode(message.abi, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bytecode);
            if (message.call_value != null && message.hasOwnProperty("call_value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.call_value);
            if (message.consume_user_resource_percent != null && message.hasOwnProperty("consume_user_resource_percent"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.consume_user_resource_percent);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.origin_energy_limit != null && message.hasOwnProperty("origin_energy_limit"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.origin_energy_limit);
            if (message.code_hash != null && message.hasOwnProperty("code_hash"))
                writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.code_hash);
            if (message.trx_hash != null && message.hasOwnProperty("trx_hash"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.trx_hash);
            return writer;
        };

        /**
         * Encodes the specified SmartContract message, length delimited. Does not implicitly {@link protocol.SmartContract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.ISmartContract} message SmartContract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SmartContract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SmartContract message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.SmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.SmartContract} SmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmartContract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.origin_address = reader.bytes();
                    break;
                case 2:
                    message.contract_address = reader.bytes();
                    break;
                case 3:
                    message.abi = $root.protocol.SmartContract.ABI.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.bytecode = reader.bytes();
                    break;
                case 5:
                    message.call_value = reader.int64();
                    break;
                case 6:
                    message.consume_user_resource_percent = reader.int64();
                    break;
                case 7:
                    message.name = reader.string();
                    break;
                case 8:
                    message.origin_energy_limit = reader.int64();
                    break;
                case 9:
                    message.code_hash = reader.bytes();
                    break;
                case 10:
                    message.trx_hash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SmartContract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.SmartContract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.SmartContract} SmartContract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SmartContract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SmartContract message.
         * @function verify
         * @memberof protocol.SmartContract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SmartContract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.origin_address != null && message.hasOwnProperty("origin_address"))
                if (!(message.origin_address && typeof message.origin_address.length === "number" || $util.isString(message.origin_address)))
                    return "origin_address: buffer expected";
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                if (!(message.contract_address && typeof message.contract_address.length === "number" || $util.isString(message.contract_address)))
                    return "contract_address: buffer expected";
            if (message.abi != null && message.hasOwnProperty("abi")) {
                var error = $root.protocol.SmartContract.ABI.verify(message.abi);
                if (error)
                    return "abi." + error;
            }
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                if (!(message.bytecode && typeof message.bytecode.length === "number" || $util.isString(message.bytecode)))
                    return "bytecode: buffer expected";
            if (message.call_value != null && message.hasOwnProperty("call_value"))
                if (!$util.isInteger(message.call_value) && !(message.call_value && $util.isInteger(message.call_value.low) && $util.isInteger(message.call_value.high)))
                    return "call_value: integer|Long expected";
            if (message.consume_user_resource_percent != null && message.hasOwnProperty("consume_user_resource_percent"))
                if (!$util.isInteger(message.consume_user_resource_percent) && !(message.consume_user_resource_percent && $util.isInteger(message.consume_user_resource_percent.low) && $util.isInteger(message.consume_user_resource_percent.high)))
                    return "consume_user_resource_percent: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.origin_energy_limit != null && message.hasOwnProperty("origin_energy_limit"))
                if (!$util.isInteger(message.origin_energy_limit) && !(message.origin_energy_limit && $util.isInteger(message.origin_energy_limit.low) && $util.isInteger(message.origin_energy_limit.high)))
                    return "origin_energy_limit: integer|Long expected";
            if (message.code_hash != null && message.hasOwnProperty("code_hash"))
                if (!(message.code_hash && typeof message.code_hash.length === "number" || $util.isString(message.code_hash)))
                    return "code_hash: buffer expected";
            if (message.trx_hash != null && message.hasOwnProperty("trx_hash"))
                if (!(message.trx_hash && typeof message.trx_hash.length === "number" || $util.isString(message.trx_hash)))
                    return "trx_hash: buffer expected";
            return null;
        };

        /**
         * Creates a SmartContract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.SmartContract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.SmartContract} SmartContract
         */
        SmartContract.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.SmartContract)
                return object;
            var message = new $root.protocol.SmartContract();
            if (object.origin_address != null)
                if (typeof object.origin_address === "string")
                    $util.base64.decode(object.origin_address, message.origin_address = $util.newBuffer($util.base64.length(object.origin_address)), 0);
                else if (object.origin_address.length)
                    message.origin_address = object.origin_address;
            if (object.contract_address != null)
                if (typeof object.contract_address === "string")
                    $util.base64.decode(object.contract_address, message.contract_address = $util.newBuffer($util.base64.length(object.contract_address)), 0);
                else if (object.contract_address.length)
                    message.contract_address = object.contract_address;
            if (object.abi != null) {
                if (typeof object.abi !== "object")
                    throw TypeError(".protocol.SmartContract.abi: object expected");
                message.abi = $root.protocol.SmartContract.ABI.fromObject(object.abi);
            }
            if (object.bytecode != null)
                if (typeof object.bytecode === "string")
                    $util.base64.decode(object.bytecode, message.bytecode = $util.newBuffer($util.base64.length(object.bytecode)), 0);
                else if (object.bytecode.length)
                    message.bytecode = object.bytecode;
            if (object.call_value != null)
                if ($util.Long)
                    (message.call_value = $util.Long.fromValue(object.call_value)).unsigned = false;
                else if (typeof object.call_value === "string")
                    message.call_value = parseInt(object.call_value, 10);
                else if (typeof object.call_value === "number")
                    message.call_value = object.call_value;
                else if (typeof object.call_value === "object")
                    message.call_value = new $util.LongBits(object.call_value.low >>> 0, object.call_value.high >>> 0).toNumber();
            if (object.consume_user_resource_percent != null)
                if ($util.Long)
                    (message.consume_user_resource_percent = $util.Long.fromValue(object.consume_user_resource_percent)).unsigned = false;
                else if (typeof object.consume_user_resource_percent === "string")
                    message.consume_user_resource_percent = parseInt(object.consume_user_resource_percent, 10);
                else if (typeof object.consume_user_resource_percent === "number")
                    message.consume_user_resource_percent = object.consume_user_resource_percent;
                else if (typeof object.consume_user_resource_percent === "object")
                    message.consume_user_resource_percent = new $util.LongBits(object.consume_user_resource_percent.low >>> 0, object.consume_user_resource_percent.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.origin_energy_limit != null)
                if ($util.Long)
                    (message.origin_energy_limit = $util.Long.fromValue(object.origin_energy_limit)).unsigned = false;
                else if (typeof object.origin_energy_limit === "string")
                    message.origin_energy_limit = parseInt(object.origin_energy_limit, 10);
                else if (typeof object.origin_energy_limit === "number")
                    message.origin_energy_limit = object.origin_energy_limit;
                else if (typeof object.origin_energy_limit === "object")
                    message.origin_energy_limit = new $util.LongBits(object.origin_energy_limit.low >>> 0, object.origin_energy_limit.high >>> 0).toNumber();
            if (object.code_hash != null)
                if (typeof object.code_hash === "string")
                    $util.base64.decode(object.code_hash, message.code_hash = $util.newBuffer($util.base64.length(object.code_hash)), 0);
                else if (object.code_hash.length)
                    message.code_hash = object.code_hash;
            if (object.trx_hash != null)
                if (typeof object.trx_hash === "string")
                    $util.base64.decode(object.trx_hash, message.trx_hash = $util.newBuffer($util.base64.length(object.trx_hash)), 0);
                else if (object.trx_hash.length)
                    message.trx_hash = object.trx_hash;
            return message;
        };

        /**
         * Creates a plain object from a SmartContract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.SmartContract
         * @static
         * @param {protocol.SmartContract} message SmartContract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SmartContract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.origin_address = "";
                else {
                    object.origin_address = [];
                    if (options.bytes !== Array)
                        object.origin_address = $util.newBuffer(object.origin_address);
                }
                if (options.bytes === String)
                    object.contract_address = "";
                else {
                    object.contract_address = [];
                    if (options.bytes !== Array)
                        object.contract_address = $util.newBuffer(object.contract_address);
                }
                object.abi = null;
                if (options.bytes === String)
                    object.bytecode = "";
                else {
                    object.bytecode = [];
                    if (options.bytes !== Array)
                        object.bytecode = $util.newBuffer(object.bytecode);
                }
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.call_value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.call_value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.consume_user_resource_percent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.consume_user_resource_percent = options.longs === String ? "0" : 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.origin_energy_limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.origin_energy_limit = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.code_hash = "";
                else {
                    object.code_hash = [];
                    if (options.bytes !== Array)
                        object.code_hash = $util.newBuffer(object.code_hash);
                }
                if (options.bytes === String)
                    object.trx_hash = "";
                else {
                    object.trx_hash = [];
                    if (options.bytes !== Array)
                        object.trx_hash = $util.newBuffer(object.trx_hash);
                }
            }
            if (message.origin_address != null && message.hasOwnProperty("origin_address"))
                object.origin_address = options.bytes === String ? $util.base64.encode(message.origin_address, 0, message.origin_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.origin_address) : message.origin_address;
            if (message.contract_address != null && message.hasOwnProperty("contract_address"))
                object.contract_address = options.bytes === String ? $util.base64.encode(message.contract_address, 0, message.contract_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.contract_address) : message.contract_address;
            if (message.abi != null && message.hasOwnProperty("abi"))
                object.abi = $root.protocol.SmartContract.ABI.toObject(message.abi, options);
            if (message.bytecode != null && message.hasOwnProperty("bytecode"))
                object.bytecode = options.bytes === String ? $util.base64.encode(message.bytecode, 0, message.bytecode.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytecode) : message.bytecode;
            if (message.call_value != null && message.hasOwnProperty("call_value"))
                if (typeof message.call_value === "number")
                    object.call_value = options.longs === String ? String(message.call_value) : message.call_value;
                else
                    object.call_value = options.longs === String ? $util.Long.prototype.toString.call(message.call_value) : options.longs === Number ? new $util.LongBits(message.call_value.low >>> 0, message.call_value.high >>> 0).toNumber() : message.call_value;
            if (message.consume_user_resource_percent != null && message.hasOwnProperty("consume_user_resource_percent"))
                if (typeof message.consume_user_resource_percent === "number")
                    object.consume_user_resource_percent = options.longs === String ? String(message.consume_user_resource_percent) : message.consume_user_resource_percent;
                else
                    object.consume_user_resource_percent = options.longs === String ? $util.Long.prototype.toString.call(message.consume_user_resource_percent) : options.longs === Number ? new $util.LongBits(message.consume_user_resource_percent.low >>> 0, message.consume_user_resource_percent.high >>> 0).toNumber() : message.consume_user_resource_percent;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.origin_energy_limit != null && message.hasOwnProperty("origin_energy_limit"))
                if (typeof message.origin_energy_limit === "number")
                    object.origin_energy_limit = options.longs === String ? String(message.origin_energy_limit) : message.origin_energy_limit;
                else
                    object.origin_energy_limit = options.longs === String ? $util.Long.prototype.toString.call(message.origin_energy_limit) : options.longs === Number ? new $util.LongBits(message.origin_energy_limit.low >>> 0, message.origin_energy_limit.high >>> 0).toNumber() : message.origin_energy_limit;
            if (message.code_hash != null && message.hasOwnProperty("code_hash"))
                object.code_hash = options.bytes === String ? $util.base64.encode(message.code_hash, 0, message.code_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.code_hash) : message.code_hash;
            if (message.trx_hash != null && message.hasOwnProperty("trx_hash"))
                object.trx_hash = options.bytes === String ? $util.base64.encode(message.trx_hash, 0, message.trx_hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.trx_hash) : message.trx_hash;
            return object;
        };

        /**
         * Converts this SmartContract to JSON.
         * @function toJSON
         * @memberof protocol.SmartContract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SmartContract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        SmartContract.ABI = (function() {

            /**
             * Properties of a ABI.
             * @memberof protocol.SmartContract
             * @interface IABI
             * @property {Array.<protocol.SmartContract.ABI.IEntry>|null} [entrys] ABI entrys
             */

            /**
             * Constructs a new ABI.
             * @memberof protocol.SmartContract
             * @classdesc Represents a ABI.
             * @implements IABI
             * @constructor
             * @param {protocol.SmartContract.IABI=} [properties] Properties to set
             */
            function ABI(properties) {
                this.entrys = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ABI entrys.
             * @member {Array.<protocol.SmartContract.ABI.IEntry>} entrys
             * @memberof protocol.SmartContract.ABI
             * @instance
             */
            ABI.prototype.entrys = $util.emptyArray;

            /**
             * Creates a new ABI instance using the specified properties.
             * @function create
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.IABI=} [properties] Properties to set
             * @returns {protocol.SmartContract.ABI} ABI instance
             */
            ABI.create = function create(properties) {
                return new ABI(properties);
            };

            /**
             * Encodes the specified ABI message. Does not implicitly {@link protocol.SmartContract.ABI.verify|verify} messages.
             * @function encode
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.IABI} message ABI message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ABI.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.entrys != null && message.entrys.length)
                    for (var i = 0; i < message.entrys.length; ++i)
                        $root.protocol.SmartContract.ABI.Entry.encode(message.entrys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ABI message, length delimited. Does not implicitly {@link protocol.SmartContract.ABI.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.IABI} message ABI message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ABI.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ABI message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.SmartContract.ABI} ABI
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ABI.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.entrys && message.entrys.length))
                            message.entrys = [];
                        message.entrys.push($root.protocol.SmartContract.ABI.Entry.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ABI message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.SmartContract.ABI} ABI
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ABI.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ABI message.
             * @function verify
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ABI.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.entrys != null && message.hasOwnProperty("entrys")) {
                    if (!Array.isArray(message.entrys))
                        return "entrys: array expected";
                    for (var i = 0; i < message.entrys.length; ++i) {
                        var error = $root.protocol.SmartContract.ABI.Entry.verify(message.entrys[i]);
                        if (error)
                            return "entrys." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ABI message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.SmartContract.ABI} ABI
             */
            ABI.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.SmartContract.ABI)
                    return object;
                var message = new $root.protocol.SmartContract.ABI();
                if (object.entrys) {
                    if (!Array.isArray(object.entrys))
                        throw TypeError(".protocol.SmartContract.ABI.entrys: array expected");
                    message.entrys = [];
                    for (var i = 0; i < object.entrys.length; ++i) {
                        if (typeof object.entrys[i] !== "object")
                            throw TypeError(".protocol.SmartContract.ABI.entrys: object expected");
                        message.entrys[i] = $root.protocol.SmartContract.ABI.Entry.fromObject(object.entrys[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ABI message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.SmartContract.ABI
             * @static
             * @param {protocol.SmartContract.ABI} message ABI
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ABI.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.entrys = [];
                if (message.entrys && message.entrys.length) {
                    object.entrys = [];
                    for (var j = 0; j < message.entrys.length; ++j)
                        object.entrys[j] = $root.protocol.SmartContract.ABI.Entry.toObject(message.entrys[j], options);
                }
                return object;
            };

            /**
             * Converts this ABI to JSON.
             * @function toJSON
             * @memberof protocol.SmartContract.ABI
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ABI.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ABI.Entry = (function() {

                /**
                 * Properties of an Entry.
                 * @memberof protocol.SmartContract.ABI
                 * @interface IEntry
                 * @property {boolean|null} [anonymous] Entry anonymous
                 * @property {boolean|null} [constant] Entry constant
                 * @property {string|null} [name] Entry name
                 * @property {Array.<protocol.SmartContract.ABI.Entry.IParam>|null} [inputs] Entry inputs
                 * @property {Array.<protocol.SmartContract.ABI.Entry.IParam>|null} [outputs] Entry outputs
                 * @property {protocol.SmartContract.ABI.Entry.EntryType|null} [type] Entry type
                 * @property {boolean|null} [payable] Entry payable
                 * @property {protocol.SmartContract.ABI.Entry.StateMutabilityType|null} [stateMutability] Entry stateMutability
                 */

                /**
                 * Constructs a new Entry.
                 * @memberof protocol.SmartContract.ABI
                 * @classdesc Represents an Entry.
                 * @implements IEntry
                 * @constructor
                 * @param {protocol.SmartContract.ABI.IEntry=} [properties] Properties to set
                 */
                function Entry(properties) {
                    this.inputs = [];
                    this.outputs = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Entry anonymous.
                 * @member {boolean} anonymous
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.anonymous = false;

                /**
                 * Entry constant.
                 * @member {boolean} constant
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.constant = false;

                /**
                 * Entry name.
                 * @member {string} name
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.name = "";

                /**
                 * Entry inputs.
                 * @member {Array.<protocol.SmartContract.ABI.Entry.IParam>} inputs
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.inputs = $util.emptyArray;

                /**
                 * Entry outputs.
                 * @member {Array.<protocol.SmartContract.ABI.Entry.IParam>} outputs
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.outputs = $util.emptyArray;

                /**
                 * Entry type.
                 * @member {protocol.SmartContract.ABI.Entry.EntryType} type
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.type = 0;

                /**
                 * Entry payable.
                 * @member {boolean} payable
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.payable = false;

                /**
                 * Entry stateMutability.
                 * @member {protocol.SmartContract.ABI.Entry.StateMutabilityType} stateMutability
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 */
                Entry.prototype.stateMutability = 0;

                /**
                 * Creates a new Entry instance using the specified properties.
                 * @function create
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.IEntry=} [properties] Properties to set
                 * @returns {protocol.SmartContract.ABI.Entry} Entry instance
                 */
                Entry.create = function create(properties) {
                    return new Entry(properties);
                };

                /**
                 * Encodes the specified Entry message. Does not implicitly {@link protocol.SmartContract.ABI.Entry.verify|verify} messages.
                 * @function encode
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.IEntry} message Entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Entry.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.anonymous);
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.constant);
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                    if (message.inputs != null && message.inputs.length)
                        for (var i = 0; i < message.inputs.length; ++i)
                            $root.protocol.SmartContract.ABI.Entry.Param.encode(message.inputs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.outputs != null && message.outputs.length)
                        for (var i = 0; i < message.outputs.length; ++i)
                            $root.protocol.SmartContract.ABI.Entry.Param.encode(message.outputs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.payable);
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.stateMutability);
                    return writer;
                };

                /**
                 * Encodes the specified Entry message, length delimited. Does not implicitly {@link protocol.SmartContract.ABI.Entry.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.IEntry} message Entry message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Entry.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Entry message from the specified reader or buffer.
                 * @function decode
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protocol.SmartContract.ABI.Entry} Entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Entry.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI.Entry();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.anonymous = reader.bool();
                            break;
                        case 2:
                            message.constant = reader.bool();
                            break;
                        case 3:
                            message.name = reader.string();
                            break;
                        case 4:
                            if (!(message.inputs && message.inputs.length))
                                message.inputs = [];
                            message.inputs.push($root.protocol.SmartContract.ABI.Entry.Param.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.outputs && message.outputs.length))
                                message.outputs = [];
                            message.outputs.push($root.protocol.SmartContract.ABI.Entry.Param.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.type = reader.int32();
                            break;
                        case 7:
                            message.payable = reader.bool();
                            break;
                        case 8:
                            message.stateMutability = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Entry message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protocol.SmartContract.ABI.Entry} Entry
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Entry.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Entry message.
                 * @function verify
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Entry.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        if (typeof message.anonymous !== "boolean")
                            return "anonymous: boolean expected";
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        if (typeof message.constant !== "boolean")
                            return "constant: boolean expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.inputs != null && message.hasOwnProperty("inputs")) {
                        if (!Array.isArray(message.inputs))
                            return "inputs: array expected";
                        for (var i = 0; i < message.inputs.length; ++i) {
                            var error = $root.protocol.SmartContract.ABI.Entry.Param.verify(message.inputs[i]);
                            if (error)
                                return "inputs." + error;
                        }
                    }
                    if (message.outputs != null && message.hasOwnProperty("outputs")) {
                        if (!Array.isArray(message.outputs))
                            return "outputs: array expected";
                        for (var i = 0; i < message.outputs.length; ++i) {
                            var error = $root.protocol.SmartContract.ABI.Entry.Param.verify(message.outputs[i]);
                            if (error)
                                return "outputs." + error;
                        }
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        if (typeof message.payable !== "boolean")
                            return "payable: boolean expected";
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        switch (message.stateMutability) {
                        default:
                            return "stateMutability: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protocol.SmartContract.ABI.Entry} Entry
                 */
                Entry.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.SmartContract.ABI.Entry)
                        return object;
                    var message = new $root.protocol.SmartContract.ABI.Entry();
                    if (object.anonymous != null)
                        message.anonymous = Boolean(object.anonymous);
                    if (object.constant != null)
                        message.constant = Boolean(object.constant);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.inputs) {
                        if (!Array.isArray(object.inputs))
                            throw TypeError(".protocol.SmartContract.ABI.Entry.inputs: array expected");
                        message.inputs = [];
                        for (var i = 0; i < object.inputs.length; ++i) {
                            if (typeof object.inputs[i] !== "object")
                                throw TypeError(".protocol.SmartContract.ABI.Entry.inputs: object expected");
                            message.inputs[i] = $root.protocol.SmartContract.ABI.Entry.Param.fromObject(object.inputs[i]);
                        }
                    }
                    if (object.outputs) {
                        if (!Array.isArray(object.outputs))
                            throw TypeError(".protocol.SmartContract.ABI.Entry.outputs: array expected");
                        message.outputs = [];
                        for (var i = 0; i < object.outputs.length; ++i) {
                            if (typeof object.outputs[i] !== "object")
                                throw TypeError(".protocol.SmartContract.ABI.Entry.outputs: object expected");
                            message.outputs[i] = $root.protocol.SmartContract.ABI.Entry.Param.fromObject(object.outputs[i]);
                        }
                    }
                    switch (object.type) {
                    case "UnknownEntryType":
                    case 0:
                        message.type = 0;
                        break;
                    case "Constructor":
                    case 1:
                        message.type = 1;
                        break;
                    case "Function":
                    case 2:
                        message.type = 2;
                        break;
                    case "Event":
                    case 3:
                        message.type = 3;
                        break;
                    case "Fallback":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.payable != null)
                        message.payable = Boolean(object.payable);
                    switch (object.stateMutability) {
                    case "UnknownMutabilityType":
                    case 0:
                        message.stateMutability = 0;
                        break;
                    case "Pure":
                    case 1:
                        message.stateMutability = 1;
                        break;
                    case "View":
                    case 2:
                        message.stateMutability = 2;
                        break;
                    case "Nonpayable":
                    case 3:
                        message.stateMutability = 3;
                        break;
                    case "Payable":
                    case 4:
                        message.stateMutability = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Entry message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @static
                 * @param {protocol.SmartContract.ABI.Entry} message Entry
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Entry.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.inputs = [];
                        object.outputs = [];
                    }
                    if (options.defaults) {
                        object.anonymous = false;
                        object.constant = false;
                        object.name = "";
                        object.type = options.enums === String ? "UnknownEntryType" : 0;
                        object.payable = false;
                        object.stateMutability = options.enums === String ? "UnknownMutabilityType" : 0;
                    }
                    if (message.anonymous != null && message.hasOwnProperty("anonymous"))
                        object.anonymous = message.anonymous;
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        object.constant = message.constant;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.inputs && message.inputs.length) {
                        object.inputs = [];
                        for (var j = 0; j < message.inputs.length; ++j)
                            object.inputs[j] = $root.protocol.SmartContract.ABI.Entry.Param.toObject(message.inputs[j], options);
                    }
                    if (message.outputs && message.outputs.length) {
                        object.outputs = [];
                        for (var j = 0; j < message.outputs.length; ++j)
                            object.outputs[j] = $root.protocol.SmartContract.ABI.Entry.Param.toObject(message.outputs[j], options);
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.protocol.SmartContract.ABI.Entry.EntryType[message.type] : message.type;
                    if (message.payable != null && message.hasOwnProperty("payable"))
                        object.payable = message.payable;
                    if (message.stateMutability != null && message.hasOwnProperty("stateMutability"))
                        object.stateMutability = options.enums === String ? $root.protocol.SmartContract.ABI.Entry.StateMutabilityType[message.stateMutability] : message.stateMutability;
                    return object;
                };

                /**
                 * Converts this Entry to JSON.
                 * @function toJSON
                 * @memberof protocol.SmartContract.ABI.Entry
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Entry.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * EntryType enum.
                 * @name protocol.SmartContract.ABI.Entry.EntryType
                 * @enum {string}
                 * @property {number} UnknownEntryType=0 UnknownEntryType value
                 * @property {number} Constructor=1 Constructor value
                 * @property {number} Function=2 Function value
                 * @property {number} Event=3 Event value
                 * @property {number} Fallback=4 Fallback value
                 */
                Entry.EntryType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UnknownEntryType"] = 0;
                    values[valuesById[1] = "Constructor"] = 1;
                    values[valuesById[2] = "Function"] = 2;
                    values[valuesById[3] = "Event"] = 3;
                    values[valuesById[4] = "Fallback"] = 4;
                    return values;
                })();

                Entry.Param = (function() {

                    /**
                     * Properties of a Param.
                     * @memberof protocol.SmartContract.ABI.Entry
                     * @interface IParam
                     * @property {boolean|null} [indexed] Param indexed
                     * @property {string|null} [name] Param name
                     * @property {string|null} [type] Param type
                     */

                    /**
                     * Constructs a new Param.
                     * @memberof protocol.SmartContract.ABI.Entry
                     * @classdesc Represents a Param.
                     * @implements IParam
                     * @constructor
                     * @param {protocol.SmartContract.ABI.Entry.IParam=} [properties] Properties to set
                     */
                    function Param(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Param indexed.
                     * @member {boolean} indexed
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     */
                    Param.prototype.indexed = false;

                    /**
                     * Param name.
                     * @member {string} name
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     */
                    Param.prototype.name = "";

                    /**
                     * Param type.
                     * @member {string} type
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     */
                    Param.prototype.type = "";

                    /**
                     * Creates a new Param instance using the specified properties.
                     * @function create
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.IParam=} [properties] Properties to set
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param instance
                     */
                    Param.create = function create(properties) {
                        return new Param(properties);
                    };

                    /**
                     * Encodes the specified Param message. Does not implicitly {@link protocol.SmartContract.ABI.Entry.Param.verify|verify} messages.
                     * @function encode
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.IParam} message Param message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Param.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.indexed);
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
                        return writer;
                    };

                    /**
                     * Encodes the specified Param message, length delimited. Does not implicitly {@link protocol.SmartContract.ABI.Entry.Param.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.IParam} message Param message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Param.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Param message from the specified reader or buffer.
                     * @function decode
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Param.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.SmartContract.ABI.Entry.Param();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.indexed = reader.bool();
                                break;
                            case 2:
                                message.name = reader.string();
                                break;
                            case 3:
                                message.type = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Param message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Param.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Param message.
                     * @function verify
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Param.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            if (typeof message.indexed !== "boolean")
                                return "indexed: boolean expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        return null;
                    };

                    /**
                     * Creates a Param message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {protocol.SmartContract.ABI.Entry.Param} Param
                     */
                    Param.fromObject = function fromObject(object) {
                        if (object instanceof $root.protocol.SmartContract.ABI.Entry.Param)
                            return object;
                        var message = new $root.protocol.SmartContract.ABI.Entry.Param();
                        if (object.indexed != null)
                            message.indexed = Boolean(object.indexed);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.type != null)
                            message.type = String(object.type);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Param message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @static
                     * @param {protocol.SmartContract.ABI.Entry.Param} message Param
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Param.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.indexed = false;
                            object.name = "";
                            object.type = "";
                        }
                        if (message.indexed != null && message.hasOwnProperty("indexed"))
                            object.indexed = message.indexed;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        return object;
                    };

                    /**
                     * Converts this Param to JSON.
                     * @function toJSON
                     * @memberof protocol.SmartContract.ABI.Entry.Param
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Param.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Param;
                })();

                /**
                 * StateMutabilityType enum.
                 * @name protocol.SmartContract.ABI.Entry.StateMutabilityType
                 * @enum {string}
                 * @property {number} UnknownMutabilityType=0 UnknownMutabilityType value
                 * @property {number} Pure=1 Pure value
                 * @property {number} View=2 View value
                 * @property {number} Nonpayable=3 Nonpayable value
                 * @property {number} Payable=4 Payable value
                 */
                Entry.StateMutabilityType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UnknownMutabilityType"] = 0;
                    values[valuesById[1] = "Pure"] = 1;
                    values[valuesById[2] = "View"] = 2;
                    values[valuesById[3] = "Nonpayable"] = 3;
                    values[valuesById[4] = "Payable"] = 4;
                    return values;
                })();

                return Entry;
            })();

            return ABI;
        })();

        return SmartContract;
    })();

    protocol.InternalTransaction = (function() {

        /**
         * Properties of an InternalTransaction.
         * @memberof protocol
         * @interface IInternalTransaction
         * @property {Uint8Array|null} [hash] InternalTransaction hash
         * @property {Uint8Array|null} [caller_address] InternalTransaction caller_address
         * @property {Uint8Array|null} [transferTo_address] InternalTransaction transferTo_address
         * @property {Array.<protocol.InternalTransaction.ICallValueInfo>|null} [callValueInfo] InternalTransaction callValueInfo
         * @property {Uint8Array|null} [note] InternalTransaction note
         * @property {boolean|null} [rejected] InternalTransaction rejected
         */

        /**
         * Constructs a new InternalTransaction.
         * @memberof protocol
         * @classdesc Represents an InternalTransaction.
         * @implements IInternalTransaction
         * @constructor
         * @param {protocol.IInternalTransaction=} [properties] Properties to set
         */
        function InternalTransaction(properties) {
            this.callValueInfo = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InternalTransaction hash.
         * @member {Uint8Array} hash
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.hash = $util.newBuffer([]);

        /**
         * InternalTransaction caller_address.
         * @member {Uint8Array} caller_address
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.caller_address = $util.newBuffer([]);

        /**
         * InternalTransaction transferTo_address.
         * @member {Uint8Array} transferTo_address
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.transferTo_address = $util.newBuffer([]);

        /**
         * InternalTransaction callValueInfo.
         * @member {Array.<protocol.InternalTransaction.ICallValueInfo>} callValueInfo
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.callValueInfo = $util.emptyArray;

        /**
         * InternalTransaction note.
         * @member {Uint8Array} note
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.note = $util.newBuffer([]);

        /**
         * InternalTransaction rejected.
         * @member {boolean} rejected
         * @memberof protocol.InternalTransaction
         * @instance
         */
        InternalTransaction.prototype.rejected = false;

        /**
         * Creates a new InternalTransaction instance using the specified properties.
         * @function create
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.IInternalTransaction=} [properties] Properties to set
         * @returns {protocol.InternalTransaction} InternalTransaction instance
         */
        InternalTransaction.create = function create(properties) {
            return new InternalTransaction(properties);
        };

        /**
         * Encodes the specified InternalTransaction message. Does not implicitly {@link protocol.InternalTransaction.verify|verify} messages.
         * @function encode
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.IInternalTransaction} message InternalTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalTransaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hash != null && message.hasOwnProperty("hash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);
            if (message.caller_address != null && message.hasOwnProperty("caller_address"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.caller_address);
            if (message.transferTo_address != null && message.hasOwnProperty("transferTo_address"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.transferTo_address);
            if (message.callValueInfo != null && message.callValueInfo.length)
                for (var i = 0; i < message.callValueInfo.length; ++i)
                    $root.protocol.InternalTransaction.CallValueInfo.encode(message.callValueInfo[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.note != null && message.hasOwnProperty("note"))
                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.note);
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.rejected);
            return writer;
        };

        /**
         * Encodes the specified InternalTransaction message, length delimited. Does not implicitly {@link protocol.InternalTransaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.IInternalTransaction} message InternalTransaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InternalTransaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InternalTransaction message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.InternalTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.InternalTransaction} InternalTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalTransaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.InternalTransaction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hash = reader.bytes();
                    break;
                case 2:
                    message.caller_address = reader.bytes();
                    break;
                case 3:
                    message.transferTo_address = reader.bytes();
                    break;
                case 4:
                    if (!(message.callValueInfo && message.callValueInfo.length))
                        message.callValueInfo = [];
                    message.callValueInfo.push($root.protocol.InternalTransaction.CallValueInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.note = reader.bytes();
                    break;
                case 6:
                    message.rejected = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InternalTransaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.InternalTransaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.InternalTransaction} InternalTransaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InternalTransaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InternalTransaction message.
         * @function verify
         * @memberof protocol.InternalTransaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InternalTransaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hash != null && message.hasOwnProperty("hash"))
                if (!(message.hash && typeof message.hash.length === "number" || $util.isString(message.hash)))
                    return "hash: buffer expected";
            if (message.caller_address != null && message.hasOwnProperty("caller_address"))
                if (!(message.caller_address && typeof message.caller_address.length === "number" || $util.isString(message.caller_address)))
                    return "caller_address: buffer expected";
            if (message.transferTo_address != null && message.hasOwnProperty("transferTo_address"))
                if (!(message.transferTo_address && typeof message.transferTo_address.length === "number" || $util.isString(message.transferTo_address)))
                    return "transferTo_address: buffer expected";
            if (message.callValueInfo != null && message.hasOwnProperty("callValueInfo")) {
                if (!Array.isArray(message.callValueInfo))
                    return "callValueInfo: array expected";
                for (var i = 0; i < message.callValueInfo.length; ++i) {
                    var error = $root.protocol.InternalTransaction.CallValueInfo.verify(message.callValueInfo[i]);
                    if (error)
                        return "callValueInfo." + error;
                }
            }
            if (message.note != null && message.hasOwnProperty("note"))
                if (!(message.note && typeof message.note.length === "number" || $util.isString(message.note)))
                    return "note: buffer expected";
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                if (typeof message.rejected !== "boolean")
                    return "rejected: boolean expected";
            return null;
        };

        /**
         * Creates an InternalTransaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.InternalTransaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.InternalTransaction} InternalTransaction
         */
        InternalTransaction.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.InternalTransaction)
                return object;
            var message = new $root.protocol.InternalTransaction();
            if (object.hash != null)
                if (typeof object.hash === "string")
                    $util.base64.decode(object.hash, message.hash = $util.newBuffer($util.base64.length(object.hash)), 0);
                else if (object.hash.length)
                    message.hash = object.hash;
            if (object.caller_address != null)
                if (typeof object.caller_address === "string")
                    $util.base64.decode(object.caller_address, message.caller_address = $util.newBuffer($util.base64.length(object.caller_address)), 0);
                else if (object.caller_address.length)
                    message.caller_address = object.caller_address;
            if (object.transferTo_address != null)
                if (typeof object.transferTo_address === "string")
                    $util.base64.decode(object.transferTo_address, message.transferTo_address = $util.newBuffer($util.base64.length(object.transferTo_address)), 0);
                else if (object.transferTo_address.length)
                    message.transferTo_address = object.transferTo_address;
            if (object.callValueInfo) {
                if (!Array.isArray(object.callValueInfo))
                    throw TypeError(".protocol.InternalTransaction.callValueInfo: array expected");
                message.callValueInfo = [];
                for (var i = 0; i < object.callValueInfo.length; ++i) {
                    if (typeof object.callValueInfo[i] !== "object")
                        throw TypeError(".protocol.InternalTransaction.callValueInfo: object expected");
                    message.callValueInfo[i] = $root.protocol.InternalTransaction.CallValueInfo.fromObject(object.callValueInfo[i]);
                }
            }
            if (object.note != null)
                if (typeof object.note === "string")
                    $util.base64.decode(object.note, message.note = $util.newBuffer($util.base64.length(object.note)), 0);
                else if (object.note.length)
                    message.note = object.note;
            if (object.rejected != null)
                message.rejected = Boolean(object.rejected);
            return message;
        };

        /**
         * Creates a plain object from an InternalTransaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.InternalTransaction
         * @static
         * @param {protocol.InternalTransaction} message InternalTransaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InternalTransaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.callValueInfo = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.hash = "";
                else {
                    object.hash = [];
                    if (options.bytes !== Array)
                        object.hash = $util.newBuffer(object.hash);
                }
                if (options.bytes === String)
                    object.caller_address = "";
                else {
                    object.caller_address = [];
                    if (options.bytes !== Array)
                        object.caller_address = $util.newBuffer(object.caller_address);
                }
                if (options.bytes === String)
                    object.transferTo_address = "";
                else {
                    object.transferTo_address = [];
                    if (options.bytes !== Array)
                        object.transferTo_address = $util.newBuffer(object.transferTo_address);
                }
                if (options.bytes === String)
                    object.note = "";
                else {
                    object.note = [];
                    if (options.bytes !== Array)
                        object.note = $util.newBuffer(object.note);
                }
                object.rejected = false;
            }
            if (message.hash != null && message.hasOwnProperty("hash"))
                object.hash = options.bytes === String ? $util.base64.encode(message.hash, 0, message.hash.length) : options.bytes === Array ? Array.prototype.slice.call(message.hash) : message.hash;
            if (message.caller_address != null && message.hasOwnProperty("caller_address"))
                object.caller_address = options.bytes === String ? $util.base64.encode(message.caller_address, 0, message.caller_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.caller_address) : message.caller_address;
            if (message.transferTo_address != null && message.hasOwnProperty("transferTo_address"))
                object.transferTo_address = options.bytes === String ? $util.base64.encode(message.transferTo_address, 0, message.transferTo_address.length) : options.bytes === Array ? Array.prototype.slice.call(message.transferTo_address) : message.transferTo_address;
            if (message.callValueInfo && message.callValueInfo.length) {
                object.callValueInfo = [];
                for (var j = 0; j < message.callValueInfo.length; ++j)
                    object.callValueInfo[j] = $root.protocol.InternalTransaction.CallValueInfo.toObject(message.callValueInfo[j], options);
            }
            if (message.note != null && message.hasOwnProperty("note"))
                object.note = options.bytes === String ? $util.base64.encode(message.note, 0, message.note.length) : options.bytes === Array ? Array.prototype.slice.call(message.note) : message.note;
            if (message.rejected != null && message.hasOwnProperty("rejected"))
                object.rejected = message.rejected;
            return object;
        };

        /**
         * Converts this InternalTransaction to JSON.
         * @function toJSON
         * @memberof protocol.InternalTransaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InternalTransaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        InternalTransaction.CallValueInfo = (function() {

            /**
             * Properties of a CallValueInfo.
             * @memberof protocol.InternalTransaction
             * @interface ICallValueInfo
             * @property {number|Long|null} [callValue] CallValueInfo callValue
             * @property {string|null} [tokenId] CallValueInfo tokenId
             */

            /**
             * Constructs a new CallValueInfo.
             * @memberof protocol.InternalTransaction
             * @classdesc Represents a CallValueInfo.
             * @implements ICallValueInfo
             * @constructor
             * @param {protocol.InternalTransaction.ICallValueInfo=} [properties] Properties to set
             */
            function CallValueInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CallValueInfo callValue.
             * @member {number|Long} callValue
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @instance
             */
            CallValueInfo.prototype.callValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * CallValueInfo tokenId.
             * @member {string} tokenId
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @instance
             */
            CallValueInfo.prototype.tokenId = "";

            /**
             * Creates a new CallValueInfo instance using the specified properties.
             * @function create
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.ICallValueInfo=} [properties] Properties to set
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo instance
             */
            CallValueInfo.create = function create(properties) {
                return new CallValueInfo(properties);
            };

            /**
             * Encodes the specified CallValueInfo message. Does not implicitly {@link protocol.InternalTransaction.CallValueInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.ICallValueInfo} message CallValueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallValueInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.callValue);
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.tokenId);
                return writer;
            };

            /**
             * Encodes the specified CallValueInfo message, length delimited. Does not implicitly {@link protocol.InternalTransaction.CallValueInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.ICallValueInfo} message CallValueInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CallValueInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CallValueInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallValueInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.InternalTransaction.CallValueInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.callValue = reader.int64();
                        break;
                    case 2:
                        message.tokenId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CallValueInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CallValueInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CallValueInfo message.
             * @function verify
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CallValueInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    if (!$util.isInteger(message.callValue) && !(message.callValue && $util.isInteger(message.callValue.low) && $util.isInteger(message.callValue.high)))
                        return "callValue: integer|Long expected";
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    if (!$util.isString(message.tokenId))
                        return "tokenId: string expected";
                return null;
            };

            /**
             * Creates a CallValueInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.InternalTransaction.CallValueInfo} CallValueInfo
             */
            CallValueInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.InternalTransaction.CallValueInfo)
                    return object;
                var message = new $root.protocol.InternalTransaction.CallValueInfo();
                if (object.callValue != null)
                    if ($util.Long)
                        (message.callValue = $util.Long.fromValue(object.callValue)).unsigned = false;
                    else if (typeof object.callValue === "string")
                        message.callValue = parseInt(object.callValue, 10);
                    else if (typeof object.callValue === "number")
                        message.callValue = object.callValue;
                    else if (typeof object.callValue === "object")
                        message.callValue = new $util.LongBits(object.callValue.low >>> 0, object.callValue.high >>> 0).toNumber();
                if (object.tokenId != null)
                    message.tokenId = String(object.tokenId);
                return message;
            };

            /**
             * Creates a plain object from a CallValueInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @static
             * @param {protocol.InternalTransaction.CallValueInfo} message CallValueInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CallValueInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.callValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.callValue = options.longs === String ? "0" : 0;
                    object.tokenId = "";
                }
                if (message.callValue != null && message.hasOwnProperty("callValue"))
                    if (typeof message.callValue === "number")
                        object.callValue = options.longs === String ? String(message.callValue) : message.callValue;
                    else
                        object.callValue = options.longs === String ? $util.Long.prototype.toString.call(message.callValue) : options.longs === Number ? new $util.LongBits(message.callValue.low >>> 0, message.callValue.high >>> 0).toNumber() : message.callValue;
                if (message.tokenId != null && message.hasOwnProperty("tokenId"))
                    object.tokenId = message.tokenId;
                return object;
            };

            /**
             * Converts this CallValueInfo to JSON.
             * @function toJSON
             * @memberof protocol.InternalTransaction.CallValueInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CallValueInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CallValueInfo;
        })();

        return InternalTransaction;
    })();

    protocol.DelegatedResourceAccountIndex = (function() {

        /**
         * Properties of a DelegatedResourceAccountIndex.
         * @memberof protocol
         * @interface IDelegatedResourceAccountIndex
         * @property {Uint8Array|null} [account] DelegatedResourceAccountIndex account
         * @property {Array.<Uint8Array>|null} [fromAccounts] DelegatedResourceAccountIndex fromAccounts
         * @property {Array.<Uint8Array>|null} [toAccounts] DelegatedResourceAccountIndex toAccounts
         */

        /**
         * Constructs a new DelegatedResourceAccountIndex.
         * @memberof protocol
         * @classdesc Represents a DelegatedResourceAccountIndex.
         * @implements IDelegatedResourceAccountIndex
         * @constructor
         * @param {protocol.IDelegatedResourceAccountIndex=} [properties] Properties to set
         */
        function DelegatedResourceAccountIndex(properties) {
            this.fromAccounts = [];
            this.toAccounts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelegatedResourceAccountIndex account.
         * @member {Uint8Array} account
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         */
        DelegatedResourceAccountIndex.prototype.account = $util.newBuffer([]);

        /**
         * DelegatedResourceAccountIndex fromAccounts.
         * @member {Array.<Uint8Array>} fromAccounts
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         */
        DelegatedResourceAccountIndex.prototype.fromAccounts = $util.emptyArray;

        /**
         * DelegatedResourceAccountIndex toAccounts.
         * @member {Array.<Uint8Array>} toAccounts
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         */
        DelegatedResourceAccountIndex.prototype.toAccounts = $util.emptyArray;

        /**
         * Creates a new DelegatedResourceAccountIndex instance using the specified properties.
         * @function create
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.IDelegatedResourceAccountIndex=} [properties] Properties to set
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex instance
         */
        DelegatedResourceAccountIndex.create = function create(properties) {
            return new DelegatedResourceAccountIndex(properties);
        };

        /**
         * Encodes the specified DelegatedResourceAccountIndex message. Does not implicitly {@link protocol.DelegatedResourceAccountIndex.verify|verify} messages.
         * @function encode
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.IDelegatedResourceAccountIndex} message DelegatedResourceAccountIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResourceAccountIndex.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.account);
            if (message.fromAccounts != null && message.fromAccounts.length)
                for (var i = 0; i < message.fromAccounts.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.fromAccounts[i]);
            if (message.toAccounts != null && message.toAccounts.length)
                for (var i = 0; i < message.toAccounts.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.toAccounts[i]);
            return writer;
        };

        /**
         * Encodes the specified DelegatedResourceAccountIndex message, length delimited. Does not implicitly {@link protocol.DelegatedResourceAccountIndex.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.IDelegatedResourceAccountIndex} message DelegatedResourceAccountIndex message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelegatedResourceAccountIndex.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelegatedResourceAccountIndex message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResourceAccountIndex.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.DelegatedResourceAccountIndex();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.bytes();
                    break;
                case 2:
                    if (!(message.fromAccounts && message.fromAccounts.length))
                        message.fromAccounts = [];
                    message.fromAccounts.push(reader.bytes());
                    break;
                case 3:
                    if (!(message.toAccounts && message.toAccounts.length))
                        message.toAccounts = [];
                    message.toAccounts.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelegatedResourceAccountIndex message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelegatedResourceAccountIndex.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelegatedResourceAccountIndex message.
         * @function verify
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelegatedResourceAccountIndex.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!(message.account && typeof message.account.length === "number" || $util.isString(message.account)))
                    return "account: buffer expected";
            if (message.fromAccounts != null && message.hasOwnProperty("fromAccounts")) {
                if (!Array.isArray(message.fromAccounts))
                    return "fromAccounts: array expected";
                for (var i = 0; i < message.fromAccounts.length; ++i)
                    if (!(message.fromAccounts[i] && typeof message.fromAccounts[i].length === "number" || $util.isString(message.fromAccounts[i])))
                        return "fromAccounts: buffer[] expected";
            }
            if (message.toAccounts != null && message.hasOwnProperty("toAccounts")) {
                if (!Array.isArray(message.toAccounts))
                    return "toAccounts: array expected";
                for (var i = 0; i < message.toAccounts.length; ++i)
                    if (!(message.toAccounts[i] && typeof message.toAccounts[i].length === "number" || $util.isString(message.toAccounts[i])))
                        return "toAccounts: buffer[] expected";
            }
            return null;
        };

        /**
         * Creates a DelegatedResourceAccountIndex message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.DelegatedResourceAccountIndex} DelegatedResourceAccountIndex
         */
        DelegatedResourceAccountIndex.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.DelegatedResourceAccountIndex)
                return object;
            var message = new $root.protocol.DelegatedResourceAccountIndex();
            if (object.account != null)
                if (typeof object.account === "string")
                    $util.base64.decode(object.account, message.account = $util.newBuffer($util.base64.length(object.account)), 0);
                else if (object.account.length)
                    message.account = object.account;
            if (object.fromAccounts) {
                if (!Array.isArray(object.fromAccounts))
                    throw TypeError(".protocol.DelegatedResourceAccountIndex.fromAccounts: array expected");
                message.fromAccounts = [];
                for (var i = 0; i < object.fromAccounts.length; ++i)
                    if (typeof object.fromAccounts[i] === "string")
                        $util.base64.decode(object.fromAccounts[i], message.fromAccounts[i] = $util.newBuffer($util.base64.length(object.fromAccounts[i])), 0);
                    else if (object.fromAccounts[i].length)
                        message.fromAccounts[i] = object.fromAccounts[i];
            }
            if (object.toAccounts) {
                if (!Array.isArray(object.toAccounts))
                    throw TypeError(".protocol.DelegatedResourceAccountIndex.toAccounts: array expected");
                message.toAccounts = [];
                for (var i = 0; i < object.toAccounts.length; ++i)
                    if (typeof object.toAccounts[i] === "string")
                        $util.base64.decode(object.toAccounts[i], message.toAccounts[i] = $util.newBuffer($util.base64.length(object.toAccounts[i])), 0);
                    else if (object.toAccounts[i].length)
                        message.toAccounts[i] = object.toAccounts[i];
            }
            return message;
        };

        /**
         * Creates a plain object from a DelegatedResourceAccountIndex message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.DelegatedResourceAccountIndex
         * @static
         * @param {protocol.DelegatedResourceAccountIndex} message DelegatedResourceAccountIndex
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DelegatedResourceAccountIndex.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.fromAccounts = [];
                object.toAccounts = [];
            }
            if (options.defaults)
                if (options.bytes === String)
                    object.account = "";
                else {
                    object.account = [];
                    if (options.bytes !== Array)
                        object.account = $util.newBuffer(object.account);
                }
            if (message.account != null && message.hasOwnProperty("account"))
                object.account = options.bytes === String ? $util.base64.encode(message.account, 0, message.account.length) : options.bytes === Array ? Array.prototype.slice.call(message.account) : message.account;
            if (message.fromAccounts && message.fromAccounts.length) {
                object.fromAccounts = [];
                for (var j = 0; j < message.fromAccounts.length; ++j)
                    object.fromAccounts[j] = options.bytes === String ? $util.base64.encode(message.fromAccounts[j], 0, message.fromAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAccounts[j]) : message.fromAccounts[j];
            }
            if (message.toAccounts && message.toAccounts.length) {
                object.toAccounts = [];
                for (var j = 0; j < message.toAccounts.length; ++j)
                    object.toAccounts[j] = options.bytes === String ? $util.base64.encode(message.toAccounts[j], 0, message.toAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.toAccounts[j]) : message.toAccounts[j];
            }
            return object;
        };

        /**
         * Converts this DelegatedResourceAccountIndex to JSON.
         * @function toJSON
         * @memberof protocol.DelegatedResourceAccountIndex
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DelegatedResourceAccountIndex.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DelegatedResourceAccountIndex;
    })();

    protocol.NodeInfo = (function() {

        /**
         * Properties of a NodeInfo.
         * @memberof protocol
         * @interface INodeInfo
         * @property {number|Long|null} [beginSyncNum] NodeInfo beginSyncNum
         * @property {string|null} [block] NodeInfo block
         * @property {string|null} [solidityBlock] NodeInfo solidityBlock
         * @property {number|null} [currentConnectCount] NodeInfo currentConnectCount
         * @property {number|null} [activeConnectCount] NodeInfo activeConnectCount
         * @property {number|null} [passiveConnectCount] NodeInfo passiveConnectCount
         * @property {number|Long|null} [totalFlow] NodeInfo totalFlow
         * @property {Array.<protocol.NodeInfo.IPeerInfo>|null} [peerInfoList] NodeInfo peerInfoList
         * @property {protocol.NodeInfo.IConfigNodeInfo|null} [configNodeInfo] NodeInfo configNodeInfo
         * @property {protocol.NodeInfo.IMachineInfo|null} [machineInfo] NodeInfo machineInfo
         * @property {Object.<string,string>|null} [cheatWitnessInfoMap] NodeInfo cheatWitnessInfoMap
         */

        /**
         * Constructs a new NodeInfo.
         * @memberof protocol
         * @classdesc Represents a NodeInfo.
         * @implements INodeInfo
         * @constructor
         * @param {protocol.INodeInfo=} [properties] Properties to set
         */
        function NodeInfo(properties) {
            this.peerInfoList = [];
            this.cheatWitnessInfoMap = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeInfo beginSyncNum.
         * @member {number|Long} beginSyncNum
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.beginSyncNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeInfo block.
         * @member {string} block
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.block = "";

        /**
         * NodeInfo solidityBlock.
         * @member {string} solidityBlock
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.solidityBlock = "";

        /**
         * NodeInfo currentConnectCount.
         * @member {number} currentConnectCount
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.currentConnectCount = 0;

        /**
         * NodeInfo activeConnectCount.
         * @member {number} activeConnectCount
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.activeConnectCount = 0;

        /**
         * NodeInfo passiveConnectCount.
         * @member {number} passiveConnectCount
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.passiveConnectCount = 0;

        /**
         * NodeInfo totalFlow.
         * @member {number|Long} totalFlow
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.totalFlow = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NodeInfo peerInfoList.
         * @member {Array.<protocol.NodeInfo.IPeerInfo>} peerInfoList
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.peerInfoList = $util.emptyArray;

        /**
         * NodeInfo configNodeInfo.
         * @member {protocol.NodeInfo.IConfigNodeInfo|null|undefined} configNodeInfo
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.configNodeInfo = null;

        /**
         * NodeInfo machineInfo.
         * @member {protocol.NodeInfo.IMachineInfo|null|undefined} machineInfo
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.machineInfo = null;

        /**
         * NodeInfo cheatWitnessInfoMap.
         * @member {Object.<string,string>} cheatWitnessInfoMap
         * @memberof protocol.NodeInfo
         * @instance
         */
        NodeInfo.prototype.cheatWitnessInfoMap = $util.emptyObject;

        /**
         * Creates a new NodeInfo instance using the specified properties.
         * @function create
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.INodeInfo=} [properties] Properties to set
         * @returns {protocol.NodeInfo} NodeInfo instance
         */
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };

        /**
         * Encodes the specified NodeInfo message. Does not implicitly {@link protocol.NodeInfo.verify|verify} messages.
         * @function encode
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.beginSyncNum);
            if (message.block != null && message.hasOwnProperty("block"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.block);
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.solidityBlock);
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.currentConnectCount);
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.activeConnectCount);
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.passiveConnectCount);
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.totalFlow);
            if (message.peerInfoList != null && message.peerInfoList.length)
                for (var i = 0; i < message.peerInfoList.length; ++i)
                    $root.protocol.NodeInfo.PeerInfo.encode(message.peerInfoList[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo"))
                $root.protocol.NodeInfo.ConfigNodeInfo.encode(message.configNodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo"))
                $root.protocol.NodeInfo.MachineInfo.encode(message.machineInfo, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.cheatWitnessInfoMap != null && message.hasOwnProperty("cheatWitnessInfoMap"))
                for (var keys = Object.keys(message.cheatWitnessInfoMap), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.cheatWitnessInfoMap[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof protocol.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {protocol.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.beginSyncNum = reader.int64();
                    break;
                case 2:
                    message.block = reader.string();
                    break;
                case 3:
                    message.solidityBlock = reader.string();
                    break;
                case 4:
                    message.currentConnectCount = reader.int32();
                    break;
                case 5:
                    message.activeConnectCount = reader.int32();
                    break;
                case 6:
                    message.passiveConnectCount = reader.int32();
                    break;
                case 7:
                    message.totalFlow = reader.int64();
                    break;
                case 8:
                    if (!(message.peerInfoList && message.peerInfoList.length))
                        message.peerInfoList = [];
                    message.peerInfoList.push($root.protocol.NodeInfo.PeerInfo.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.machineInfo = $root.protocol.NodeInfo.MachineInfo.decode(reader, reader.uint32());
                    break;
                case 11:
                    reader.skip().pos++;
                    if (message.cheatWitnessInfoMap === $util.emptyObject)
                        message.cheatWitnessInfoMap = {};
                    key = reader.string();
                    reader.pos++;
                    message.cheatWitnessInfoMap[key] = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof protocol.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {protocol.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfo message.
         * @function verify
         * @memberof protocol.NodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                if (!$util.isInteger(message.beginSyncNum) && !(message.beginSyncNum && $util.isInteger(message.beginSyncNum.low) && $util.isInteger(message.beginSyncNum.high)))
                    return "beginSyncNum: integer|Long expected";
            if (message.block != null && message.hasOwnProperty("block"))
                if (!$util.isString(message.block))
                    return "block: string expected";
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                if (!$util.isString(message.solidityBlock))
                    return "solidityBlock: string expected";
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                if (!$util.isInteger(message.currentConnectCount))
                    return "currentConnectCount: integer expected";
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                if (!$util.isInteger(message.activeConnectCount))
                    return "activeConnectCount: integer expected";
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                if (!$util.isInteger(message.passiveConnectCount))
                    return "passiveConnectCount: integer expected";
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                if (!$util.isInteger(message.totalFlow) && !(message.totalFlow && $util.isInteger(message.totalFlow.low) && $util.isInteger(message.totalFlow.high)))
                    return "totalFlow: integer|Long expected";
            if (message.peerInfoList != null && message.hasOwnProperty("peerInfoList")) {
                if (!Array.isArray(message.peerInfoList))
                    return "peerInfoList: array expected";
                for (var i = 0; i < message.peerInfoList.length; ++i) {
                    var error = $root.protocol.NodeInfo.PeerInfo.verify(message.peerInfoList[i]);
                    if (error)
                        return "peerInfoList." + error;
                }
            }
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo")) {
                var error = $root.protocol.NodeInfo.ConfigNodeInfo.verify(message.configNodeInfo);
                if (error)
                    return "configNodeInfo." + error;
            }
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo")) {
                var error = $root.protocol.NodeInfo.MachineInfo.verify(message.machineInfo);
                if (error)
                    return "machineInfo." + error;
            }
            if (message.cheatWitnessInfoMap != null && message.hasOwnProperty("cheatWitnessInfoMap")) {
                if (!$util.isObject(message.cheatWitnessInfoMap))
                    return "cheatWitnessInfoMap: object expected";
                var key = Object.keys(message.cheatWitnessInfoMap);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.cheatWitnessInfoMap[key[i]]))
                        return "cheatWitnessInfoMap: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a NodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof protocol.NodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {protocol.NodeInfo} NodeInfo
         */
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.protocol.NodeInfo)
                return object;
            var message = new $root.protocol.NodeInfo();
            if (object.beginSyncNum != null)
                if ($util.Long)
                    (message.beginSyncNum = $util.Long.fromValue(object.beginSyncNum)).unsigned = false;
                else if (typeof object.beginSyncNum === "string")
                    message.beginSyncNum = parseInt(object.beginSyncNum, 10);
                else if (typeof object.beginSyncNum === "number")
                    message.beginSyncNum = object.beginSyncNum;
                else if (typeof object.beginSyncNum === "object")
                    message.beginSyncNum = new $util.LongBits(object.beginSyncNum.low >>> 0, object.beginSyncNum.high >>> 0).toNumber();
            if (object.block != null)
                message.block = String(object.block);
            if (object.solidityBlock != null)
                message.solidityBlock = String(object.solidityBlock);
            if (object.currentConnectCount != null)
                message.currentConnectCount = object.currentConnectCount | 0;
            if (object.activeConnectCount != null)
                message.activeConnectCount = object.activeConnectCount | 0;
            if (object.passiveConnectCount != null)
                message.passiveConnectCount = object.passiveConnectCount | 0;
            if (object.totalFlow != null)
                if ($util.Long)
                    (message.totalFlow = $util.Long.fromValue(object.totalFlow)).unsigned = false;
                else if (typeof object.totalFlow === "string")
                    message.totalFlow = parseInt(object.totalFlow, 10);
                else if (typeof object.totalFlow === "number")
                    message.totalFlow = object.totalFlow;
                else if (typeof object.totalFlow === "object")
                    message.totalFlow = new $util.LongBits(object.totalFlow.low >>> 0, object.totalFlow.high >>> 0).toNumber();
            if (object.peerInfoList) {
                if (!Array.isArray(object.peerInfoList))
                    throw TypeError(".protocol.NodeInfo.peerInfoList: array expected");
                message.peerInfoList = [];
                for (var i = 0; i < object.peerInfoList.length; ++i) {
                    if (typeof object.peerInfoList[i] !== "object")
                        throw TypeError(".protocol.NodeInfo.peerInfoList: object expected");
                    message.peerInfoList[i] = $root.protocol.NodeInfo.PeerInfo.fromObject(object.peerInfoList[i]);
                }
            }
            if (object.configNodeInfo != null) {
                if (typeof object.configNodeInfo !== "object")
                    throw TypeError(".protocol.NodeInfo.configNodeInfo: object expected");
                message.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.fromObject(object.configNodeInfo);
            }
            if (object.machineInfo != null) {
                if (typeof object.machineInfo !== "object")
                    throw TypeError(".protocol.NodeInfo.machineInfo: object expected");
                message.machineInfo = $root.protocol.NodeInfo.MachineInfo.fromObject(object.machineInfo);
            }
            if (object.cheatWitnessInfoMap) {
                if (typeof object.cheatWitnessInfoMap !== "object")
                    throw TypeError(".protocol.NodeInfo.cheatWitnessInfoMap: object expected");
                message.cheatWitnessInfoMap = {};
                for (var keys = Object.keys(object.cheatWitnessInfoMap), i = 0; i < keys.length; ++i)
                    message.cheatWitnessInfoMap[keys[i]] = String(object.cheatWitnessInfoMap[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof protocol.NodeInfo
         * @static
         * @param {protocol.NodeInfo} message NodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.peerInfoList = [];
            if (options.objects || options.defaults)
                object.cheatWitnessInfoMap = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.beginSyncNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.beginSyncNum = options.longs === String ? "0" : 0;
                object.block = "";
                object.solidityBlock = "";
                object.currentConnectCount = 0;
                object.activeConnectCount = 0;
                object.passiveConnectCount = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalFlow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFlow = options.longs === String ? "0" : 0;
                object.configNodeInfo = null;
                object.machineInfo = null;
            }
            if (message.beginSyncNum != null && message.hasOwnProperty("beginSyncNum"))
                if (typeof message.beginSyncNum === "number")
                    object.beginSyncNum = options.longs === String ? String(message.beginSyncNum) : message.beginSyncNum;
                else
                    object.beginSyncNum = options.longs === String ? $util.Long.prototype.toString.call(message.beginSyncNum) : options.longs === Number ? new $util.LongBits(message.beginSyncNum.low >>> 0, message.beginSyncNum.high >>> 0).toNumber() : message.beginSyncNum;
            if (message.block != null && message.hasOwnProperty("block"))
                object.block = message.block;
            if (message.solidityBlock != null && message.hasOwnProperty("solidityBlock"))
                object.solidityBlock = message.solidityBlock;
            if (message.currentConnectCount != null && message.hasOwnProperty("currentConnectCount"))
                object.currentConnectCount = message.currentConnectCount;
            if (message.activeConnectCount != null && message.hasOwnProperty("activeConnectCount"))
                object.activeConnectCount = message.activeConnectCount;
            if (message.passiveConnectCount != null && message.hasOwnProperty("passiveConnectCount"))
                object.passiveConnectCount = message.passiveConnectCount;
            if (message.totalFlow != null && message.hasOwnProperty("totalFlow"))
                if (typeof message.totalFlow === "number")
                    object.totalFlow = options.longs === String ? String(message.totalFlow) : message.totalFlow;
                else
                    object.totalFlow = options.longs === String ? $util.Long.prototype.toString.call(message.totalFlow) : options.longs === Number ? new $util.LongBits(message.totalFlow.low >>> 0, message.totalFlow.high >>> 0).toNumber() : message.totalFlow;
            if (message.peerInfoList && message.peerInfoList.length) {
                object.peerInfoList = [];
                for (var j = 0; j < message.peerInfoList.length; ++j)
                    object.peerInfoList[j] = $root.protocol.NodeInfo.PeerInfo.toObject(message.peerInfoList[j], options);
            }
            if (message.configNodeInfo != null && message.hasOwnProperty("configNodeInfo"))
                object.configNodeInfo = $root.protocol.NodeInfo.ConfigNodeInfo.toObject(message.configNodeInfo, options);
            if (message.machineInfo != null && message.hasOwnProperty("machineInfo"))
                object.machineInfo = $root.protocol.NodeInfo.MachineInfo.toObject(message.machineInfo, options);
            var keys2;
            if (message.cheatWitnessInfoMap && (keys2 = Object.keys(message.cheatWitnessInfoMap)).length) {
                object.cheatWitnessInfoMap = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.cheatWitnessInfoMap[keys2[j]] = message.cheatWitnessInfoMap[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this NodeInfo to JSON.
         * @function toJSON
         * @memberof protocol.NodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        NodeInfo.PeerInfo = (function() {

            /**
             * Properties of a PeerInfo.
             * @memberof protocol.NodeInfo
             * @interface IPeerInfo
             * @property {string|null} [lastSyncBlock] PeerInfo lastSyncBlock
             * @property {number|Long|null} [remainNum] PeerInfo remainNum
             * @property {number|Long|null} [lastBlockUpdateTime] PeerInfo lastBlockUpdateTime
             * @property {boolean|null} [syncFlag] PeerInfo syncFlag
             * @property {number|Long|null} [headBlockTimeWeBothHave] PeerInfo headBlockTimeWeBothHave
             * @property {boolean|null} [needSyncFromPeer] PeerInfo needSyncFromPeer
             * @property {boolean|null} [needSyncFromUs] PeerInfo needSyncFromUs
             * @property {string|null} [host] PeerInfo host
             * @property {number|null} [port] PeerInfo port
             * @property {string|null} [nodeId] PeerInfo nodeId
             * @property {number|Long|null} [connectTime] PeerInfo connectTime
             * @property {number|null} [avgLatency] PeerInfo avgLatency
             * @property {number|null} [syncToFetchSize] PeerInfo syncToFetchSize
             * @property {number|Long|null} [syncToFetchSizePeekNum] PeerInfo syncToFetchSizePeekNum
             * @property {number|null} [syncBlockRequestedSize] PeerInfo syncBlockRequestedSize
             * @property {number|Long|null} [unFetchSynNum] PeerInfo unFetchSynNum
             * @property {number|null} [blockInPorcSize] PeerInfo blockInPorcSize
             * @property {string|null} [headBlockWeBothHave] PeerInfo headBlockWeBothHave
             * @property {boolean|null} [isActive] PeerInfo isActive
             * @property {number|null} [score] PeerInfo score
             * @property {number|null} [nodeCount] PeerInfo nodeCount
             * @property {number|Long|null} [inFlow] PeerInfo inFlow
             * @property {number|null} [disconnectTimes] PeerInfo disconnectTimes
             * @property {string|null} [localDisconnectReason] PeerInfo localDisconnectReason
             * @property {string|null} [remoteDisconnectReason] PeerInfo remoteDisconnectReason
             */

            /**
             * Constructs a new PeerInfo.
             * @memberof protocol.NodeInfo
             * @classdesc Represents a PeerInfo.
             * @implements IPeerInfo
             * @constructor
             * @param {protocol.NodeInfo.IPeerInfo=} [properties] Properties to set
             */
            function PeerInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PeerInfo lastSyncBlock.
             * @member {string} lastSyncBlock
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.lastSyncBlock = "";

            /**
             * PeerInfo remainNum.
             * @member {number|Long} remainNum
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.remainNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo lastBlockUpdateTime.
             * @member {number|Long} lastBlockUpdateTime
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.lastBlockUpdateTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo syncFlag.
             * @member {boolean} syncFlag
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncFlag = false;

            /**
             * PeerInfo headBlockTimeWeBothHave.
             * @member {number|Long} headBlockTimeWeBothHave
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.headBlockTimeWeBothHave = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo needSyncFromPeer.
             * @member {boolean} needSyncFromPeer
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.needSyncFromPeer = false;

            /**
             * PeerInfo needSyncFromUs.
             * @member {boolean} needSyncFromUs
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.needSyncFromUs = false;

            /**
             * PeerInfo host.
             * @member {string} host
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.host = "";

            /**
             * PeerInfo port.
             * @member {number} port
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.port = 0;

            /**
             * PeerInfo nodeId.
             * @member {string} nodeId
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.nodeId = "";

            /**
             * PeerInfo connectTime.
             * @member {number|Long} connectTime
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.connectTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo avgLatency.
             * @member {number} avgLatency
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.avgLatency = 0;

            /**
             * PeerInfo syncToFetchSize.
             * @member {number} syncToFetchSize
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncToFetchSize = 0;

            /**
             * PeerInfo syncToFetchSizePeekNum.
             * @member {number|Long} syncToFetchSizePeekNum
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncToFetchSizePeekNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo syncBlockRequestedSize.
             * @member {number} syncBlockRequestedSize
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.syncBlockRequestedSize = 0;

            /**
             * PeerInfo unFetchSynNum.
             * @member {number|Long} unFetchSynNum
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.unFetchSynNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo blockInPorcSize.
             * @member {number} blockInPorcSize
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.blockInPorcSize = 0;

            /**
             * PeerInfo headBlockWeBothHave.
             * @member {string} headBlockWeBothHave
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.headBlockWeBothHave = "";

            /**
             * PeerInfo isActive.
             * @member {boolean} isActive
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.isActive = false;

            /**
             * PeerInfo score.
             * @member {number} score
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.score = 0;

            /**
             * PeerInfo nodeCount.
             * @member {number} nodeCount
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.nodeCount = 0;

            /**
             * PeerInfo inFlow.
             * @member {number|Long} inFlow
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.inFlow = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PeerInfo disconnectTimes.
             * @member {number} disconnectTimes
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.disconnectTimes = 0;

            /**
             * PeerInfo localDisconnectReason.
             * @member {string} localDisconnectReason
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.localDisconnectReason = "";

            /**
             * PeerInfo remoteDisconnectReason.
             * @member {string} remoteDisconnectReason
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             */
            PeerInfo.prototype.remoteDisconnectReason = "";

            /**
             * Creates a new PeerInfo instance using the specified properties.
             * @function create
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.IPeerInfo=} [properties] Properties to set
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo instance
             */
            PeerInfo.create = function create(properties) {
                return new PeerInfo(properties);
            };

            /**
             * Encodes the specified PeerInfo message. Does not implicitly {@link protocol.NodeInfo.PeerInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.IPeerInfo} message PeerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.lastSyncBlock);
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.remainNum);
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastBlockUpdateTime);
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.syncFlag);
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.headBlockTimeWeBothHave);
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.needSyncFromPeer);
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.needSyncFromUs);
                if (message.host != null && message.hasOwnProperty("host"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.host);
                if (message.port != null && message.hasOwnProperty("port"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.port);
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.nodeId);
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.connectTime);
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    writer.uint32(/* id 12, wireType 1 =*/97).double(message.avgLatency);
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.syncToFetchSize);
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.syncToFetchSizePeekNum);
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.syncBlockRequestedSize);
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int64(message.unFetchSynNum);
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.blockInPorcSize);
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    writer.uint32(/* id 18, wireType 2 =*/146).string(message.headBlockWeBothHave);
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    writer.uint32(/* id 19, wireType 0 =*/152).bool(message.isActive);
                if (message.score != null && message.hasOwnProperty("score"))
                    writer.uint32(/* id 20, wireType 0 =*/160).int32(message.score);
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    writer.uint32(/* id 21, wireType 0 =*/168).int32(message.nodeCount);
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    writer.uint32(/* id 22, wireType 0 =*/176).int64(message.inFlow);
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    writer.uint32(/* id 23, wireType 0 =*/184).int32(message.disconnectTimes);
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.localDisconnectReason);
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    writer.uint32(/* id 25, wireType 2 =*/202).string(message.remoteDisconnectReason);
                return writer;
            };

            /**
             * Encodes the specified PeerInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.PeerInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.IPeerInfo} message PeerInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PeerInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PeerInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.PeerInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.lastSyncBlock = reader.string();
                        break;
                    case 2:
                        message.remainNum = reader.int64();
                        break;
                    case 3:
                        message.lastBlockUpdateTime = reader.int64();
                        break;
                    case 4:
                        message.syncFlag = reader.bool();
                        break;
                    case 5:
                        message.headBlockTimeWeBothHave = reader.int64();
                        break;
                    case 6:
                        message.needSyncFromPeer = reader.bool();
                        break;
                    case 7:
                        message.needSyncFromUs = reader.bool();
                        break;
                    case 8:
                        message.host = reader.string();
                        break;
                    case 9:
                        message.port = reader.int32();
                        break;
                    case 10:
                        message.nodeId = reader.string();
                        break;
                    case 11:
                        message.connectTime = reader.int64();
                        break;
                    case 12:
                        message.avgLatency = reader.double();
                        break;
                    case 13:
                        message.syncToFetchSize = reader.int32();
                        break;
                    case 14:
                        message.syncToFetchSizePeekNum = reader.int64();
                        break;
                    case 15:
                        message.syncBlockRequestedSize = reader.int32();
                        break;
                    case 16:
                        message.unFetchSynNum = reader.int64();
                        break;
                    case 17:
                        message.blockInPorcSize = reader.int32();
                        break;
                    case 18:
                        message.headBlockWeBothHave = reader.string();
                        break;
                    case 19:
                        message.isActive = reader.bool();
                        break;
                    case 20:
                        message.score = reader.int32();
                        break;
                    case 21:
                        message.nodeCount = reader.int32();
                        break;
                    case 22:
                        message.inFlow = reader.int64();
                        break;
                    case 23:
                        message.disconnectTimes = reader.int32();
                        break;
                    case 24:
                        message.localDisconnectReason = reader.string();
                        break;
                    case 25:
                        message.remoteDisconnectReason = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PeerInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PeerInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PeerInfo message.
             * @function verify
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PeerInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    if (!$util.isString(message.lastSyncBlock))
                        return "lastSyncBlock: string expected";
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    if (!$util.isInteger(message.remainNum) && !(message.remainNum && $util.isInteger(message.remainNum.low) && $util.isInteger(message.remainNum.high)))
                        return "remainNum: integer|Long expected";
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    if (!$util.isInteger(message.lastBlockUpdateTime) && !(message.lastBlockUpdateTime && $util.isInteger(message.lastBlockUpdateTime.low) && $util.isInteger(message.lastBlockUpdateTime.high)))
                        return "lastBlockUpdateTime: integer|Long expected";
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    if (typeof message.syncFlag !== "boolean")
                        return "syncFlag: boolean expected";
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    if (!$util.isInteger(message.headBlockTimeWeBothHave) && !(message.headBlockTimeWeBothHave && $util.isInteger(message.headBlockTimeWeBothHave.low) && $util.isInteger(message.headBlockTimeWeBothHave.high)))
                        return "headBlockTimeWeBothHave: integer|Long expected";
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    if (typeof message.needSyncFromPeer !== "boolean")
                        return "needSyncFromPeer: boolean expected";
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    if (typeof message.needSyncFromUs !== "boolean")
                        return "needSyncFromUs: boolean expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    if (!$util.isString(message.nodeId))
                        return "nodeId: string expected";
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    if (!$util.isInteger(message.connectTime) && !(message.connectTime && $util.isInteger(message.connectTime.low) && $util.isInteger(message.connectTime.high)))
                        return "connectTime: integer|Long expected";
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    if (typeof message.avgLatency !== "number")
                        return "avgLatency: number expected";
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    if (!$util.isInteger(message.syncToFetchSize))
                        return "syncToFetchSize: integer expected";
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    if (!$util.isInteger(message.syncToFetchSizePeekNum) && !(message.syncToFetchSizePeekNum && $util.isInteger(message.syncToFetchSizePeekNum.low) && $util.isInteger(message.syncToFetchSizePeekNum.high)))
                        return "syncToFetchSizePeekNum: integer|Long expected";
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    if (!$util.isInteger(message.syncBlockRequestedSize))
                        return "syncBlockRequestedSize: integer expected";
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    if (!$util.isInteger(message.unFetchSynNum) && !(message.unFetchSynNum && $util.isInteger(message.unFetchSynNum.low) && $util.isInteger(message.unFetchSynNum.high)))
                        return "unFetchSynNum: integer|Long expected";
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    if (!$util.isInteger(message.blockInPorcSize))
                        return "blockInPorcSize: integer expected";
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    if (!$util.isString(message.headBlockWeBothHave))
                        return "headBlockWeBothHave: string expected";
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    if (typeof message.isActive !== "boolean")
                        return "isActive: boolean expected";
                if (message.score != null && message.hasOwnProperty("score"))
                    if (!$util.isInteger(message.score))
                        return "score: integer expected";
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    if (!$util.isInteger(message.nodeCount))
                        return "nodeCount: integer expected";
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    if (!$util.isInteger(message.inFlow) && !(message.inFlow && $util.isInteger(message.inFlow.low) && $util.isInteger(message.inFlow.high)))
                        return "inFlow: integer|Long expected";
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    if (!$util.isInteger(message.disconnectTimes))
                        return "disconnectTimes: integer expected";
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    if (!$util.isString(message.localDisconnectReason))
                        return "localDisconnectReason: string expected";
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    if (!$util.isString(message.remoteDisconnectReason))
                        return "remoteDisconnectReason: string expected";
                return null;
            };

            /**
             * Creates a PeerInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.NodeInfo.PeerInfo} PeerInfo
             */
            PeerInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.PeerInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.PeerInfo();
                if (object.lastSyncBlock != null)
                    message.lastSyncBlock = String(object.lastSyncBlock);
                if (object.remainNum != null)
                    if ($util.Long)
                        (message.remainNum = $util.Long.fromValue(object.remainNum)).unsigned = false;
                    else if (typeof object.remainNum === "string")
                        message.remainNum = parseInt(object.remainNum, 10);
                    else if (typeof object.remainNum === "number")
                        message.remainNum = object.remainNum;
                    else if (typeof object.remainNum === "object")
                        message.remainNum = new $util.LongBits(object.remainNum.low >>> 0, object.remainNum.high >>> 0).toNumber();
                if (object.lastBlockUpdateTime != null)
                    if ($util.Long)
                        (message.lastBlockUpdateTime = $util.Long.fromValue(object.lastBlockUpdateTime)).unsigned = false;
                    else if (typeof object.lastBlockUpdateTime === "string")
                        message.lastBlockUpdateTime = parseInt(object.lastBlockUpdateTime, 10);
                    else if (typeof object.lastBlockUpdateTime === "number")
                        message.lastBlockUpdateTime = object.lastBlockUpdateTime;
                    else if (typeof object.lastBlockUpdateTime === "object")
                        message.lastBlockUpdateTime = new $util.LongBits(object.lastBlockUpdateTime.low >>> 0, object.lastBlockUpdateTime.high >>> 0).toNumber();
                if (object.syncFlag != null)
                    message.syncFlag = Boolean(object.syncFlag);
                if (object.headBlockTimeWeBothHave != null)
                    if ($util.Long)
                        (message.headBlockTimeWeBothHave = $util.Long.fromValue(object.headBlockTimeWeBothHave)).unsigned = false;
                    else if (typeof object.headBlockTimeWeBothHave === "string")
                        message.headBlockTimeWeBothHave = parseInt(object.headBlockTimeWeBothHave, 10);
                    else if (typeof object.headBlockTimeWeBothHave === "number")
                        message.headBlockTimeWeBothHave = object.headBlockTimeWeBothHave;
                    else if (typeof object.headBlockTimeWeBothHave === "object")
                        message.headBlockTimeWeBothHave = new $util.LongBits(object.headBlockTimeWeBothHave.low >>> 0, object.headBlockTimeWeBothHave.high >>> 0).toNumber();
                if (object.needSyncFromPeer != null)
                    message.needSyncFromPeer = Boolean(object.needSyncFromPeer);
                if (object.needSyncFromUs != null)
                    message.needSyncFromUs = Boolean(object.needSyncFromUs);
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                if (object.nodeId != null)
                    message.nodeId = String(object.nodeId);
                if (object.connectTime != null)
                    if ($util.Long)
                        (message.connectTime = $util.Long.fromValue(object.connectTime)).unsigned = false;
                    else if (typeof object.connectTime === "string")
                        message.connectTime = parseInt(object.connectTime, 10);
                    else if (typeof object.connectTime === "number")
                        message.connectTime = object.connectTime;
                    else if (typeof object.connectTime === "object")
                        message.connectTime = new $util.LongBits(object.connectTime.low >>> 0, object.connectTime.high >>> 0).toNumber();
                if (object.avgLatency != null)
                    message.avgLatency = Number(object.avgLatency);
                if (object.syncToFetchSize != null)
                    message.syncToFetchSize = object.syncToFetchSize | 0;
                if (object.syncToFetchSizePeekNum != null)
                    if ($util.Long)
                        (message.syncToFetchSizePeekNum = $util.Long.fromValue(object.syncToFetchSizePeekNum)).unsigned = false;
                    else if (typeof object.syncToFetchSizePeekNum === "string")
                        message.syncToFetchSizePeekNum = parseInt(object.syncToFetchSizePeekNum, 10);
                    else if (typeof object.syncToFetchSizePeekNum === "number")
                        message.syncToFetchSizePeekNum = object.syncToFetchSizePeekNum;
                    else if (typeof object.syncToFetchSizePeekNum === "object")
                        message.syncToFetchSizePeekNum = new $util.LongBits(object.syncToFetchSizePeekNum.low >>> 0, object.syncToFetchSizePeekNum.high >>> 0).toNumber();
                if (object.syncBlockRequestedSize != null)
                    message.syncBlockRequestedSize = object.syncBlockRequestedSize | 0;
                if (object.unFetchSynNum != null)
                    if ($util.Long)
                        (message.unFetchSynNum = $util.Long.fromValue(object.unFetchSynNum)).unsigned = false;
                    else if (typeof object.unFetchSynNum === "string")
                        message.unFetchSynNum = parseInt(object.unFetchSynNum, 10);
                    else if (typeof object.unFetchSynNum === "number")
                        message.unFetchSynNum = object.unFetchSynNum;
                    else if (typeof object.unFetchSynNum === "object")
                        message.unFetchSynNum = new $util.LongBits(object.unFetchSynNum.low >>> 0, object.unFetchSynNum.high >>> 0).toNumber();
                if (object.blockInPorcSize != null)
                    message.blockInPorcSize = object.blockInPorcSize | 0;
                if (object.headBlockWeBothHave != null)
                    message.headBlockWeBothHave = String(object.headBlockWeBothHave);
                if (object.isActive != null)
                    message.isActive = Boolean(object.isActive);
                if (object.score != null)
                    message.score = object.score | 0;
                if (object.nodeCount != null)
                    message.nodeCount = object.nodeCount | 0;
                if (object.inFlow != null)
                    if ($util.Long)
                        (message.inFlow = $util.Long.fromValue(object.inFlow)).unsigned = false;
                    else if (typeof object.inFlow === "string")
                        message.inFlow = parseInt(object.inFlow, 10);
                    else if (typeof object.inFlow === "number")
                        message.inFlow = object.inFlow;
                    else if (typeof object.inFlow === "object")
                        message.inFlow = new $util.LongBits(object.inFlow.low >>> 0, object.inFlow.high >>> 0).toNumber();
                if (object.disconnectTimes != null)
                    message.disconnectTimes = object.disconnectTimes | 0;
                if (object.localDisconnectReason != null)
                    message.localDisconnectReason = String(object.localDisconnectReason);
                if (object.remoteDisconnectReason != null)
                    message.remoteDisconnectReason = String(object.remoteDisconnectReason);
                return message;
            };

            /**
             * Creates a plain object from a PeerInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.NodeInfo.PeerInfo
             * @static
             * @param {protocol.NodeInfo.PeerInfo} message PeerInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PeerInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.lastSyncBlock = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.remainNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remainNum = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.lastBlockUpdateTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastBlockUpdateTime = options.longs === String ? "0" : 0;
                    object.syncFlag = false;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.headBlockTimeWeBothHave = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.headBlockTimeWeBothHave = options.longs === String ? "0" : 0;
                    object.needSyncFromPeer = false;
                    object.needSyncFromUs = false;
                    object.host = "";
                    object.port = 0;
                    object.nodeId = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.connectTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.connectTime = options.longs === String ? "0" : 0;
                    object.avgLatency = 0;
                    object.syncToFetchSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.syncToFetchSizePeekNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.syncToFetchSizePeekNum = options.longs === String ? "0" : 0;
                    object.syncBlockRequestedSize = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.unFetchSynNum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.unFetchSynNum = options.longs === String ? "0" : 0;
                    object.blockInPorcSize = 0;
                    object.headBlockWeBothHave = "";
                    object.isActive = false;
                    object.score = 0;
                    object.nodeCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.inFlow = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inFlow = options.longs === String ? "0" : 0;
                    object.disconnectTimes = 0;
                    object.localDisconnectReason = "";
                    object.remoteDisconnectReason = "";
                }
                if (message.lastSyncBlock != null && message.hasOwnProperty("lastSyncBlock"))
                    object.lastSyncBlock = message.lastSyncBlock;
                if (message.remainNum != null && message.hasOwnProperty("remainNum"))
                    if (typeof message.remainNum === "number")
                        object.remainNum = options.longs === String ? String(message.remainNum) : message.remainNum;
                    else
                        object.remainNum = options.longs === String ? $util.Long.prototype.toString.call(message.remainNum) : options.longs === Number ? new $util.LongBits(message.remainNum.low >>> 0, message.remainNum.high >>> 0).toNumber() : message.remainNum;
                if (message.lastBlockUpdateTime != null && message.hasOwnProperty("lastBlockUpdateTime"))
                    if (typeof message.lastBlockUpdateTime === "number")
                        object.lastBlockUpdateTime = options.longs === String ? String(message.lastBlockUpdateTime) : message.lastBlockUpdateTime;
                    else
                        object.lastBlockUpdateTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastBlockUpdateTime) : options.longs === Number ? new $util.LongBits(message.lastBlockUpdateTime.low >>> 0, message.lastBlockUpdateTime.high >>> 0).toNumber() : message.lastBlockUpdateTime;
                if (message.syncFlag != null && message.hasOwnProperty("syncFlag"))
                    object.syncFlag = message.syncFlag;
                if (message.headBlockTimeWeBothHave != null && message.hasOwnProperty("headBlockTimeWeBothHave"))
                    if (typeof message.headBlockTimeWeBothHave === "number")
                        object.headBlockTimeWeBothHave = options.longs === String ? String(message.headBlockTimeWeBothHave) : message.headBlockTimeWeBothHave;
                    else
                        object.headBlockTimeWeBothHave = options.longs === String ? $util.Long.prototype.toString.call(message.headBlockTimeWeBothHave) : options.longs === Number ? new $util.LongBits(message.headBlockTimeWeBothHave.low >>> 0, message.headBlockTimeWeBothHave.high >>> 0).toNumber() : message.headBlockTimeWeBothHave;
                if (message.needSyncFromPeer != null && message.hasOwnProperty("needSyncFromPeer"))
                    object.needSyncFromPeer = message.needSyncFromPeer;
                if (message.needSyncFromUs != null && message.hasOwnProperty("needSyncFromUs"))
                    object.needSyncFromUs = message.needSyncFromUs;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                    object.nodeId = message.nodeId;
                if (message.connectTime != null && message.hasOwnProperty("connectTime"))
                    if (typeof message.connectTime === "number")
                        object.connectTime = options.longs === String ? String(message.connectTime) : message.connectTime;
                    else
                        object.connectTime = options.longs === String ? $util.Long.prototype.toString.call(message.connectTime) : options.longs === Number ? new $util.LongBits(message.connectTime.low >>> 0, message.connectTime.high >>> 0).toNumber() : message.connectTime;
                if (message.avgLatency != null && message.hasOwnProperty("avgLatency"))
                    object.avgLatency = options.json && !isFinite(message.avgLatency) ? String(message.avgLatency) : message.avgLatency;
                if (message.syncToFetchSize != null && message.hasOwnProperty("syncToFetchSize"))
                    object.syncToFetchSize = message.syncToFetchSize;
                if (message.syncToFetchSizePeekNum != null && message.hasOwnProperty("syncToFetchSizePeekNum"))
                    if (typeof message.syncToFetchSizePeekNum === "number")
                        object.syncToFetchSizePeekNum = options.longs === String ? String(message.syncToFetchSizePeekNum) : message.syncToFetchSizePeekNum;
                    else
                        object.syncToFetchSizePeekNum = options.longs === String ? $util.Long.prototype.toString.call(message.syncToFetchSizePeekNum) : options.longs === Number ? new $util.LongBits(message.syncToFetchSizePeekNum.low >>> 0, message.syncToFetchSizePeekNum.high >>> 0).toNumber() : message.syncToFetchSizePeekNum;
                if (message.syncBlockRequestedSize != null && message.hasOwnProperty("syncBlockRequestedSize"))
                    object.syncBlockRequestedSize = message.syncBlockRequestedSize;
                if (message.unFetchSynNum != null && message.hasOwnProperty("unFetchSynNum"))
                    if (typeof message.unFetchSynNum === "number")
                        object.unFetchSynNum = options.longs === String ? String(message.unFetchSynNum) : message.unFetchSynNum;
                    else
                        object.unFetchSynNum = options.longs === String ? $util.Long.prototype.toString.call(message.unFetchSynNum) : options.longs === Number ? new $util.LongBits(message.unFetchSynNum.low >>> 0, message.unFetchSynNum.high >>> 0).toNumber() : message.unFetchSynNum;
                if (message.blockInPorcSize != null && message.hasOwnProperty("blockInPorcSize"))
                    object.blockInPorcSize = message.blockInPorcSize;
                if (message.headBlockWeBothHave != null && message.hasOwnProperty("headBlockWeBothHave"))
                    object.headBlockWeBothHave = message.headBlockWeBothHave;
                if (message.isActive != null && message.hasOwnProperty("isActive"))
                    object.isActive = message.isActive;
                if (message.score != null && message.hasOwnProperty("score"))
                    object.score = message.score;
                if (message.nodeCount != null && message.hasOwnProperty("nodeCount"))
                    object.nodeCount = message.nodeCount;
                if (message.inFlow != null && message.hasOwnProperty("inFlow"))
                    if (typeof message.inFlow === "number")
                        object.inFlow = options.longs === String ? String(message.inFlow) : message.inFlow;
                    else
                        object.inFlow = options.longs === String ? $util.Long.prototype.toString.call(message.inFlow) : options.longs === Number ? new $util.LongBits(message.inFlow.low >>> 0, message.inFlow.high >>> 0).toNumber() : message.inFlow;
                if (message.disconnectTimes != null && message.hasOwnProperty("disconnectTimes"))
                    object.disconnectTimes = message.disconnectTimes;
                if (message.localDisconnectReason != null && message.hasOwnProperty("localDisconnectReason"))
                    object.localDisconnectReason = message.localDisconnectReason;
                if (message.remoteDisconnectReason != null && message.hasOwnProperty("remoteDisconnectReason"))
                    object.remoteDisconnectReason = message.remoteDisconnectReason;
                return object;
            };

            /**
             * Converts this PeerInfo to JSON.
             * @function toJSON
             * @memberof protocol.NodeInfo.PeerInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PeerInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PeerInfo;
        })();

        NodeInfo.ConfigNodeInfo = (function() {

            /**
             * Properties of a ConfigNodeInfo.
             * @memberof protocol.NodeInfo
             * @interface IConfigNodeInfo
             * @property {string|null} [codeVersion] ConfigNodeInfo codeVersion
             * @property {string|null} [p2pVersion] ConfigNodeInfo p2pVersion
             * @property {number|null} [listenPort] ConfigNodeInfo listenPort
             * @property {boolean|null} [discoverEnable] ConfigNodeInfo discoverEnable
             * @property {number|null} [activeNodeSize] ConfigNodeInfo activeNodeSize
             * @property {number|null} [passiveNodeSize] ConfigNodeInfo passiveNodeSize
             * @property {number|null} [sendNodeSize] ConfigNodeInfo sendNodeSize
             * @property {number|null} [maxConnectCount] ConfigNodeInfo maxConnectCount
             * @property {number|null} [sameIpMaxConnectCount] ConfigNodeInfo sameIpMaxConnectCount
             * @property {number|null} [backupListenPort] ConfigNodeInfo backupListenPort
             * @property {number|null} [backupMemberSize] ConfigNodeInfo backupMemberSize
             * @property {number|null} [backupPriority] ConfigNodeInfo backupPriority
             * @property {number|null} [dbVersion] ConfigNodeInfo dbVersion
             * @property {number|null} [minParticipationRate] ConfigNodeInfo minParticipationRate
             * @property {boolean|null} [supportConstant] ConfigNodeInfo supportConstant
             * @property {number|null} [minTimeRatio] ConfigNodeInfo minTimeRatio
             * @property {number|null} [maxTimeRatio] ConfigNodeInfo maxTimeRatio
             * @property {number|Long|null} [allowCreationOfContracts] ConfigNodeInfo allowCreationOfContracts
             * @property {number|Long|null} [allowAdaptiveEnergy] ConfigNodeInfo allowAdaptiveEnergy
             */

            /**
             * Constructs a new ConfigNodeInfo.
             * @memberof protocol.NodeInfo
             * @classdesc Represents a ConfigNodeInfo.
             * @implements IConfigNodeInfo
             * @constructor
             * @param {protocol.NodeInfo.IConfigNodeInfo=} [properties] Properties to set
             */
            function ConfigNodeInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ConfigNodeInfo codeVersion.
             * @member {string} codeVersion
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.codeVersion = "";

            /**
             * ConfigNodeInfo p2pVersion.
             * @member {string} p2pVersion
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.p2pVersion = "";

            /**
             * ConfigNodeInfo listenPort.
             * @member {number} listenPort
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.listenPort = 0;

            /**
             * ConfigNodeInfo discoverEnable.
             * @member {boolean} discoverEnable
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.discoverEnable = false;

            /**
             * ConfigNodeInfo activeNodeSize.
             * @member {number} activeNodeSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.activeNodeSize = 0;

            /**
             * ConfigNodeInfo passiveNodeSize.
             * @member {number} passiveNodeSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.passiveNodeSize = 0;

            /**
             * ConfigNodeInfo sendNodeSize.
             * @member {number} sendNodeSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.sendNodeSize = 0;

            /**
             * ConfigNodeInfo maxConnectCount.
             * @member {number} maxConnectCount
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.maxConnectCount = 0;

            /**
             * ConfigNodeInfo sameIpMaxConnectCount.
             * @member {number} sameIpMaxConnectCount
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.sameIpMaxConnectCount = 0;

            /**
             * ConfigNodeInfo backupListenPort.
             * @member {number} backupListenPort
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.backupListenPort = 0;

            /**
             * ConfigNodeInfo backupMemberSize.
             * @member {number} backupMemberSize
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.backupMemberSize = 0;

            /**
             * ConfigNodeInfo backupPriority.
             * @member {number} backupPriority
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.backupPriority = 0;

            /**
             * ConfigNodeInfo dbVersion.
             * @member {number} dbVersion
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.dbVersion = 0;

            /**
             * ConfigNodeInfo minParticipationRate.
             * @member {number} minParticipationRate
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.minParticipationRate = 0;

            /**
             * ConfigNodeInfo supportConstant.
             * @member {boolean} supportConstant
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.supportConstant = false;

            /**
             * ConfigNodeInfo minTimeRatio.
             * @member {number} minTimeRatio
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.minTimeRatio = 0;

            /**
             * ConfigNodeInfo maxTimeRatio.
             * @member {number} maxTimeRatio
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.maxTimeRatio = 0;

            /**
             * ConfigNodeInfo allowCreationOfContracts.
             * @member {number|Long} allowCreationOfContracts
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.allowCreationOfContracts = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ConfigNodeInfo allowAdaptiveEnergy.
             * @member {number|Long} allowAdaptiveEnergy
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             */
            ConfigNodeInfo.prototype.allowAdaptiveEnergy = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new ConfigNodeInfo instance using the specified properties.
             * @function create
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.IConfigNodeInfo=} [properties] Properties to set
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo instance
             */
            ConfigNodeInfo.create = function create(properties) {
                return new ConfigNodeInfo(properties);
            };

            /**
             * Encodes the specified ConfigNodeInfo message. Does not implicitly {@link protocol.NodeInfo.ConfigNodeInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.IConfigNodeInfo} message ConfigNodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigNodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.codeVersion);
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.p2pVersion);
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.listenPort);
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.discoverEnable);
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.activeNodeSize);
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.passiveNodeSize);
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.sendNodeSize);
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.maxConnectCount);
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.sameIpMaxConnectCount);
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.backupListenPort);
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.backupMemberSize);
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.backupPriority);
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.dbVersion);
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int32(message.minParticipationRate);
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    writer.uint32(/* id 15, wireType 0 =*/120).bool(message.supportConstant);
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    writer.uint32(/* id 16, wireType 1 =*/129).double(message.minTimeRatio);
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    writer.uint32(/* id 17, wireType 1 =*/137).double(message.maxTimeRatio);
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    writer.uint32(/* id 18, wireType 0 =*/144).int64(message.allowCreationOfContracts);
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    writer.uint32(/* id 19, wireType 0 =*/152).int64(message.allowAdaptiveEnergy);
                return writer;
            };

            /**
             * Encodes the specified ConfigNodeInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.ConfigNodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.IConfigNodeInfo} message ConfigNodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConfigNodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConfigNodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigNodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.ConfigNodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.codeVersion = reader.string();
                        break;
                    case 2:
                        message.p2pVersion = reader.string();
                        break;
                    case 3:
                        message.listenPort = reader.int32();
                        break;
                    case 4:
                        message.discoverEnable = reader.bool();
                        break;
                    case 5:
                        message.activeNodeSize = reader.int32();
                        break;
                    case 6:
                        message.passiveNodeSize = reader.int32();
                        break;
                    case 7:
                        message.sendNodeSize = reader.int32();
                        break;
                    case 8:
                        message.maxConnectCount = reader.int32();
                        break;
                    case 9:
                        message.sameIpMaxConnectCount = reader.int32();
                        break;
                    case 10:
                        message.backupListenPort = reader.int32();
                        break;
                    case 11:
                        message.backupMemberSize = reader.int32();
                        break;
                    case 12:
                        message.backupPriority = reader.int32();
                        break;
                    case 13:
                        message.dbVersion = reader.int32();
                        break;
                    case 14:
                        message.minParticipationRate = reader.int32();
                        break;
                    case 15:
                        message.supportConstant = reader.bool();
                        break;
                    case 16:
                        message.minTimeRatio = reader.double();
                        break;
                    case 17:
                        message.maxTimeRatio = reader.double();
                        break;
                    case 18:
                        message.allowCreationOfContracts = reader.int64();
                        break;
                    case 19:
                        message.allowAdaptiveEnergy = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConfigNodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConfigNodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConfigNodeInfo message.
             * @function verify
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConfigNodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    if (!$util.isString(message.codeVersion))
                        return "codeVersion: string expected";
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    if (!$util.isString(message.p2pVersion))
                        return "p2pVersion: string expected";
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    if (!$util.isInteger(message.listenPort))
                        return "listenPort: integer expected";
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    if (typeof message.discoverEnable !== "boolean")
                        return "discoverEnable: boolean expected";
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    if (!$util.isInteger(message.activeNodeSize))
                        return "activeNodeSize: integer expected";
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    if (!$util.isInteger(message.passiveNodeSize))
                        return "passiveNodeSize: integer expected";
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    if (!$util.isInteger(message.sendNodeSize))
                        return "sendNodeSize: integer expected";
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    if (!$util.isInteger(message.maxConnectCount))
                        return "maxConnectCount: integer expected";
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    if (!$util.isInteger(message.sameIpMaxConnectCount))
                        return "sameIpMaxConnectCount: integer expected";
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    if (!$util.isInteger(message.backupListenPort))
                        return "backupListenPort: integer expected";
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    if (!$util.isInteger(message.backupMemberSize))
                        return "backupMemberSize: integer expected";
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    if (!$util.isInteger(message.backupPriority))
                        return "backupPriority: integer expected";
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    if (!$util.isInteger(message.dbVersion))
                        return "dbVersion: integer expected";
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    if (!$util.isInteger(message.minParticipationRate))
                        return "minParticipationRate: integer expected";
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    if (typeof message.supportConstant !== "boolean")
                        return "supportConstant: boolean expected";
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    if (typeof message.minTimeRatio !== "number")
                        return "minTimeRatio: number expected";
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    if (typeof message.maxTimeRatio !== "number")
                        return "maxTimeRatio: number expected";
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    if (!$util.isInteger(message.allowCreationOfContracts) && !(message.allowCreationOfContracts && $util.isInteger(message.allowCreationOfContracts.low) && $util.isInteger(message.allowCreationOfContracts.high)))
                        return "allowCreationOfContracts: integer|Long expected";
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    if (!$util.isInteger(message.allowAdaptiveEnergy) && !(message.allowAdaptiveEnergy && $util.isInteger(message.allowAdaptiveEnergy.low) && $util.isInteger(message.allowAdaptiveEnergy.high)))
                        return "allowAdaptiveEnergy: integer|Long expected";
                return null;
            };

            /**
             * Creates a ConfigNodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.NodeInfo.ConfigNodeInfo} ConfigNodeInfo
             */
            ConfigNodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.ConfigNodeInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.ConfigNodeInfo();
                if (object.codeVersion != null)
                    message.codeVersion = String(object.codeVersion);
                if (object.p2pVersion != null)
                    message.p2pVersion = String(object.p2pVersion);
                if (object.listenPort != null)
                    message.listenPort = object.listenPort | 0;
                if (object.discoverEnable != null)
                    message.discoverEnable = Boolean(object.discoverEnable);
                if (object.activeNodeSize != null)
                    message.activeNodeSize = object.activeNodeSize | 0;
                if (object.passiveNodeSize != null)
                    message.passiveNodeSize = object.passiveNodeSize | 0;
                if (object.sendNodeSize != null)
                    message.sendNodeSize = object.sendNodeSize | 0;
                if (object.maxConnectCount != null)
                    message.maxConnectCount = object.maxConnectCount | 0;
                if (object.sameIpMaxConnectCount != null)
                    message.sameIpMaxConnectCount = object.sameIpMaxConnectCount | 0;
                if (object.backupListenPort != null)
                    message.backupListenPort = object.backupListenPort | 0;
                if (object.backupMemberSize != null)
                    message.backupMemberSize = object.backupMemberSize | 0;
                if (object.backupPriority != null)
                    message.backupPriority = object.backupPriority | 0;
                if (object.dbVersion != null)
                    message.dbVersion = object.dbVersion | 0;
                if (object.minParticipationRate != null)
                    message.minParticipationRate = object.minParticipationRate | 0;
                if (object.supportConstant != null)
                    message.supportConstant = Boolean(object.supportConstant);
                if (object.minTimeRatio != null)
                    message.minTimeRatio = Number(object.minTimeRatio);
                if (object.maxTimeRatio != null)
                    message.maxTimeRatio = Number(object.maxTimeRatio);
                if (object.allowCreationOfContracts != null)
                    if ($util.Long)
                        (message.allowCreationOfContracts = $util.Long.fromValue(object.allowCreationOfContracts)).unsigned = false;
                    else if (typeof object.allowCreationOfContracts === "string")
                        message.allowCreationOfContracts = parseInt(object.allowCreationOfContracts, 10);
                    else if (typeof object.allowCreationOfContracts === "number")
                        message.allowCreationOfContracts = object.allowCreationOfContracts;
                    else if (typeof object.allowCreationOfContracts === "object")
                        message.allowCreationOfContracts = new $util.LongBits(object.allowCreationOfContracts.low >>> 0, object.allowCreationOfContracts.high >>> 0).toNumber();
                if (object.allowAdaptiveEnergy != null)
                    if ($util.Long)
                        (message.allowAdaptiveEnergy = $util.Long.fromValue(object.allowAdaptiveEnergy)).unsigned = false;
                    else if (typeof object.allowAdaptiveEnergy === "string")
                        message.allowAdaptiveEnergy = parseInt(object.allowAdaptiveEnergy, 10);
                    else if (typeof object.allowAdaptiveEnergy === "number")
                        message.allowAdaptiveEnergy = object.allowAdaptiveEnergy;
                    else if (typeof object.allowAdaptiveEnergy === "object")
                        message.allowAdaptiveEnergy = new $util.LongBits(object.allowAdaptiveEnergy.low >>> 0, object.allowAdaptiveEnergy.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a ConfigNodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @static
             * @param {protocol.NodeInfo.ConfigNodeInfo} message ConfigNodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConfigNodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.codeVersion = "";
                    object.p2pVersion = "";
                    object.listenPort = 0;
                    object.discoverEnable = false;
                    object.activeNodeSize = 0;
                    object.passiveNodeSize = 0;
                    object.sendNodeSize = 0;
                    object.maxConnectCount = 0;
                    object.sameIpMaxConnectCount = 0;
                    object.backupListenPort = 0;
                    object.backupMemberSize = 0;
                    object.backupPriority = 0;
                    object.dbVersion = 0;
                    object.minParticipationRate = 0;
                    object.supportConstant = false;
                    object.minTimeRatio = 0;
                    object.maxTimeRatio = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.allowCreationOfContracts = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.allowCreationOfContracts = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.allowAdaptiveEnergy = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.allowAdaptiveEnergy = options.longs === String ? "0" : 0;
                }
                if (message.codeVersion != null && message.hasOwnProperty("codeVersion"))
                    object.codeVersion = message.codeVersion;
                if (message.p2pVersion != null && message.hasOwnProperty("p2pVersion"))
                    object.p2pVersion = message.p2pVersion;
                if (message.listenPort != null && message.hasOwnProperty("listenPort"))
                    object.listenPort = message.listenPort;
                if (message.discoverEnable != null && message.hasOwnProperty("discoverEnable"))
                    object.discoverEnable = message.discoverEnable;
                if (message.activeNodeSize != null && message.hasOwnProperty("activeNodeSize"))
                    object.activeNodeSize = message.activeNodeSize;
                if (message.passiveNodeSize != null && message.hasOwnProperty("passiveNodeSize"))
                    object.passiveNodeSize = message.passiveNodeSize;
                if (message.sendNodeSize != null && message.hasOwnProperty("sendNodeSize"))
                    object.sendNodeSize = message.sendNodeSize;
                if (message.maxConnectCount != null && message.hasOwnProperty("maxConnectCount"))
                    object.maxConnectCount = message.maxConnectCount;
                if (message.sameIpMaxConnectCount != null && message.hasOwnProperty("sameIpMaxConnectCount"))
                    object.sameIpMaxConnectCount = message.sameIpMaxConnectCount;
                if (message.backupListenPort != null && message.hasOwnProperty("backupListenPort"))
                    object.backupListenPort = message.backupListenPort;
                if (message.backupMemberSize != null && message.hasOwnProperty("backupMemberSize"))
                    object.backupMemberSize = message.backupMemberSize;
                if (message.backupPriority != null && message.hasOwnProperty("backupPriority"))
                    object.backupPriority = message.backupPriority;
                if (message.dbVersion != null && message.hasOwnProperty("dbVersion"))
                    object.dbVersion = message.dbVersion;
                if (message.minParticipationRate != null && message.hasOwnProperty("minParticipationRate"))
                    object.minParticipationRate = message.minParticipationRate;
                if (message.supportConstant != null && message.hasOwnProperty("supportConstant"))
                    object.supportConstant = message.supportConstant;
                if (message.minTimeRatio != null && message.hasOwnProperty("minTimeRatio"))
                    object.minTimeRatio = options.json && !isFinite(message.minTimeRatio) ? String(message.minTimeRatio) : message.minTimeRatio;
                if (message.maxTimeRatio != null && message.hasOwnProperty("maxTimeRatio"))
                    object.maxTimeRatio = options.json && !isFinite(message.maxTimeRatio) ? String(message.maxTimeRatio) : message.maxTimeRatio;
                if (message.allowCreationOfContracts != null && message.hasOwnProperty("allowCreationOfContracts"))
                    if (typeof message.allowCreationOfContracts === "number")
                        object.allowCreationOfContracts = options.longs === String ? String(message.allowCreationOfContracts) : message.allowCreationOfContracts;
                    else
                        object.allowCreationOfContracts = options.longs === String ? $util.Long.prototype.toString.call(message.allowCreationOfContracts) : options.longs === Number ? new $util.LongBits(message.allowCreationOfContracts.low >>> 0, message.allowCreationOfContracts.high >>> 0).toNumber() : message.allowCreationOfContracts;
                if (message.allowAdaptiveEnergy != null && message.hasOwnProperty("allowAdaptiveEnergy"))
                    if (typeof message.allowAdaptiveEnergy === "number")
                        object.allowAdaptiveEnergy = options.longs === String ? String(message.allowAdaptiveEnergy) : message.allowAdaptiveEnergy;
                    else
                        object.allowAdaptiveEnergy = options.longs === String ? $util.Long.prototype.toString.call(message.allowAdaptiveEnergy) : options.longs === Number ? new $util.LongBits(message.allowAdaptiveEnergy.low >>> 0, message.allowAdaptiveEnergy.high >>> 0).toNumber() : message.allowAdaptiveEnergy;
                return object;
            };

            /**
             * Converts this ConfigNodeInfo to JSON.
             * @function toJSON
             * @memberof protocol.NodeInfo.ConfigNodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConfigNodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ConfigNodeInfo;
        })();

        NodeInfo.MachineInfo = (function() {

            /**
             * Properties of a MachineInfo.
             * @memberof protocol.NodeInfo
             * @interface IMachineInfo
             * @property {number|null} [threadCount] MachineInfo threadCount
             * @property {number|null} [deadLockThreadCount] MachineInfo deadLockThreadCount
             * @property {number|null} [cpuCount] MachineInfo cpuCount
             * @property {number|Long|null} [totalMemory] MachineInfo totalMemory
             * @property {number|Long|null} [freeMemory] MachineInfo freeMemory
             * @property {number|null} [cpuRate] MachineInfo cpuRate
             * @property {string|null} [javaVersion] MachineInfo javaVersion
             * @property {string|null} [osName] MachineInfo osName
             * @property {number|Long|null} [jvmTotalMemoery] MachineInfo jvmTotalMemoery
             * @property {number|Long|null} [jvmFreeMemory] MachineInfo jvmFreeMemory
             * @property {number|null} [processCpuRate] MachineInfo processCpuRate
             * @property {Array.<protocol.NodeInfo.MachineInfo.IMemoryDescInfo>|null} [memoryDescInfoList] MachineInfo memoryDescInfoList
             * @property {Array.<protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo>|null} [deadLockThreadInfoList] MachineInfo deadLockThreadInfoList
             */

            /**
             * Constructs a new MachineInfo.
             * @memberof protocol.NodeInfo
             * @classdesc Represents a MachineInfo.
             * @implements IMachineInfo
             * @constructor
             * @param {protocol.NodeInfo.IMachineInfo=} [properties] Properties to set
             */
            function MachineInfo(properties) {
                this.memoryDescInfoList = [];
                this.deadLockThreadInfoList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MachineInfo threadCount.
             * @member {number} threadCount
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.threadCount = 0;

            /**
             * MachineInfo deadLockThreadCount.
             * @member {number} deadLockThreadCount
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.deadLockThreadCount = 0;

            /**
             * MachineInfo cpuCount.
             * @member {number} cpuCount
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.cpuCount = 0;

            /**
             * MachineInfo totalMemory.
             * @member {number|Long} totalMemory
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.totalMemory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo freeMemory.
             * @member {number|Long} freeMemory
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.freeMemory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo cpuRate.
             * @member {number} cpuRate
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.cpuRate = 0;

            /**
             * MachineInfo javaVersion.
             * @member {string} javaVersion
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.javaVersion = "";

            /**
             * MachineInfo osName.
             * @member {string} osName
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.osName = "";

            /**
             * MachineInfo jvmTotalMemoery.
             * @member {number|Long} jvmTotalMemoery
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.jvmTotalMemoery = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo jvmFreeMemory.
             * @member {number|Long} jvmFreeMemory
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.jvmFreeMemory = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * MachineInfo processCpuRate.
             * @member {number} processCpuRate
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.processCpuRate = 0;

            /**
             * MachineInfo memoryDescInfoList.
             * @member {Array.<protocol.NodeInfo.MachineInfo.IMemoryDescInfo>} memoryDescInfoList
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.memoryDescInfoList = $util.emptyArray;

            /**
             * MachineInfo deadLockThreadInfoList.
             * @member {Array.<protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo>} deadLockThreadInfoList
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             */
            MachineInfo.prototype.deadLockThreadInfoList = $util.emptyArray;

            /**
             * Creates a new MachineInfo instance using the specified properties.
             * @function create
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.IMachineInfo=} [properties] Properties to set
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo instance
             */
            MachineInfo.create = function create(properties) {
                return new MachineInfo(properties);
            };

            /**
             * Encodes the specified MachineInfo message. Does not implicitly {@link protocol.NodeInfo.MachineInfo.verify|verify} messages.
             * @function encode
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.IMachineInfo} message MachineInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MachineInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.threadCount);
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.deadLockThreadCount);
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cpuCount);
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.totalMemory);
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.freeMemory);
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.cpuRate);
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.javaVersion);
                if (message.osName != null && message.hasOwnProperty("osName"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.osName);
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.jvmTotalMemoery);
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.jvmFreeMemory);
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.processCpuRate);
                if (message.memoryDescInfoList != null && message.memoryDescInfoList.length)
                    for (var i = 0; i < message.memoryDescInfoList.length; ++i)
                        $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.encode(message.memoryDescInfoList[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.deadLockThreadInfoList != null && message.deadLockThreadInfoList.length)
                    for (var i = 0; i < message.deadLockThreadInfoList.length; ++i)
                        $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.encode(message.deadLockThreadInfoList[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MachineInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.MachineInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.IMachineInfo} message MachineInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MachineInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MachineInfo message from the specified reader or buffer.
             * @function decode
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MachineInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.threadCount = reader.int32();
                        break;
                    case 2:
                        message.deadLockThreadCount = reader.int32();
                        break;
                    case 3:
                        message.cpuCount = reader.int32();
                        break;
                    case 4:
                        message.totalMemory = reader.int64();
                        break;
                    case 5:
                        message.freeMemory = reader.int64();
                        break;
                    case 6:
                        message.cpuRate = reader.double();
                        break;
                    case 7:
                        message.javaVersion = reader.string();
                        break;
                    case 8:
                        message.osName = reader.string();
                        break;
                    case 9:
                        message.jvmTotalMemoery = reader.int64();
                        break;
                    case 10:
                        message.jvmFreeMemory = reader.int64();
                        break;
                    case 11:
                        message.processCpuRate = reader.double();
                        break;
                    case 12:
                        if (!(message.memoryDescInfoList && message.memoryDescInfoList.length))
                            message.memoryDescInfoList = [];
                        message.memoryDescInfoList.push($root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.decode(reader, reader.uint32()));
                        break;
                    case 13:
                        if (!(message.deadLockThreadInfoList && message.deadLockThreadInfoList.length))
                            message.deadLockThreadInfoList = [];
                        message.deadLockThreadInfoList.push($root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MachineInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MachineInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MachineInfo message.
             * @function verify
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MachineInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    if (!$util.isInteger(message.threadCount))
                        return "threadCount: integer expected";
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    if (!$util.isInteger(message.deadLockThreadCount))
                        return "deadLockThreadCount: integer expected";
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    if (!$util.isInteger(message.cpuCount))
                        return "cpuCount: integer expected";
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    if (!$util.isInteger(message.totalMemory) && !(message.totalMemory && $util.isInteger(message.totalMemory.low) && $util.isInteger(message.totalMemory.high)))
                        return "totalMemory: integer|Long expected";
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    if (!$util.isInteger(message.freeMemory) && !(message.freeMemory && $util.isInteger(message.freeMemory.low) && $util.isInteger(message.freeMemory.high)))
                        return "freeMemory: integer|Long expected";
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    if (typeof message.cpuRate !== "number")
                        return "cpuRate: number expected";
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    if (!$util.isString(message.javaVersion))
                        return "javaVersion: string expected";
                if (message.osName != null && message.hasOwnProperty("osName"))
                    if (!$util.isString(message.osName))
                        return "osName: string expected";
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    if (!$util.isInteger(message.jvmTotalMemoery) && !(message.jvmTotalMemoery && $util.isInteger(message.jvmTotalMemoery.low) && $util.isInteger(message.jvmTotalMemoery.high)))
                        return "jvmTotalMemoery: integer|Long expected";
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    if (!$util.isInteger(message.jvmFreeMemory) && !(message.jvmFreeMemory && $util.isInteger(message.jvmFreeMemory.low) && $util.isInteger(message.jvmFreeMemory.high)))
                        return "jvmFreeMemory: integer|Long expected";
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    if (typeof message.processCpuRate !== "number")
                        return "processCpuRate: number expected";
                if (message.memoryDescInfoList != null && message.hasOwnProperty("memoryDescInfoList")) {
                    if (!Array.isArray(message.memoryDescInfoList))
                        return "memoryDescInfoList: array expected";
                    for (var i = 0; i < message.memoryDescInfoList.length; ++i) {
                        var error = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify(message.memoryDescInfoList[i]);
                        if (error)
                            return "memoryDescInfoList." + error;
                    }
                }
                if (message.deadLockThreadInfoList != null && message.hasOwnProperty("deadLockThreadInfoList")) {
                    if (!Array.isArray(message.deadLockThreadInfoList))
                        return "deadLockThreadInfoList: array expected";
                    for (var i = 0; i < message.deadLockThreadInfoList.length; ++i) {
                        var error = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify(message.deadLockThreadInfoList[i]);
                        if (error)
                            return "deadLockThreadInfoList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MachineInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {protocol.NodeInfo.MachineInfo} MachineInfo
             */
            MachineInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.protocol.NodeInfo.MachineInfo)
                    return object;
                var message = new $root.protocol.NodeInfo.MachineInfo();
                if (object.threadCount != null)
                    message.threadCount = object.threadCount | 0;
                if (object.deadLockThreadCount != null)
                    message.deadLockThreadCount = object.deadLockThreadCount | 0;
                if (object.cpuCount != null)
                    message.cpuCount = object.cpuCount | 0;
                if (object.totalMemory != null)
                    if ($util.Long)
                        (message.totalMemory = $util.Long.fromValue(object.totalMemory)).unsigned = false;
                    else if (typeof object.totalMemory === "string")
                        message.totalMemory = parseInt(object.totalMemory, 10);
                    else if (typeof object.totalMemory === "number")
                        message.totalMemory = object.totalMemory;
                    else if (typeof object.totalMemory === "object")
                        message.totalMemory = new $util.LongBits(object.totalMemory.low >>> 0, object.totalMemory.high >>> 0).toNumber();
                if (object.freeMemory != null)
                    if ($util.Long)
                        (message.freeMemory = $util.Long.fromValue(object.freeMemory)).unsigned = false;
                    else if (typeof object.freeMemory === "string")
                        message.freeMemory = parseInt(object.freeMemory, 10);
                    else if (typeof object.freeMemory === "number")
                        message.freeMemory = object.freeMemory;
                    else if (typeof object.freeMemory === "object")
                        message.freeMemory = new $util.LongBits(object.freeMemory.low >>> 0, object.freeMemory.high >>> 0).toNumber();
                if (object.cpuRate != null)
                    message.cpuRate = Number(object.cpuRate);
                if (object.javaVersion != null)
                    message.javaVersion = String(object.javaVersion);
                if (object.osName != null)
                    message.osName = String(object.osName);
                if (object.jvmTotalMemoery != null)
                    if ($util.Long)
                        (message.jvmTotalMemoery = $util.Long.fromValue(object.jvmTotalMemoery)).unsigned = false;
                    else if (typeof object.jvmTotalMemoery === "string")
                        message.jvmTotalMemoery = parseInt(object.jvmTotalMemoery, 10);
                    else if (typeof object.jvmTotalMemoery === "number")
                        message.jvmTotalMemoery = object.jvmTotalMemoery;
                    else if (typeof object.jvmTotalMemoery === "object")
                        message.jvmTotalMemoery = new $util.LongBits(object.jvmTotalMemoery.low >>> 0, object.jvmTotalMemoery.high >>> 0).toNumber();
                if (object.jvmFreeMemory != null)
                    if ($util.Long)
                        (message.jvmFreeMemory = $util.Long.fromValue(object.jvmFreeMemory)).unsigned = false;
                    else if (typeof object.jvmFreeMemory === "string")
                        message.jvmFreeMemory = parseInt(object.jvmFreeMemory, 10);
                    else if (typeof object.jvmFreeMemory === "number")
                        message.jvmFreeMemory = object.jvmFreeMemory;
                    else if (typeof object.jvmFreeMemory === "object")
                        message.jvmFreeMemory = new $util.LongBits(object.jvmFreeMemory.low >>> 0, object.jvmFreeMemory.high >>> 0).toNumber();
                if (object.processCpuRate != null)
                    message.processCpuRate = Number(object.processCpuRate);
                if (object.memoryDescInfoList) {
                    if (!Array.isArray(object.memoryDescInfoList))
                        throw TypeError(".protocol.NodeInfo.MachineInfo.memoryDescInfoList: array expected");
                    message.memoryDescInfoList = [];
                    for (var i = 0; i < object.memoryDescInfoList.length; ++i) {
                        if (typeof object.memoryDescInfoList[i] !== "object")
                            throw TypeError(".protocol.NodeInfo.MachineInfo.memoryDescInfoList: object expected");
                        message.memoryDescInfoList[i] = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.fromObject(object.memoryDescInfoList[i]);
                    }
                }
                if (object.deadLockThreadInfoList) {
                    if (!Array.isArray(object.deadLockThreadInfoList))
                        throw TypeError(".protocol.NodeInfo.MachineInfo.deadLockThreadInfoList: array expected");
                    message.deadLockThreadInfoList = [];
                    for (var i = 0; i < object.deadLockThreadInfoList.length; ++i) {
                        if (typeof object.deadLockThreadInfoList[i] !== "object")
                            throw TypeError(".protocol.NodeInfo.MachineInfo.deadLockThreadInfoList: object expected");
                        message.deadLockThreadInfoList[i] = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.fromObject(object.deadLockThreadInfoList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MachineInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof protocol.NodeInfo.MachineInfo
             * @static
             * @param {protocol.NodeInfo.MachineInfo} message MachineInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MachineInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.memoryDescInfoList = [];
                    object.deadLockThreadInfoList = [];
                }
                if (options.defaults) {
                    object.threadCount = 0;
                    object.deadLockThreadCount = 0;
                    object.cpuCount = 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.totalMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.totalMemory = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.freeMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.freeMemory = options.longs === String ? "0" : 0;
                    object.cpuRate = 0;
                    object.javaVersion = "";
                    object.osName = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.jvmTotalMemoery = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jvmTotalMemoery = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.jvmFreeMemory = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jvmFreeMemory = options.longs === String ? "0" : 0;
                    object.processCpuRate = 0;
                }
                if (message.threadCount != null && message.hasOwnProperty("threadCount"))
                    object.threadCount = message.threadCount;
                if (message.deadLockThreadCount != null && message.hasOwnProperty("deadLockThreadCount"))
                    object.deadLockThreadCount = message.deadLockThreadCount;
                if (message.cpuCount != null && message.hasOwnProperty("cpuCount"))
                    object.cpuCount = message.cpuCount;
                if (message.totalMemory != null && message.hasOwnProperty("totalMemory"))
                    if (typeof message.totalMemory === "number")
                        object.totalMemory = options.longs === String ? String(message.totalMemory) : message.totalMemory;
                    else
                        object.totalMemory = options.longs === String ? $util.Long.prototype.toString.call(message.totalMemory) : options.longs === Number ? new $util.LongBits(message.totalMemory.low >>> 0, message.totalMemory.high >>> 0).toNumber() : message.totalMemory;
                if (message.freeMemory != null && message.hasOwnProperty("freeMemory"))
                    if (typeof message.freeMemory === "number")
                        object.freeMemory = options.longs === String ? String(message.freeMemory) : message.freeMemory;
                    else
                        object.freeMemory = options.longs === String ? $util.Long.prototype.toString.call(message.freeMemory) : options.longs === Number ? new $util.LongBits(message.freeMemory.low >>> 0, message.freeMemory.high >>> 0).toNumber() : message.freeMemory;
                if (message.cpuRate != null && message.hasOwnProperty("cpuRate"))
                    object.cpuRate = options.json && !isFinite(message.cpuRate) ? String(message.cpuRate) : message.cpuRate;
                if (message.javaVersion != null && message.hasOwnProperty("javaVersion"))
                    object.javaVersion = message.javaVersion;
                if (message.osName != null && message.hasOwnProperty("osName"))
                    object.osName = message.osName;
                if (message.jvmTotalMemoery != null && message.hasOwnProperty("jvmTotalMemoery"))
                    if (typeof message.jvmTotalMemoery === "number")
                        object.jvmTotalMemoery = options.longs === String ? String(message.jvmTotalMemoery) : message.jvmTotalMemoery;
                    else
                        object.jvmTotalMemoery = options.longs === String ? $util.Long.prototype.toString.call(message.jvmTotalMemoery) : options.longs === Number ? new $util.LongBits(message.jvmTotalMemoery.low >>> 0, message.jvmTotalMemoery.high >>> 0).toNumber() : message.jvmTotalMemoery;
                if (message.jvmFreeMemory != null && message.hasOwnProperty("jvmFreeMemory"))
                    if (typeof message.jvmFreeMemory === "number")
                        object.jvmFreeMemory = options.longs === String ? String(message.jvmFreeMemory) : message.jvmFreeMemory;
                    else
                        object.jvmFreeMemory = options.longs === String ? $util.Long.prototype.toString.call(message.jvmFreeMemory) : options.longs === Number ? new $util.LongBits(message.jvmFreeMemory.low >>> 0, message.jvmFreeMemory.high >>> 0).toNumber() : message.jvmFreeMemory;
                if (message.processCpuRate != null && message.hasOwnProperty("processCpuRate"))
                    object.processCpuRate = options.json && !isFinite(message.processCpuRate) ? String(message.processCpuRate) : message.processCpuRate;
                if (message.memoryDescInfoList && message.memoryDescInfoList.length) {
                    object.memoryDescInfoList = [];
                    for (var j = 0; j < message.memoryDescInfoList.length; ++j)
                        object.memoryDescInfoList[j] = $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo.toObject(message.memoryDescInfoList[j], options);
                }
                if (message.deadLockThreadInfoList && message.deadLockThreadInfoList.length) {
                    object.deadLockThreadInfoList = [];
                    for (var j = 0; j < message.deadLockThreadInfoList.length; ++j)
                        object.deadLockThreadInfoList[j] = $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.toObject(message.deadLockThreadInfoList[j], options);
                }
                return object;
            };

            /**
             * Converts this MachineInfo to JSON.
             * @function toJSON
             * @memberof protocol.NodeInfo.MachineInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MachineInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            MachineInfo.MemoryDescInfo = (function() {

                /**
                 * Properties of a MemoryDescInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @interface IMemoryDescInfo
                 * @property {string|null} [name] MemoryDescInfo name
                 * @property {number|Long|null} [initSize] MemoryDescInfo initSize
                 * @property {number|Long|null} [useSize] MemoryDescInfo useSize
                 * @property {number|Long|null} [maxSize] MemoryDescInfo maxSize
                 * @property {number|null} [useRate] MemoryDescInfo useRate
                 */

                /**
                 * Constructs a new MemoryDescInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @classdesc Represents a MemoryDescInfo.
                 * @implements IMemoryDescInfo
                 * @constructor
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo=} [properties] Properties to set
                 */
                function MemoryDescInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MemoryDescInfo name.
                 * @member {string} name
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.name = "";

                /**
                 * MemoryDescInfo initSize.
                 * @member {number|Long} initSize
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.initSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MemoryDescInfo useSize.
                 * @member {number|Long} useSize
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.useSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MemoryDescInfo maxSize.
                 * @member {number|Long} maxSize
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.maxSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * MemoryDescInfo useRate.
                 * @member {number} useRate
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 */
                MemoryDescInfo.prototype.useRate = 0;

                /**
                 * Creates a new MemoryDescInfo instance using the specified properties.
                 * @function create
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo=} [properties] Properties to set
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo instance
                 */
                MemoryDescInfo.create = function create(properties) {
                    return new MemoryDescInfo(properties);
                };

                /**
                 * Encodes the specified MemoryDescInfo message. Does not implicitly {@link protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify|verify} messages.
                 * @function encode
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo} message MemoryDescInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemoryDescInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.initSize);
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int64(message.useSize);
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int64(message.maxSize);
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.useRate);
                    return writer;
                };

                /**
                 * Encodes the specified MemoryDescInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.MachineInfo.MemoryDescInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IMemoryDescInfo} message MemoryDescInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MemoryDescInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MemoryDescInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemoryDescInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.initSize = reader.int64();
                            break;
                        case 3:
                            message.useSize = reader.int64();
                            break;
                        case 4:
                            message.maxSize = reader.int64();
                            break;
                        case 5:
                            message.useRate = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MemoryDescInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MemoryDescInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MemoryDescInfo message.
                 * @function verify
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MemoryDescInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        if (!$util.isInteger(message.initSize) && !(message.initSize && $util.isInteger(message.initSize.low) && $util.isInteger(message.initSize.high)))
                            return "initSize: integer|Long expected";
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        if (!$util.isInteger(message.useSize) && !(message.useSize && $util.isInteger(message.useSize.low) && $util.isInteger(message.useSize.high)))
                            return "useSize: integer|Long expected";
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        if (!$util.isInteger(message.maxSize) && !(message.maxSize && $util.isInteger(message.maxSize.low) && $util.isInteger(message.maxSize.high)))
                            return "maxSize: integer|Long expected";
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        if (typeof message.useRate !== "number")
                            return "useRate: number expected";
                    return null;
                };

                /**
                 * Creates a MemoryDescInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protocol.NodeInfo.MachineInfo.MemoryDescInfo} MemoryDescInfo
                 */
                MemoryDescInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo)
                        return object;
                    var message = new $root.protocol.NodeInfo.MachineInfo.MemoryDescInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.initSize != null)
                        if ($util.Long)
                            (message.initSize = $util.Long.fromValue(object.initSize)).unsigned = false;
                        else if (typeof object.initSize === "string")
                            message.initSize = parseInt(object.initSize, 10);
                        else if (typeof object.initSize === "number")
                            message.initSize = object.initSize;
                        else if (typeof object.initSize === "object")
                            message.initSize = new $util.LongBits(object.initSize.low >>> 0, object.initSize.high >>> 0).toNumber();
                    if (object.useSize != null)
                        if ($util.Long)
                            (message.useSize = $util.Long.fromValue(object.useSize)).unsigned = false;
                        else if (typeof object.useSize === "string")
                            message.useSize = parseInt(object.useSize, 10);
                        else if (typeof object.useSize === "number")
                            message.useSize = object.useSize;
                        else if (typeof object.useSize === "object")
                            message.useSize = new $util.LongBits(object.useSize.low >>> 0, object.useSize.high >>> 0).toNumber();
                    if (object.maxSize != null)
                        if ($util.Long)
                            (message.maxSize = $util.Long.fromValue(object.maxSize)).unsigned = false;
                        else if (typeof object.maxSize === "string")
                            message.maxSize = parseInt(object.maxSize, 10);
                        else if (typeof object.maxSize === "number")
                            message.maxSize = object.maxSize;
                        else if (typeof object.maxSize === "object")
                            message.maxSize = new $util.LongBits(object.maxSize.low >>> 0, object.maxSize.high >>> 0).toNumber();
                    if (object.useRate != null)
                        message.useRate = Number(object.useRate);
                    return message;
                };

                /**
                 * Creates a plain object from a MemoryDescInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.MemoryDescInfo} message MemoryDescInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MemoryDescInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.initSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.initSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.useSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.useSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.maxSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxSize = options.longs === String ? "0" : 0;
                        object.useRate = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.initSize != null && message.hasOwnProperty("initSize"))
                        if (typeof message.initSize === "number")
                            object.initSize = options.longs === String ? String(message.initSize) : message.initSize;
                        else
                            object.initSize = options.longs === String ? $util.Long.prototype.toString.call(message.initSize) : options.longs === Number ? new $util.LongBits(message.initSize.low >>> 0, message.initSize.high >>> 0).toNumber() : message.initSize;
                    if (message.useSize != null && message.hasOwnProperty("useSize"))
                        if (typeof message.useSize === "number")
                            object.useSize = options.longs === String ? String(message.useSize) : message.useSize;
                        else
                            object.useSize = options.longs === String ? $util.Long.prototype.toString.call(message.useSize) : options.longs === Number ? new $util.LongBits(message.useSize.low >>> 0, message.useSize.high >>> 0).toNumber() : message.useSize;
                    if (message.maxSize != null && message.hasOwnProperty("maxSize"))
                        if (typeof message.maxSize === "number")
                            object.maxSize = options.longs === String ? String(message.maxSize) : message.maxSize;
                        else
                            object.maxSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxSize) : options.longs === Number ? new $util.LongBits(message.maxSize.low >>> 0, message.maxSize.high >>> 0).toNumber() : message.maxSize;
                    if (message.useRate != null && message.hasOwnProperty("useRate"))
                        object.useRate = options.json && !isFinite(message.useRate) ? String(message.useRate) : message.useRate;
                    return object;
                };

                /**
                 * Converts this MemoryDescInfo to JSON.
                 * @function toJSON
                 * @memberof protocol.NodeInfo.MachineInfo.MemoryDescInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MemoryDescInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MemoryDescInfo;
            })();

            MachineInfo.DeadLockThreadInfo = (function() {

                /**
                 * Properties of a DeadLockThreadInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @interface IDeadLockThreadInfo
                 * @property {string|null} [name] DeadLockThreadInfo name
                 * @property {string|null} [lockName] DeadLockThreadInfo lockName
                 * @property {string|null} [lockOwner] DeadLockThreadInfo lockOwner
                 * @property {string|null} [state] DeadLockThreadInfo state
                 * @property {number|Long|null} [blockTime] DeadLockThreadInfo blockTime
                 * @property {number|Long|null} [waitTime] DeadLockThreadInfo waitTime
                 * @property {string|null} [stackTrace] DeadLockThreadInfo stackTrace
                 */

                /**
                 * Constructs a new DeadLockThreadInfo.
                 * @memberof protocol.NodeInfo.MachineInfo
                 * @classdesc Represents a DeadLockThreadInfo.
                 * @implements IDeadLockThreadInfo
                 * @constructor
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo=} [properties] Properties to set
                 */
                function DeadLockThreadInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeadLockThreadInfo name.
                 * @member {string} name
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.name = "";

                /**
                 * DeadLockThreadInfo lockName.
                 * @member {string} lockName
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.lockName = "";

                /**
                 * DeadLockThreadInfo lockOwner.
                 * @member {string} lockOwner
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.lockOwner = "";

                /**
                 * DeadLockThreadInfo state.
                 * @member {string} state
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.state = "";

                /**
                 * DeadLockThreadInfo blockTime.
                 * @member {number|Long} blockTime
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.blockTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DeadLockThreadInfo waitTime.
                 * @member {number|Long} waitTime
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.waitTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * DeadLockThreadInfo stackTrace.
                 * @member {string} stackTrace
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 */
                DeadLockThreadInfo.prototype.stackTrace = "";

                /**
                 * Creates a new DeadLockThreadInfo instance using the specified properties.
                 * @function create
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo=} [properties] Properties to set
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo instance
                 */
                DeadLockThreadInfo.create = function create(properties) {
                    return new DeadLockThreadInfo(properties);
                };

                /**
                 * Encodes the specified DeadLockThreadInfo message. Does not implicitly {@link protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify|verify} messages.
                 * @function encode
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo} message DeadLockThreadInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeadLockThreadInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.lockName);
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.lockOwner);
                    if (message.state != null && message.hasOwnProperty("state"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.state);
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.blockTime);
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.waitTime);
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.stackTrace);
                    return writer;
                };

                /**
                 * Encodes the specified DeadLockThreadInfo message, length delimited. Does not implicitly {@link protocol.NodeInfo.MachineInfo.DeadLockThreadInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.IDeadLockThreadInfo} message DeadLockThreadInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeadLockThreadInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeadLockThreadInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeadLockThreadInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.lockName = reader.string();
                            break;
                        case 3:
                            message.lockOwner = reader.string();
                            break;
                        case 4:
                            message.state = reader.string();
                            break;
                        case 5:
                            message.blockTime = reader.int64();
                            break;
                        case 6:
                            message.waitTime = reader.int64();
                            break;
                        case 7:
                            message.stackTrace = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeadLockThreadInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeadLockThreadInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeadLockThreadInfo message.
                 * @function verify
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeadLockThreadInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        if (!$util.isString(message.lockName))
                            return "lockName: string expected";
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        if (!$util.isString(message.lockOwner))
                            return "lockOwner: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        if (!$util.isString(message.state))
                            return "state: string expected";
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        if (!$util.isInteger(message.blockTime) && !(message.blockTime && $util.isInteger(message.blockTime.low) && $util.isInteger(message.blockTime.high)))
                            return "blockTime: integer|Long expected";
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (!$util.isInteger(message.waitTime) && !(message.waitTime && $util.isInteger(message.waitTime.low) && $util.isInteger(message.waitTime.high)))
                            return "waitTime: integer|Long expected";
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        if (!$util.isString(message.stackTrace))
                            return "stackTrace: string expected";
                    return null;
                };

                /**
                 * Creates a DeadLockThreadInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} DeadLockThreadInfo
                 */
                DeadLockThreadInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo)
                        return object;
                    var message = new $root.protocol.NodeInfo.MachineInfo.DeadLockThreadInfo();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.lockName != null)
                        message.lockName = String(object.lockName);
                    if (object.lockOwner != null)
                        message.lockOwner = String(object.lockOwner);
                    if (object.state != null)
                        message.state = String(object.state);
                    if (object.blockTime != null)
                        if ($util.Long)
                            (message.blockTime = $util.Long.fromValue(object.blockTime)).unsigned = false;
                        else if (typeof object.blockTime === "string")
                            message.blockTime = parseInt(object.blockTime, 10);
                        else if (typeof object.blockTime === "number")
                            message.blockTime = object.blockTime;
                        else if (typeof object.blockTime === "object")
                            message.blockTime = new $util.LongBits(object.blockTime.low >>> 0, object.blockTime.high >>> 0).toNumber();
                    if (object.waitTime != null)
                        if ($util.Long)
                            (message.waitTime = $util.Long.fromValue(object.waitTime)).unsigned = false;
                        else if (typeof object.waitTime === "string")
                            message.waitTime = parseInt(object.waitTime, 10);
                        else if (typeof object.waitTime === "number")
                            message.waitTime = object.waitTime;
                        else if (typeof object.waitTime === "object")
                            message.waitTime = new $util.LongBits(object.waitTime.low >>> 0, object.waitTime.high >>> 0).toNumber();
                    if (object.stackTrace != null)
                        message.stackTrace = String(object.stackTrace);
                    return message;
                };

                /**
                 * Creates a plain object from a DeadLockThreadInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @static
                 * @param {protocol.NodeInfo.MachineInfo.DeadLockThreadInfo} message DeadLockThreadInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeadLockThreadInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.lockName = "";
                        object.lockOwner = "";
                        object.state = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.blockTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockTime = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.waitTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.waitTime = options.longs === String ? "0" : 0;
                        object.stackTrace = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.lockName != null && message.hasOwnProperty("lockName"))
                        object.lockName = message.lockName;
                    if (message.lockOwner != null && message.hasOwnProperty("lockOwner"))
                        object.lockOwner = message.lockOwner;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = message.state;
                    if (message.blockTime != null && message.hasOwnProperty("blockTime"))
                        if (typeof message.blockTime === "number")
                            object.blockTime = options.longs === String ? String(message.blockTime) : message.blockTime;
                        else
                            object.blockTime = options.longs === String ? $util.Long.prototype.toString.call(message.blockTime) : options.longs === Number ? new $util.LongBits(message.blockTime.low >>> 0, message.blockTime.high >>> 0).toNumber() : message.blockTime;
                    if (message.waitTime != null && message.hasOwnProperty("waitTime"))
                        if (typeof message.waitTime === "number")
                            object.waitTime = options.longs === String ? String(message.waitTime) : message.waitTime;
                        else
                            object.waitTime = options.longs === String ? $util.Long.prototype.toString.call(message.waitTime) : options.longs === Number ? new $util.LongBits(message.waitTime.low >>> 0, message.waitTime.high >>> 0).toNumber() : message.waitTime;
                    if (message.stackTrace != null && message.hasOwnProperty("stackTrace"))
                        object.stackTrace = message.stackTrace;
                    return object;
                };

                /**
                 * Converts this DeadLockThreadInfo to JSON.
                 * @function toJSON
                 * @memberof protocol.NodeInfo.MachineInfo.DeadLockThreadInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeadLockThreadInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeadLockThreadInfo;
            })();

            return MachineInfo;
        })();

        return NodeInfo;
    })();

    return protocol;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && message.hasOwnProperty("value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
